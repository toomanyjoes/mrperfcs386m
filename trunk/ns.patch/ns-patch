diff -Naur orig.ns-2.33/Makefile.in ns-2.33/Makefile.in
--- orig.ns-2.33/Makefile.in	2008-03-31 22:00:08.000000000 -0400
+++ ns-2.33/Makefile.in	2009-07-07 04:02:20.000000000 -0400
@@ -79,7 +79,7 @@
 	@V_LIBS@ \
 	@V_LIB_X11@ \
 	@V_LIB@ \
-	-lm @LIBS@
+	-lm -L /home/wanggy/lib/ -lxml2 -lz @LIBS@
 #	-L@libdir@ \
 
 CFLAGS	+= $(CCOPT) $(DEFINE) 
@@ -233,6 +233,7 @@
 	webcache/mcache.o webcache/webtraf.o \
 	webcache/webserver.o \
 	webcache/logweb.o \
+	mrperf/mrperf.o mrperf/datalayout.o mrperf/thread.o \
 	empweb/empweb.o \
 	empweb/empftp.o \
 	realaudio/realaudio.o \
diff -Naur orig.ns-2.33/common/packet.cc ns-2.33/common/packet.cc
--- orig.ns-2.33/common/packet.cc	2008-03-31 22:00:25.000000000 -0400
+++ ns-2.33/common/packet.cc	2009-06-27 14:29:02.000000000 -0400
@@ -41,7 +41,7 @@
 #include "flags.h"
 
 p_info packet_info;
-char** p_info::name_;
+const char** p_info::name_;
 unsigned int p_info::nPkt_ = 0;
 PacketClassifier *p_info::pc_ = 0;
 
diff -Naur orig.ns-2.33/common/packet.h ns-2.33/common/packet.h
--- orig.ns-2.33/common/packet.h	2008-03-31 22:00:25.000000000 -0400
+++ ns-2.33/common/packet.h	2009-06-27 14:28:37.000000000 -0400
@@ -272,7 +272,7 @@
 	{
 		if(nPkt_ >= PT_NTYPE+1)
 		        return;
-		char **nameNew = new char*[PT_NTYPE+1];
+		const char **nameNew = new const char*[PT_NTYPE+1];
 		for(unsigned int i = (unsigned int)PT_SMAC+1; i < nPkt_; i++)
 		{
 		        nameNew[i] = name_[i];
@@ -391,7 +391,7 @@
 
 	}
 private:
-	static char** name_;
+	static const char** name_;
 	static unsigned int nPkt_;
 	static PacketClassifier *pc_;
 };
diff -Naur orig.ns-2.33/common/ptypes2tcl.cc ns-2.33/common/ptypes2tcl.cc
--- orig.ns-2.33/common/ptypes2tcl.cc	2008-03-31 22:00:25.000000000 -0400
+++ ns-2.33/common/ptypes2tcl.cc	2009-06-27 14:45:18.000000000 -0400
@@ -10,7 +10,7 @@
 #define TCL2C_INT
 #endif
 
-char** p_info::name_;
+const char** p_info::name_;
 unsigned int p_info::nPkt_ = 0;
 PacketClassifier *p_info::pc_ = 0;
 int p_info::addPacket(char *name)
@@ -26,7 +26,7 @@
 }
 
 void
-printLine(char *s) {
+printLine(const char *s) {
 #ifdef TCL2C_INT
 	for (unsigned int i = 0; i < strlen(s); i++) 
 		if ((i > 0) && ((i % 20) == 0))
diff -Naur orig.ns-2.33/libxml/DOCBparser.h ns-2.33/libxml/DOCBparser.h
--- orig.ns-2.33/libxml/DOCBparser.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/DOCBparser.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,96 @@
+/*
+ * Summary: old DocBook SGML parser
+ * Description: interface for a DocBook SGML non-verifying parser
+ * This code is DEPRECATED, and should not be used anymore.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __DOCB_PARSER_H__
+#define __DOCB_PARSER_H__
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_DOCB_ENABLED
+
+#include <libxml/parser.h>
+#include <libxml/parserInternals.h>
+
+#ifndef IN_LIBXML
+#ifdef __GNUC__
+#warning "The DOCBparser module has been deprecated in libxml2-2.6.0"
+#endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Most of the back-end structures from XML and SGML are shared.
+ */
+typedef xmlParserCtxt docbParserCtxt;
+typedef xmlParserCtxtPtr docbParserCtxtPtr;
+typedef xmlSAXHandler docbSAXHandler;
+typedef xmlSAXHandlerPtr docbSAXHandlerPtr;
+typedef xmlParserInput docbParserInput;
+typedef xmlParserInputPtr docbParserInputPtr;
+typedef xmlDocPtr docbDocPtr;
+
+/*
+ * There is only few public functions.
+ */
+XMLPUBFUN int XMLCALL
+		     docbEncodeEntities(unsigned char *out,
+                                        int *outlen,
+                                        const unsigned char *in,
+                                        int *inlen, int quoteChar);
+
+XMLPUBFUN docbDocPtr XMLCALL             
+		     docbSAXParseDoc   (xmlChar *cur,
+                                        const char *encoding,
+                                        docbSAXHandlerPtr sax,
+                                        void *userData);
+XMLPUBFUN docbDocPtr XMLCALL             
+		     docbParseDoc      (xmlChar *cur,
+                                        const char *encoding);
+XMLPUBFUN docbDocPtr XMLCALL             
+		     docbSAXParseFile  (const char *filename,
+                                        const char *encoding,
+                                        docbSAXHandlerPtr sax,
+                                        void *userData);
+XMLPUBFUN docbDocPtr XMLCALL             
+		     docbParseFile     (const char *filename,
+                                        const char *encoding);
+
+/**
+ * Interfaces for the Push mode.
+ */
+XMLPUBFUN void XMLCALL                  
+		     docbFreeParserCtxt      (docbParserCtxtPtr ctxt);
+XMLPUBFUN docbParserCtxtPtr XMLCALL     
+		     docbCreatePushParserCtxt(docbSAXHandlerPtr sax,
+                                              void *user_data,
+                                              const char *chunk,
+                                              int size,
+                                              const char *filename,
+                                              xmlCharEncoding enc);
+XMLPUBFUN int XMLCALL                   
+		     docbParseChunk          (docbParserCtxtPtr ctxt,
+                                              const char *chunk,
+                                              int size,
+                                              int terminate);
+XMLPUBFUN docbParserCtxtPtr XMLCALL       
+		     docbCreateFileParserCtxt(const char *filename,
+                                              const char *encoding);
+XMLPUBFUN int XMLCALL                   
+		     docbParseDocument       (docbParserCtxtPtr ctxt);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_DOCB_ENABLED */
+
+#endif /* __DOCB_PARSER_H__ */
diff -Naur orig.ns-2.33/libxml/HTMLparser.h ns-2.33/libxml/HTMLparser.h
--- orig.ns-2.33/libxml/HTMLparser.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/HTMLparser.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,303 @@
+/*
+ * Summary: interface for an HTML 4.0 non-verifying parser
+ * Description: this module implements an HTML 4.0 non-verifying parser
+ *              with API compatible with the XML parser ones. It should
+ *              be able to parse "real world" HTML, even if severely
+ *              broken from a specification point of view.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __HTML_PARSER_H__
+#define __HTML_PARSER_H__
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+
+#ifdef LIBXML_HTML_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Most of the back-end structures from XML and HTML are shared.
+ */
+typedef xmlParserCtxt htmlParserCtxt;
+typedef xmlParserCtxtPtr htmlParserCtxtPtr;
+typedef xmlParserNodeInfo htmlParserNodeInfo;
+typedef xmlSAXHandler htmlSAXHandler;
+typedef xmlSAXHandlerPtr htmlSAXHandlerPtr;
+typedef xmlParserInput htmlParserInput;
+typedef xmlParserInputPtr htmlParserInputPtr;
+typedef xmlDocPtr htmlDocPtr;
+typedef xmlNodePtr htmlNodePtr;
+
+/*
+ * Internal description of an HTML element, representing HTML 4.01
+ * and XHTML 1.0 (which share the same structure).
+ */
+typedef struct _htmlElemDesc htmlElemDesc;
+typedef htmlElemDesc *htmlElemDescPtr;
+struct _htmlElemDesc {
+    const char *name;	/* The tag name */
+    char startTag;      /* Whether the start tag can be implied */
+    char endTag;        /* Whether the end tag can be implied */
+    char saveEndTag;    /* Whether the end tag should be saved */
+    char empty;         /* Is this an empty element ? */
+    char depr;          /* Is this a deprecated element ? */
+    char dtd;           /* 1: only in Loose DTD, 2: only Frameset one */
+    char isinline;      /* is this a block 0 or inline 1 element */
+    const char *desc;   /* the description */
+
+/* NRK Jan.2003
+ * New fields encapsulating HTML structure
+ *
+ * Bugs:
+ *	This is a very limited representation.  It fails to tell us when
+ *	an element *requires* subelements (we only have whether they're
+ *	allowed or not), and it doesn't tell us where CDATA and PCDATA
+ *	are allowed.  Some element relationships are not fully represented:
+ *	these are flagged with the word MODIFIER
+ */
+    const char** subelts;		/* allowed sub-elements of this element */
+    const char* defaultsubelt;	/* subelement for suggested auto-repair
+					   if necessary or NULL */
+    const char** attrs_opt;		/* Optional Attributes */
+    const char** attrs_depr;		/* Additional deprecated attributes */
+    const char** attrs_req;		/* Required attributes */
+};
+
+/*
+ * Internal description of an HTML entity.
+ */
+typedef struct _htmlEntityDesc htmlEntityDesc;
+typedef htmlEntityDesc *htmlEntityDescPtr;
+struct _htmlEntityDesc {
+    unsigned int value;	/* the UNICODE value for the character */
+    const char *name;	/* The entity name */
+    const char *desc;   /* the description */
+};
+
+/*
+ * There is only few public functions.
+ */
+XMLPUBFUN const htmlElemDesc * XMLCALL 	
+			htmlTagLookup	(const xmlChar *tag);
+XMLPUBFUN const htmlEntityDesc * XMLCALL 	
+			htmlEntityLookup(const xmlChar *name);
+XMLPUBFUN const htmlEntityDesc * XMLCALL 	
+			htmlEntityValueLookup(unsigned int value);
+
+XMLPUBFUN int XMLCALL			
+			htmlIsAutoClosed(htmlDocPtr doc,
+					 htmlNodePtr elem);
+XMLPUBFUN int XMLCALL			
+			htmlAutoCloseTag(htmlDocPtr doc,
+					 const xmlChar *name,
+					 htmlNodePtr elem);
+XMLPUBFUN const htmlEntityDesc * XMLCALL	
+			htmlParseEntityRef(htmlParserCtxtPtr ctxt,
+					 const xmlChar **str);
+XMLPUBFUN int XMLCALL			
+			htmlParseCharRef(htmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			htmlParseElement(htmlParserCtxtPtr ctxt);
+
+XMLPUBFUN htmlParserCtxtPtr XMLCALL	
+			htmlNewParserCtxt(void);
+
+XMLPUBFUN htmlParserCtxtPtr XMLCALL	
+			htmlCreateMemoryParserCtxt(const char *buffer,
+						   int size);
+
+XMLPUBFUN int XMLCALL			
+			htmlParseDocument(htmlParserCtxtPtr ctxt);
+XMLPUBFUN htmlDocPtr XMLCALL		
+			htmlSAXParseDoc	(xmlChar *cur,
+					 const char *encoding,
+					 htmlSAXHandlerPtr sax,
+					 void *userData);
+XMLPUBFUN htmlDocPtr XMLCALL		
+			htmlParseDoc	(xmlChar *cur,
+					 const char *encoding);
+XMLPUBFUN htmlDocPtr XMLCALL		
+			htmlSAXParseFile(const char *filename,
+					 const char *encoding,
+					 htmlSAXHandlerPtr sax,
+					 void *userData);
+XMLPUBFUN htmlDocPtr XMLCALL		
+			htmlParseFile	(const char *filename,
+					 const char *encoding);
+XMLPUBFUN int XMLCALL			
+			UTF8ToHtml	(unsigned char *out,
+					 int *outlen,
+					 const unsigned char *in,
+					 int *inlen);
+XMLPUBFUN int XMLCALL			
+			htmlEncodeEntities(unsigned char *out,
+					 int *outlen,
+					 const unsigned char *in,
+					 int *inlen, int quoteChar);
+XMLPUBFUN int XMLCALL			
+			htmlIsScriptAttribute(const xmlChar *name);
+XMLPUBFUN int XMLCALL			
+			htmlHandleOmittedElem(int val);
+
+#ifdef LIBXML_PUSH_ENABLED
+/**
+ * Interfaces for the Push mode.
+ */
+XMLPUBFUN htmlParserCtxtPtr XMLCALL	
+			htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,
+						 void *user_data,
+						 const char *chunk,
+						 int size,
+						 const char *filename,
+						 xmlCharEncoding enc);
+XMLPUBFUN int XMLCALL			
+			htmlParseChunk		(htmlParserCtxtPtr ctxt,
+						 const char *chunk,
+						 int size,
+						 int terminate);
+#endif /* LIBXML_PUSH_ENABLED */
+
+XMLPUBFUN void XMLCALL			
+			htmlFreeParserCtxt	(htmlParserCtxtPtr ctxt);
+
+/*
+ * New set of simpler/more flexible APIs
+ */
+/**
+ * xmlParserOption:
+ *
+ * This is the set of XML parser options that can be passed down
+ * to the xmlReadDoc() and similar calls.
+ */
+typedef enum {
+    HTML_PARSE_RECOVER  = 1<<0, /* Relaxed parsing */
+    HTML_PARSE_NOERROR	= 1<<5,	/* suppress error reports */
+    HTML_PARSE_NOWARNING= 1<<6,	/* suppress warning reports */
+    HTML_PARSE_PEDANTIC	= 1<<7,	/* pedantic error reporting */
+    HTML_PARSE_NOBLANKS	= 1<<8,	/* remove blank nodes */
+    HTML_PARSE_NONET	= 1<<11,/* Forbid network access */
+    HTML_PARSE_COMPACT  = 1<<16 /* compact small text nodes */
+} htmlParserOption;
+
+XMLPUBFUN void XMLCALL
+		htmlCtxtReset		(htmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+		htmlCtxtUseOptions	(htmlParserCtxtPtr ctxt,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlReadDoc		(const xmlChar *cur,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlReadFile		(const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlReadMemory		(const char *buffer,
+					 int size,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlReadFd		(int fd,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlReadIO		(xmlInputReadCallback ioread,
+					 xmlInputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlCtxtReadDoc		(xmlParserCtxtPtr ctxt,
+					 const xmlChar *cur,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlCtxtReadFile		(xmlParserCtxtPtr ctxt,
+					 const char *filename,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlCtxtReadMemory		(xmlParserCtxtPtr ctxt,
+					 const char *buffer,
+					 int size,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlCtxtReadFd		(xmlParserCtxtPtr ctxt,
+					 int fd,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlCtxtReadIO		(xmlParserCtxtPtr ctxt,
+					 xmlInputReadCallback ioread,
+					 xmlInputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+
+/* NRK/Jan2003: further knowledge of HTML structure
+ */
+typedef enum {
+  HTML_NA = 0 ,		/* something we don't check at all */
+  HTML_INVALID = 0x1 ,
+  HTML_DEPRECATED = 0x2 ,
+  HTML_VALID = 0x4 ,
+  HTML_REQUIRED = 0xc /* VALID bit set so ( & HTML_VALID ) is TRUE */
+} htmlStatus ;
+
+/* Using htmlElemDesc rather than name here, to emphasise the fact
+   that otherwise there's a lookup overhead
+*/
+XMLPUBFUN htmlStatus XMLCALL htmlAttrAllowed(const htmlElemDesc*, const xmlChar*, int) ;
+XMLPUBFUN int XMLCALL htmlElementAllowedHere(const htmlElemDesc*, const xmlChar*) ;
+XMLPUBFUN htmlStatus XMLCALL htmlElementStatusHere(const htmlElemDesc*, const htmlElemDesc*) ;
+XMLPUBFUN htmlStatus XMLCALL htmlNodeStatus(const htmlNodePtr, int) ;
+/**
+ * htmlDefaultSubelement:
+ * @elt: HTML element
+ *
+ * Returns the default subelement for this element
+ */
+#define htmlDefaultSubelement(elt) elt->defaultsubelt
+/**
+ * htmlElementAllowedHereDesc:
+ * @parent: HTML parent element
+ * @elt: HTML element
+ *
+ * Checks whether an HTML element description may be a
+ * direct child of the specified element.
+ *
+ * Returns 1 if allowed; 0 otherwise.
+ */
+#define htmlElementAllowedHereDesc(parent,elt) \
+	htmlElementAllowedHere((parent), (elt)->name)
+/**
+ * htmlRequiredAttrs:
+ * @elt: HTML element
+ *
+ * Returns the attributes required for the specified element.
+ */
+#define htmlRequiredAttrs(elt) (elt)->attrs_req
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_HTML_ENABLED */
+#endif /* __HTML_PARSER_H__ */
diff -Naur orig.ns-2.33/libxml/HTMLtree.h ns-2.33/libxml/HTMLtree.h
--- orig.ns-2.33/libxml/HTMLtree.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/HTMLtree.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,147 @@
+/*
+ * Summary: specific APIs to process HTML tree, especially serialization
+ * Description: this module implements a few function needed to process
+ *              tree in an HTML specific way.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __HTML_TREE_H__
+#define __HTML_TREE_H__
+
+#include <stdio.h>
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+#include <libxml/HTMLparser.h>
+
+#ifdef LIBXML_HTML_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * HTML_TEXT_NODE:
+ *
+ * Macro. A text node in a HTML document is really implemented
+ * the same way as a text node in an XML document.
+ */
+#define HTML_TEXT_NODE		XML_TEXT_NODE
+/**
+ * HTML_ENTITY_REF_NODE:
+ *
+ * Macro. An entity reference in a HTML document is really implemented
+ * the same way as an entity reference in an XML document.
+ */
+#define HTML_ENTITY_REF_NODE	XML_ENTITY_REF_NODE
+/**
+ * HTML_COMMENT_NODE:
+ *
+ * Macro. A comment in a HTML document is really implemented
+ * the same way as a comment in an XML document.
+ */
+#define HTML_COMMENT_NODE	XML_COMMENT_NODE
+/**
+ * HTML_PRESERVE_NODE:
+ *
+ * Macro. A preserved node in a HTML document is really implemented
+ * the same way as a CDATA section in an XML document.
+ */
+#define HTML_PRESERVE_NODE	XML_CDATA_SECTION_NODE
+/**
+ * HTML_PI_NODE:
+ *
+ * Macro. A processing instruction in a HTML document is really implemented
+ * the same way as a processing instruction in an XML document.
+ */
+#define HTML_PI_NODE		XML_PI_NODE
+
+XMLPUBFUN htmlDocPtr XMLCALL
+		htmlNewDoc		(const xmlChar *URI,
+					 const xmlChar *ExternalID);
+XMLPUBFUN htmlDocPtr XMLCALL	
+		htmlNewDocNoDtD		(const xmlChar *URI,
+					 const xmlChar *ExternalID);
+XMLPUBFUN const xmlChar * XMLCALL	
+		htmlGetMetaEncoding	(htmlDocPtr doc);
+XMLPUBFUN int XMLCALL		
+		htmlSetMetaEncoding	(htmlDocPtr doc,
+					 const xmlChar *encoding);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL	    
+		htmlDocDumpMemory	(xmlDocPtr cur,
+					 xmlChar **mem,
+					 int *size);
+XMLPUBFUN void XMLCALL	    
+		htmlDocDumpMemoryFormat	(xmlDocPtr cur,
+					 xmlChar **mem,
+					 int *size,
+					 int format);
+XMLPUBFUN int XMLCALL		
+		htmlDocDump		(FILE *f,
+					 xmlDocPtr cur);
+XMLPUBFUN int XMLCALL		
+		htmlSaveFile		(const char *filename,
+					 xmlDocPtr cur);
+XMLPUBFUN int XMLCALL		
+		htmlNodeDump		(xmlBufferPtr buf,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur);
+XMLPUBFUN void XMLCALL		
+		htmlNodeDumpFile	(FILE *out,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur);
+XMLPUBFUN int XMLCALL		
+		htmlNodeDumpFileFormat	(FILE *out,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur,
+					 const char *encoding,
+					 int format);
+XMLPUBFUN int XMLCALL		
+		htmlSaveFileEnc		(const char *filename,
+					 xmlDocPtr cur,
+					 const char *encoding);
+XMLPUBFUN int XMLCALL		
+		htmlSaveFileFormat	(const char *filename,
+					 xmlDocPtr cur,
+					 const char *encoding,
+					 int format);
+
+XMLPUBFUN void XMLCALL		
+		htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur,
+					 const char *encoding,
+					 int format);
+XMLPUBFUN void XMLCALL		
+		htmlDocContentDumpOutput(xmlOutputBufferPtr buf,
+					 xmlDocPtr cur,
+					 const char *encoding);
+XMLPUBFUN void XMLCALL		
+		htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,
+					 xmlDocPtr cur,
+					 const char *encoding,
+					 int format);
+XMLPUBFUN void XMLCALL 
+		htmlNodeDumpOutput	(xmlOutputBufferPtr buf, 
+					 xmlDocPtr doc,
+					 xmlNodePtr cur, 
+					 const char *encoding);
+
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+XMLPUBFUN int XMLCALL		
+		htmlIsBooleanAttr	(const xmlChar *name);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_HTML_ENABLED */
+
+#endif /* __HTML_TREE_H__ */
+
diff -Naur orig.ns-2.33/libxml/Makefile.am ns-2.33/libxml/Makefile.am
--- orig.ns-2.33/libxml/Makefile.am	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/Makefile.am	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,57 @@
+## Process this file with automake to produce Makefile.in
+
+xmlincdir = $(includedir)/libxml2/libxml
+
+xmlinc_HEADERS = \
+		SAX.h \
+		entities.h \
+		encoding.h \
+		parser.h \
+		parserInternals.h \
+		xmlerror.h \
+		HTMLparser.h \
+		HTMLtree.h \
+		debugXML.h \
+		tree.h \
+		list.h \
+		hash.h \
+		xpath.h \
+		xpathInternals.h \
+		xpointer.h \
+		xinclude.h \
+		xmlIO.h \
+		xmlmemory.h \
+		nanohttp.h \
+		nanoftp.h \
+		uri.h \
+		valid.h \
+		xlink.h \
+		xmlversion.h \
+		DOCBparser.h \
+		catalog.h \
+		threads.h \
+		globals.h \
+		c14n.h \
+		xmlautomata.h \
+		xmlregexp.h \
+		xmlmodule.h \
+		xmlschemas.h \
+		schemasInternals.h \
+		xmlschemastypes.h \
+		xmlstring.h \
+		xmlunicode.h \
+		xmlreader.h \
+		relaxng.h \
+		dict.h \
+		SAX2.h \
+		xmlexports.h \
+		xmlwriter.h \
+		chvalid.h \
+		pattern.h \
+		xmlsave.h \
+		schematron.h
+
+install-exec-hook:
+	$(mkinstalldirs) $(DESTDIR)$(xmlincdir)
+
+EXTRA_DIST = xmlversion.h.in
diff -Naur orig.ns-2.33/libxml/Makefile.in ns-2.33/libxml/Makefile.in
--- orig.ns-2.33/libxml/Makefile.in	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/Makefile.in	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,562 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/libxml
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in \
+	$(srcdir)/xmlversion.h.in $(xmlinc_HEADERS)
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES = xmlversion.h
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(xmlincdir)"
+xmlincHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(xmlinc_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BASE_THREAD_LIBS = @BASE_THREAD_LIBS@
+C14N_OBJ = @C14N_OBJ@
+CATALOG_OBJ = @CATALOG_OBJ@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+CYGWIN_EXTRA_LDFLAGS = @CYGWIN_EXTRA_LDFLAGS@
+CYGWIN_EXTRA_PYTHON_LIBADD = @CYGWIN_EXTRA_PYTHON_LIBADD@
+DEBUG_OBJ = @DEBUG_OBJ@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOCB_OBJ = @DOCB_OBJ@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+FTP_OBJ = @FTP_OBJ@
+HAVE_ISINF = @HAVE_ISINF@
+HAVE_ISNAN = @HAVE_ISNAN@
+HTML_DIR = @HTML_DIR@
+HTML_OBJ = @HTML_OBJ@
+HTTP_OBJ = @HTTP_OBJ@
+ICONV_LIBS = @ICONV_LIBS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIBXML_MAJOR_VERSION = @LIBXML_MAJOR_VERSION@
+LIBXML_MICRO_VERSION = @LIBXML_MICRO_VERSION@
+LIBXML_MINOR_VERSION = @LIBXML_MINOR_VERSION@
+LIBXML_VERSION = @LIBXML_VERSION@
+LIBXML_VERSION_EXTRA = @LIBXML_VERSION_EXTRA@
+LIBXML_VERSION_INFO = @LIBXML_VERSION_INFO@
+LIBXML_VERSION_NUMBER = @LIBXML_VERSION_NUMBER@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MODULE_EXTENSION = @MODULE_EXTENSION@
+MODULE_PLATFORM_LIBS = @MODULE_PLATFORM_LIBS@
+MV = @MV@
+M_LIBS = @M_LIBS@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+PYTHON = @PYTHON@
+PYTHON_INCLUDES = @PYTHON_INCLUDES@
+PYTHON_SITE_PACKAGES = @PYTHON_SITE_PACKAGES@
+PYTHON_SUBDIR = @PYTHON_SUBDIR@
+PYTHON_TESTS = @PYTHON_TESTS@
+PYTHON_VERSION = @PYTHON_VERSION@
+RANLIB = @RANLIB@
+RDL_LIBS = @RDL_LIBS@
+READER_TEST = @READER_TEST@
+RELDATE = @RELDATE@
+RM = @RM@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STATIC_BINARIES = @STATIC_BINARIES@
+STRIP = @STRIP@
+TAR = @TAR@
+TEST_C14N = @TEST_C14N@
+TEST_CATALOG = @TEST_CATALOG@
+TEST_DEBUG = @TEST_DEBUG@
+TEST_HTML = @TEST_HTML@
+TEST_MODULES = @TEST_MODULES@
+TEST_PATTERN = @TEST_PATTERN@
+TEST_PHTML = @TEST_PHTML@
+TEST_PUSH = @TEST_PUSH@
+TEST_REGEXPS = @TEST_REGEXPS@
+TEST_SAX = @TEST_SAX@
+TEST_SCHEMAS = @TEST_SCHEMAS@
+TEST_SCHEMATRON = @TEST_SCHEMATRON@
+TEST_THREADS = @TEST_THREADS@
+TEST_VALID = @TEST_VALID@
+TEST_VTIME = @TEST_VTIME@
+TEST_XINCLUDE = @TEST_XINCLUDE@
+TEST_XPATH = @TEST_XPATH@
+TEST_XPTR = @TEST_XPTR@
+THREADS_W32 = @THREADS_W32@
+THREAD_CFLAGS = @THREAD_CFLAGS@
+THREAD_LIBS = @THREAD_LIBS@
+U = @U@
+VERSION = @VERSION@
+WGET = @WGET@
+WIN32_EXTRA_LDFLAGS = @WIN32_EXTRA_LDFLAGS@
+WIN32_EXTRA_LIBADD = @WIN32_EXTRA_LIBADD@
+WITH_C14N = @WITH_C14N@
+WITH_CATALOG = @WITH_CATALOG@
+WITH_DEBUG = @WITH_DEBUG@
+WITH_DOCB = @WITH_DOCB@
+WITH_FTP = @WITH_FTP@
+WITH_HTML = @WITH_HTML@
+WITH_HTTP = @WITH_HTTP@
+WITH_ICONV = @WITH_ICONV@
+WITH_ISO8859X = @WITH_ISO8859X@
+WITH_LEGACY = @WITH_LEGACY@
+WITH_MEM_DEBUG = @WITH_MEM_DEBUG@
+WITH_MODULES = @WITH_MODULES@
+WITH_OUTPUT = @WITH_OUTPUT@
+WITH_PATTERN = @WITH_PATTERN@
+WITH_PUSH = @WITH_PUSH@
+WITH_PYTHON_FALSE = @WITH_PYTHON_FALSE@
+WITH_PYTHON_TRUE = @WITH_PYTHON_TRUE@
+WITH_READER = @WITH_READER@
+WITH_REGEXPS = @WITH_REGEXPS@
+WITH_RUN_DEBUG = @WITH_RUN_DEBUG@
+WITH_SAX1 = @WITH_SAX1@
+WITH_SCHEMAS = @WITH_SCHEMAS@
+WITH_SCHEMATRON = @WITH_SCHEMATRON@
+WITH_THREADS = @WITH_THREADS@
+WITH_TREE = @WITH_TREE@
+WITH_TRIO = @WITH_TRIO@
+WITH_TRIO_SOURCES_FALSE = @WITH_TRIO_SOURCES_FALSE@
+WITH_TRIO_SOURCES_TRUE = @WITH_TRIO_SOURCES_TRUE@
+WITH_VALID = @WITH_VALID@
+WITH_WRITER = @WITH_WRITER@
+WITH_XINCLUDE = @WITH_XINCLUDE@
+WITH_XPATH = @WITH_XPATH@
+WITH_XPTR = @WITH_XPTR@
+WITH_ZLIB = @WITH_ZLIB@
+XINCLUDE_OBJ = @XINCLUDE_OBJ@
+XMLLINT = @XMLLINT@
+XML_CFLAGS = @XML_CFLAGS@
+XML_INCLUDEDIR = @XML_INCLUDEDIR@
+XML_LIBDIR = @XML_LIBDIR@
+XML_LIBS = @XML_LIBS@
+XML_LIBTOOLLIBS = @XML_LIBTOOLLIBS@
+XPATH_OBJ = @XPATH_OBJ@
+XPTR_OBJ = @XPTR_OBJ@
+XSLTPROC = @XSLTPROC@
+Z_CFLAGS = @Z_CFLAGS@
+Z_LIBS = @Z_LIBS@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_AS = @ac_ct_AS@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DLLTOOL = @ac_ct_DLLTOOL@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_OBJDUMP = @ac_ct_OBJDUMP@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+pythondir = @pythondir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+xmlincdir = $(includedir)/libxml2/libxml
+xmlinc_HEADERS = \
+		SAX.h \
+		entities.h \
+		encoding.h \
+		parser.h \
+		parserInternals.h \
+		xmlerror.h \
+		HTMLparser.h \
+		HTMLtree.h \
+		debugXML.h \
+		tree.h \
+		list.h \
+		hash.h \
+		xpath.h \
+		xpathInternals.h \
+		xpointer.h \
+		xinclude.h \
+		xmlIO.h \
+		xmlmemory.h \
+		nanohttp.h \
+		nanoftp.h \
+		uri.h \
+		valid.h \
+		xlink.h \
+		xmlversion.h \
+		DOCBparser.h \
+		catalog.h \
+		threads.h \
+		globals.h \
+		c14n.h \
+		xmlautomata.h \
+		xmlregexp.h \
+		xmlmodule.h \
+		xmlschemas.h \
+		schemasInternals.h \
+		xmlschemastypes.h \
+		xmlstring.h \
+		xmlunicode.h \
+		xmlreader.h \
+		relaxng.h \
+		dict.h \
+		SAX2.h \
+		xmlexports.h \
+		xmlwriter.h \
+		chvalid.h \
+		pattern.h \
+		xmlsave.h \
+		schematron.h
+
+EXTRA_DIST = xmlversion.h.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/libxml/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/libxml/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+xmlversion.h: $(top_builddir)/config.status $(srcdir)/xmlversion.h.in
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+install-xmlincHEADERS: $(xmlinc_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(xmlincdir)" || $(mkdir_p) "$(DESTDIR)$(xmlincdir)"
+	@list='$(xmlinc_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(xmlincHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(xmlincdir)/$$f'"; \
+	  $(xmlincHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(xmlincdir)/$$f"; \
+	done
+
+uninstall-xmlincHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(xmlinc_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(xmlincdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(xmlincdir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(xmlincdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-xmlincHEADERS
+
+install-exec-am:
+	@$(NORMAL_INSTALL)
+	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-xmlincHEADERS
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-exec-hook \
+	install-info install-info-am install-man install-strip \
+	install-xmlincHEADERS installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-xmlincHEADERS
+
+
+install-exec-hook:
+	$(mkinstalldirs) $(DESTDIR)$(xmlincdir)
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Naur orig.ns-2.33/libxml/SAX.h ns-2.33/libxml/SAX.h
--- orig.ns-2.33/libxml/SAX.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/SAX.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,173 @@
+/*
+ * Summary: Old SAX version 1 handler, deprecated
+ * Description: DEPRECATED set of SAX version 1 interfaces used to
+ *              build the DOM tree.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_SAX_H__
+#define __XML_SAX_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+#include <libxml/xlink.h>
+
+#ifdef LIBXML_LEGACY_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+XMLPUBFUN const xmlChar * XMLCALL
+		getPublicId			(void *ctx);
+XMLPUBFUN const xmlChar * XMLCALL	
+		getSystemId			(void *ctx);
+XMLPUBFUN void XMLCALL		
+		setDocumentLocator		(void *ctx,
+						 xmlSAXLocatorPtr loc);
+    
+XMLPUBFUN int XMLCALL		
+		getLineNumber			(void *ctx);
+XMLPUBFUN int XMLCALL		
+		getColumnNumber			(void *ctx);
+
+XMLPUBFUN int XMLCALL		
+		isStandalone			(void *ctx);
+XMLPUBFUN int XMLCALL		
+		hasInternalSubset		(void *ctx);
+XMLPUBFUN int XMLCALL		
+		hasExternalSubset		(void *ctx);
+
+XMLPUBFUN void XMLCALL		
+		internalSubset			(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID);
+XMLPUBFUN void XMLCALL		
+		externalSubset			(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID);
+XMLPUBFUN xmlEntityPtr XMLCALL	
+		getEntity			(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN xmlEntityPtr XMLCALL	
+		getParameterEntity		(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN xmlParserInputPtr XMLCALL 
+		resolveEntity			(void *ctx,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId);
+
+XMLPUBFUN void XMLCALL		
+		entityDecl			(void *ctx,
+						 const xmlChar *name,
+						 int type,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId,
+						 xmlChar *content);
+XMLPUBFUN void XMLCALL		
+		attributeDecl			(void *ctx,
+						 const xmlChar *elem,
+						 const xmlChar *fullname,
+						 int type,
+						 int def,
+						 const xmlChar *defaultValue,
+						 xmlEnumerationPtr tree);
+XMLPUBFUN void XMLCALL		
+		elementDecl			(void *ctx,
+						 const xmlChar *name,
+						 int type,
+						 xmlElementContentPtr content);
+XMLPUBFUN void XMLCALL		
+		notationDecl			(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId);
+XMLPUBFUN void XMLCALL		
+		unparsedEntityDecl		(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId,
+						 const xmlChar *notationName);
+
+XMLPUBFUN void XMLCALL		
+		startDocument			(void *ctx);
+XMLPUBFUN void XMLCALL		
+		endDocument			(void *ctx);
+XMLPUBFUN void XMLCALL		
+		attribute			(void *ctx,
+						 const xmlChar *fullname,
+						 const xmlChar *value);
+XMLPUBFUN void XMLCALL		
+		startElement			(void *ctx,
+						 const xmlChar *fullname,
+						 const xmlChar **atts);
+XMLPUBFUN void XMLCALL		
+		endElement			(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN void XMLCALL		
+		reference			(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN void XMLCALL		
+		characters			(void *ctx,
+						 const xmlChar *ch,
+						 int len);
+XMLPUBFUN void XMLCALL		
+		ignorableWhitespace		(void *ctx,
+						 const xmlChar *ch,
+						 int len);
+XMLPUBFUN void XMLCALL		
+		processingInstruction		(void *ctx,
+						 const xmlChar *target,
+						 const xmlChar *data);
+XMLPUBFUN void XMLCALL		
+		globalNamespace			(void *ctx,
+						 const xmlChar *href,
+						 const xmlChar *prefix);
+XMLPUBFUN void XMLCALL		
+		setNamespace			(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN xmlNsPtr XMLCALL	
+		getNamespace			(void *ctx);
+XMLPUBFUN int XMLCALL		
+		checkNamespace			(void *ctx,
+						 xmlChar *nameSpace);
+XMLPUBFUN void XMLCALL		
+		namespaceDecl			(void *ctx,
+						 const xmlChar *href,
+						 const xmlChar *prefix);
+XMLPUBFUN void XMLCALL		
+		comment				(void *ctx,
+						 const xmlChar *value);
+XMLPUBFUN void XMLCALL		
+		cdataBlock			(void *ctx,
+						 const xmlChar *value,
+						 int len);
+
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN void XMLCALL		
+		initxmlDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr,
+						 int warning);
+#ifdef LIBXML_HTML_ENABLED
+XMLPUBFUN void XMLCALL		
+		inithtmlDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr);
+#endif
+#ifdef LIBXML_DOCB_ENABLED
+XMLPUBFUN void XMLCALL		
+		initdocbDefaultSAXHandler	(xmlSAXHandlerV1 *hdlr);
+#endif
+#endif /* LIBXML_SAX1_ENABLED */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_LEGACY_ENABLED */
+
+#endif /* __XML_SAX_H__ */
diff -Naur orig.ns-2.33/libxml/SAX2.h ns-2.33/libxml/SAX2.h
--- orig.ns-2.33/libxml/SAX2.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/SAX2.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,176 @@
+/*
+ * Summary: SAX2 parser interface used to build the DOM tree
+ * Description: those are the default SAX2 interfaces used by
+ *              the library when building DOM tree.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_SAX2_H__
+#define __XML_SAX2_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+#include <libxml/xlink.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+XMLPUBFUN const xmlChar * XMLCALL
+		xmlSAX2GetPublicId		(void *ctx);
+XMLPUBFUN const xmlChar * XMLCALL	
+		xmlSAX2GetSystemId		(void *ctx);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2SetDocumentLocator	(void *ctx,
+						 xmlSAXLocatorPtr loc);
+    
+XMLPUBFUN int XMLCALL		
+		xmlSAX2GetLineNumber		(void *ctx);
+XMLPUBFUN int XMLCALL		
+		xmlSAX2GetColumnNumber		(void *ctx);
+
+XMLPUBFUN int XMLCALL		
+		xmlSAX2IsStandalone		(void *ctx);
+XMLPUBFUN int XMLCALL		
+		xmlSAX2HasInternalSubset	(void *ctx);
+XMLPUBFUN int XMLCALL		
+		xmlSAX2HasExternalSubset	(void *ctx);
+
+XMLPUBFUN void XMLCALL		
+		xmlSAX2InternalSubset		(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2ExternalSubset		(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID);
+XMLPUBFUN xmlEntityPtr XMLCALL	
+		xmlSAX2GetEntity		(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN xmlEntityPtr XMLCALL	
+		xmlSAX2GetParameterEntity	(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN xmlParserInputPtr XMLCALL 
+		xmlSAX2ResolveEntity		(void *ctx,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId);
+
+XMLPUBFUN void XMLCALL		
+		xmlSAX2EntityDecl		(void *ctx,
+						 const xmlChar *name,
+						 int type,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId,
+						 xmlChar *content);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2AttributeDecl		(void *ctx,
+						 const xmlChar *elem,
+						 const xmlChar *fullname,
+						 int type,
+						 int def,
+						 const xmlChar *defaultValue,
+						 xmlEnumerationPtr tree);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2ElementDecl		(void *ctx,
+						 const xmlChar *name,
+						 int type,
+						 xmlElementContentPtr content);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2NotationDecl		(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2UnparsedEntityDecl	(void *ctx,
+						 const xmlChar *name,
+						 const xmlChar *publicId,
+						 const xmlChar *systemId,
+						 const xmlChar *notationName);
+
+XMLPUBFUN void XMLCALL		
+		xmlSAX2StartDocument		(void *ctx);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2EndDocument		(void *ctx);
+#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED)
+XMLPUBFUN void XMLCALL		
+		xmlSAX2StartElement		(void *ctx,
+						 const xmlChar *fullname,
+						 const xmlChar **atts);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2EndElement		(void *ctx,
+						 const xmlChar *name);
+#endif /* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED */
+XMLPUBFUN void XMLCALL
+		xmlSAX2StartElementNs		(void *ctx,
+						 const xmlChar *localname,
+						 const xmlChar *prefix,
+						 const xmlChar *URI,
+						 int nb_namespaces,
+						 const xmlChar **namespaces,
+						 int nb_attributes,
+						 int nb_defaulted,
+						 const xmlChar **attributes);
+XMLPUBFUN void XMLCALL
+		xmlSAX2EndElementNs		(void *ctx,
+						 const xmlChar *localname,
+						 const xmlChar *prefix,
+						 const xmlChar *URI);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2Reference		(void *ctx,
+						 const xmlChar *name);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2Characters		(void *ctx,
+						 const xmlChar *ch,
+						 int len);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2IgnorableWhitespace	(void *ctx,
+						 const xmlChar *ch,
+						 int len);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2ProcessingInstruction	(void *ctx,
+						 const xmlChar *target,
+						 const xmlChar *data);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2Comment			(void *ctx,
+						 const xmlChar *value);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2CDataBlock		(void *ctx,
+						 const xmlChar *value,
+						 int len);
+
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN int XMLCALL
+		xmlSAXDefaultVersion		(int version);
+#endif /* LIBXML_SAX1_ENABLED */
+
+XMLPUBFUN int XMLCALL
+		xmlSAXVersion			(xmlSAXHandler *hdlr,
+						 int version);
+XMLPUBFUN void XMLCALL		
+		xmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,
+						 int warning);
+#ifdef LIBXML_HTML_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);
+XMLPUBFUN void XMLCALL		
+		htmlDefaultSAXHandlerInit	(void);
+#endif
+#ifdef LIBXML_DOCB_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr);
+XMLPUBFUN void XMLCALL		
+		docbDefaultSAXHandlerInit	(void);
+#endif
+XMLPUBFUN void XMLCALL		
+		xmlDefaultSAXHandlerInit	(void);
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_SAX2_H__ */
diff -Naur orig.ns-2.33/libxml/c14n.h ns-2.33/libxml/c14n.h
--- orig.ns-2.33/libxml/c14n.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/c14n.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,105 @@
+/*
+ * Summary: Provide Canonical XML and Exclusive XML Canonicalization
+ * Description: the c14n modules provides a
+ *
+ * "Canonical XML" implementation 
+ * http://www.w3.org/TR/xml-c14n
+ * 
+ * and an
+ *
+ * "Exclusive XML Canonicalization" implementation
+ * http://www.w3.org/TR/xml-exc-c14n
+ 
+ * Copy: See Copyright for the status of this software.
+ * 
+ * Author: Aleksey Sanin <aleksey@aleksey.com>
+ */
+#ifndef __XML_C14N_H__
+#define __XML_C14N_H__    
+#ifdef LIBXML_C14N_ENABLED
+#ifdef LIBXML_OUTPUT_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */ 
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+#include <libxml/xpath.h> 
+
+/*
+ * XML Canonicazation
+ * http://www.w3.org/TR/xml-c14n
+ *
+ * Exclusive XML Canonicazation
+ * http://www.w3.org/TR/xml-exc-c14n
+ *
+ * Canonical form of an XML document could be created if and only if
+ *  a) default attributes (if any) are added to all nodes
+ *  b) all character and parsed entity references are resolved
+ * In order to achive this in libxml2 the document MUST be loaded with 
+ * following global setings:
+ *    
+ *    xmlLoadExtDtdDefaultValue = XML_DETECT_IDS | XML_COMPLETE_ATTRS;
+ *    xmlSubstituteEntitiesDefault(1);
+ *
+ * or corresponding parser context setting:
+ *    xmlParserCtxtPtr ctxt;
+ *    
+ *    ... 
+ *    ctxt->loadsubset = XML_DETECT_IDS | XML_COMPLETE_ATTRS;
+ *    ctxt->replaceEntities = 1;
+ *    ...
+ */
+
+
+XMLPUBFUN int XMLCALL 		
+		xmlC14NDocSaveTo	(xmlDocPtr doc,
+					 xmlNodeSetPtr nodes,
+					 int exclusive,
+					 xmlChar **inclusive_ns_prefixes,
+					 int with_comments, 
+					 xmlOutputBufferPtr buf);
+
+XMLPUBFUN int XMLCALL
+		xmlC14NDocDumpMemory	(xmlDocPtr doc,
+					 xmlNodeSetPtr nodes,
+					 int exclusive,
+					 xmlChar **inclusive_ns_prefixes,
+					 int with_comments, 
+					 xmlChar **doc_txt_ptr);
+
+XMLPUBFUN int XMLCALL
+		xmlC14NDocSave		(xmlDocPtr doc,
+					 xmlNodeSetPtr nodes,
+					 int exclusive,
+					 xmlChar **inclusive_ns_prefixes,
+					 int with_comments, 
+					 const char* filename,
+					 int compression);
+
+
+/**
+ * This is the core C14N function
+ */
+typedef int (*xmlC14NIsVisibleCallback)	(void* user_data, 
+					 xmlNodePtr node,
+					 xmlNodePtr parent);
+
+XMLPUBFUN int XMLCALL
+		xmlC14NExecute		(xmlDocPtr doc,
+					 xmlC14NIsVisibleCallback is_visible_callback,
+					 void* user_data,				 
+					 int exclusive,
+					 xmlChar **inclusive_ns_prefixes,
+					 int with_comments, 
+					 xmlOutputBufferPtr buf);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* LIBXML_OUTPUT_ENABLED */
+#endif /* LIBXML_C14N_ENABLED */
+#endif /* __XML_C14N_H__ */
+
diff -Naur orig.ns-2.33/libxml/catalog.h ns-2.33/libxml/catalog.h
--- orig.ns-2.33/libxml/catalog.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/catalog.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,182 @@
+/**
+ * Summary: interfaces to the Catalog handling system
+ * Description: the catalog module implements the support for
+ * XML Catalogs and SGML catalogs
+ *
+ * SGML Open Technical Resolution TR9401:1997.
+ * http://www.jclark.com/sp/catalog.htm
+ *
+ * XML Catalogs Working Draft 06 August 2001
+ * http://www.oasis-open.org/committees/entity/spec-2001-08-06.html
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_CATALOG_H__
+#define __XML_CATALOG_H__
+
+#include <stdio.h>
+
+#include <libxml/xmlversion.h>
+#include <libxml/xmlstring.h>
+#include <libxml/tree.h>
+
+#ifdef LIBXML_CATALOG_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * XML_CATALOGS_NAMESPACE:
+ *
+ * The namespace for the XML Catalogs elements.
+ */
+#define XML_CATALOGS_NAMESPACE					\
+    (const xmlChar *) "urn:oasis:names:tc:entity:xmlns:xml:catalog"
+/**
+ * XML_CATALOG_PI:
+ *
+ * The specific XML Catalog Processing Instuction name.
+ */
+#define XML_CATALOG_PI						\
+    (const xmlChar *) "oasis-xml-catalog"
+
+/*
+ * The API is voluntarily limited to general cataloging.
+ */
+typedef enum {
+    XML_CATA_PREFER_NONE = 0,
+    XML_CATA_PREFER_PUBLIC = 1,
+    XML_CATA_PREFER_SYSTEM
+} xmlCatalogPrefer;
+
+typedef enum {
+    XML_CATA_ALLOW_NONE = 0,
+    XML_CATA_ALLOW_GLOBAL = 1,
+    XML_CATA_ALLOW_DOCUMENT = 2,
+    XML_CATA_ALLOW_ALL = 3
+} xmlCatalogAllow;
+
+typedef struct _xmlCatalog xmlCatalog;
+typedef xmlCatalog *xmlCatalogPtr;
+
+/*
+ * Operations on a given catalog.
+ */
+XMLPUBFUN xmlCatalogPtr XMLCALL
+		xmlNewCatalog		(int sgml);
+XMLPUBFUN xmlCatalogPtr XMLCALL	
+		xmlLoadACatalog		(const char *filename);
+XMLPUBFUN xmlCatalogPtr XMLCALL	
+		xmlLoadSGMLSuperCatalog	(const char *filename);
+XMLPUBFUN int XMLCALL		
+		xmlConvertSGMLCatalog	(xmlCatalogPtr catal);
+XMLPUBFUN int XMLCALL		
+		xmlACatalogAdd		(xmlCatalogPtr catal,
+					 const xmlChar *type,
+					 const xmlChar *orig,
+					 const xmlChar *replace);
+XMLPUBFUN int XMLCALL		
+		xmlACatalogRemove	(xmlCatalogPtr catal,
+					 const xmlChar *value);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlACatalogResolve	(xmlCatalogPtr catal,
+					 const xmlChar *pubID,
+	                                 const xmlChar *sysID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlACatalogResolveSystem(xmlCatalogPtr catal,
+					 const xmlChar *sysID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlACatalogResolvePublic(xmlCatalogPtr catal,
+					 const xmlChar *pubID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlACatalogResolveURI	(xmlCatalogPtr catal,
+					 const xmlChar *URI);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlACatalogDump		(xmlCatalogPtr catal,
+					 FILE *out);
+#endif /* LIBXML_OUTPUT_ENABLED */
+XMLPUBFUN void XMLCALL		
+		xmlFreeCatalog		(xmlCatalogPtr catal);
+XMLPUBFUN int XMLCALL		
+		xmlCatalogIsEmpty	(xmlCatalogPtr catal);
+
+/*
+ * Global operations.
+ */
+XMLPUBFUN void XMLCALL		
+		xmlInitializeCatalog	(void);
+XMLPUBFUN int XMLCALL		
+		xmlLoadCatalog		(const char *filename);
+XMLPUBFUN void XMLCALL		
+		xmlLoadCatalogs		(const char *paths);
+XMLPUBFUN void XMLCALL		
+		xmlCatalogCleanup	(void);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlCatalogDump		(FILE *out);
+#endif /* LIBXML_OUTPUT_ENABLED */
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlCatalogResolve	(const xmlChar *pubID,
+	                                 const xmlChar *sysID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlCatalogResolveSystem	(const xmlChar *sysID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlCatalogResolvePublic	(const xmlChar *pubID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlCatalogResolveURI	(const xmlChar *URI);
+XMLPUBFUN int XMLCALL		
+		xmlCatalogAdd		(const xmlChar *type,
+					 const xmlChar *orig,
+					 const xmlChar *replace);
+XMLPUBFUN int XMLCALL		
+		xmlCatalogRemove	(const xmlChar *value);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlParseCatalogFile	(const char *filename);
+XMLPUBFUN int XMLCALL		
+		xmlCatalogConvert	(void);
+
+/*
+ * Strictly minimal interfaces for per-document catalogs used
+ * by the parser.
+ */
+XMLPUBFUN void XMLCALL		
+		xmlCatalogFreeLocal	(void *catalogs);
+XMLPUBFUN void * XMLCALL		
+		xmlCatalogAddLocal	(void *catalogs,
+					 const xmlChar *URL);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlCatalogLocalResolve	(void *catalogs,
+					 const xmlChar *pubID,
+	                                 const xmlChar *sysID);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlCatalogLocalResolveURI(void *catalogs,
+					 const xmlChar *URI);
+/*
+ * Preference settings.
+ */
+XMLPUBFUN int XMLCALL		
+		xmlCatalogSetDebug	(int level);
+XMLPUBFUN xmlCatalogPrefer XMLCALL 
+		xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);
+XMLPUBFUN void XMLCALL		
+		xmlCatalogSetDefaults	(xmlCatalogAllow allow);
+XMLPUBFUN xmlCatalogAllow XMLCALL	
+		xmlCatalogGetDefaults	(void);
+
+
+/* DEPRECATED interfaces */
+XMLPUBFUN const xmlChar * XMLCALL	
+		xmlCatalogGetSystem	(const xmlChar *sysID);
+XMLPUBFUN const xmlChar * XMLCALL	
+		xmlCatalogGetPublic	(const xmlChar *pubID);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* LIBXML_CATALOG_ENABLED */
+#endif /* __XML_CATALOG_H__ */
diff -Naur orig.ns-2.33/libxml/chvalid.h ns-2.33/libxml/chvalid.h
--- orig.ns-2.33/libxml/chvalid.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/chvalid.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,230 @@
+/*
+ * Summary: Unicode character range checking
+ * Description: this module exports interfaces for the character
+ *               range validation APIs
+ *
+ * This file is automatically generated from the cvs source
+ * definition files using the genChRanges.py Python script
+ *
+ * Generation date: Mon Mar 27 11:09:48 2006
+ * Sources: chvalid.def
+ * Author: William Brack <wbrack@mmm.com.hk>
+ */
+
+#ifndef __XML_CHVALID_H__
+#define __XML_CHVALID_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/xmlstring.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Define our typedefs and structures
+ *
+ */
+typedef struct _xmlChSRange xmlChSRange;
+typedef xmlChSRange *xmlChSRangePtr;
+struct _xmlChSRange {
+    unsigned short	low;
+    unsigned short	high;
+};
+
+typedef struct _xmlChLRange xmlChLRange;
+typedef xmlChLRange *xmlChLRangePtr;
+struct _xmlChLRange {
+    unsigned int	low;
+    unsigned int	high;
+};
+
+typedef struct _xmlChRangeGroup xmlChRangeGroup;
+typedef xmlChRangeGroup *xmlChRangeGroupPtr;
+struct _xmlChRangeGroup {
+    int			nbShortRange;
+    int			nbLongRange;
+    const xmlChSRange	*shortRange;	/* points to an array of ranges */
+    const xmlChLRange	*longRange;
+};
+
+/**
+ * Range checking routine
+ */
+XMLPUBFUN int XMLCALL
+		xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);
+
+
+/**
+ * xmlIsBaseChar_ch:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsBaseChar_ch(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
+				 ((0x61 <= (c)) && ((c) <= 0x7a)) || \
+				 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \
+				 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \
+				  (0xf8 <= (c)))
+
+/**
+ * xmlIsBaseCharQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsBaseCharQ(c)	(((c) < 0x100) ? \
+				 xmlIsBaseChar_ch((c)) : \
+				 xmlCharInRange((c), &xmlIsBaseCharGroup))
+
+XMLPUBVAR const xmlChRangeGroup xmlIsBaseCharGroup;
+
+/**
+ * xmlIsBlank_ch:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsBlank_ch(c)	(((c) == 0x20) || \
+				 ((0x9 <= (c)) && ((c) <= 0xa)) || \
+				 ((c) == 0xd))
+
+/**
+ * xmlIsBlankQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsBlankQ(c)		(((c) < 0x100) ? \
+				 xmlIsBlank_ch((c)) : 0)
+
+
+/**
+ * xmlIsChar_ch:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsChar_ch(c)		(((0x9 <= (c)) && ((c) <= 0xa)) || \
+				 ((c) == 0xd) || \
+				  (0x20 <= (c)))
+
+/**
+ * xmlIsCharQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsCharQ(c)		(((c) < 0x100) ? \
+				 xmlIsChar_ch((c)) :\
+				(((0x100 <= (c)) && ((c) <= 0xd7ff)) || \
+				 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \
+				 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))
+
+XMLPUBVAR const xmlChRangeGroup xmlIsCharGroup;
+
+/**
+ * xmlIsCombiningQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsCombiningQ(c)	(((c) < 0x100) ? \
+				 0 : \
+				 xmlCharInRange((c), &xmlIsCombiningGroup))
+
+XMLPUBVAR const xmlChRangeGroup xmlIsCombiningGroup;
+
+/**
+ * xmlIsDigit_ch:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsDigit_ch(c)	(((0x30 <= (c)) && ((c) <= 0x39)))
+
+/**
+ * xmlIsDigitQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsDigitQ(c)		(((c) < 0x100) ? \
+				 xmlIsDigit_ch((c)) : \
+				 xmlCharInRange((c), &xmlIsDigitGroup))
+
+XMLPUBVAR const xmlChRangeGroup xmlIsDigitGroup;
+
+/**
+ * xmlIsExtender_ch:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsExtender_ch(c)	(((c) == 0xb7))
+
+/**
+ * xmlIsExtenderQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsExtenderQ(c)	(((c) < 0x100) ? \
+				 xmlIsExtender_ch((c)) : \
+				 xmlCharInRange((c), &xmlIsExtenderGroup))
+
+XMLPUBVAR const xmlChRangeGroup xmlIsExtenderGroup;
+
+/**
+ * xmlIsIdeographicQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsIdeographicQ(c)	(((c) < 0x100) ? \
+				 0 :\
+				(((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \
+				 ((c) == 0x3007) || \
+				 ((0x3021 <= (c)) && ((c) <= 0x3029))))
+
+XMLPUBVAR const xmlChRangeGroup xmlIsIdeographicGroup;
+XMLPUBVAR const unsigned char xmlIsPubidChar_tab[256];
+
+/**
+ * xmlIsPubidChar_ch:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsPubidChar_ch(c)	(xmlIsPubidChar_tab[(c)])
+
+/**
+ * xmlIsPubidCharQ:
+ * @c: char to validate
+ *
+ * Automatically generated by genChRanges.py
+ */
+#define xmlIsPubidCharQ(c)	(((c) < 0x100) ? \
+				 xmlIsPubidChar_ch((c)) : 0)
+
+XMLPUBFUN int XMLCALL
+		xmlIsBaseChar(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsBlank(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsChar(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsCombining(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsDigit(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsExtender(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsIdeographic(unsigned int ch);
+XMLPUBFUN int XMLCALL
+		xmlIsPubidChar(unsigned int ch);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_CHVALID_H__ */
diff -Naur orig.ns-2.33/libxml/debugXML.h ns-2.33/libxml/debugXML.h
--- orig.ns-2.33/libxml/debugXML.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/debugXML.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,217 @@
+/*
+ * Summary: Tree debugging APIs
+ * Description: Interfaces to a set of routines used for debugging the tree
+ *              produced by the XML parser.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __DEBUG_XML__
+#define __DEBUG_XML__
+#include <stdio.h>
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef LIBXML_DEBUG_ENABLED
+
+#include <libxml/xpath.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The standard Dump routines.
+ */
+XMLPUBFUN void XMLCALL	
+	xmlDebugDumpString	(FILE *output,
+				 const xmlChar *str);
+XMLPUBFUN void XMLCALL	
+	xmlDebugDumpAttr	(FILE *output,
+				 xmlAttrPtr attr,
+				 int depth);
+XMLPUBFUN void XMLCALL	
+	xmlDebugDumpAttrList	(FILE *output,
+				 xmlAttrPtr attr,
+				 int depth);
+XMLPUBFUN void XMLCALL	
+	xmlDebugDumpOneNode	(FILE *output,
+				 xmlNodePtr node,
+				 int depth);
+XMLPUBFUN void XMLCALL
+	xmlDebugDumpNode	(FILE *output,
+				 xmlNodePtr node,
+				 int depth);
+XMLPUBFUN void XMLCALL
+	xmlDebugDumpNodeList	(FILE *output,
+				 xmlNodePtr node,
+				 int depth);
+XMLPUBFUN void XMLCALL
+	xmlDebugDumpDocumentHead(FILE *output,
+				 xmlDocPtr doc);
+XMLPUBFUN void XMLCALL
+	xmlDebugDumpDocument	(FILE *output,
+				 xmlDocPtr doc);
+XMLPUBFUN void XMLCALL	
+	xmlDebugDumpDTD		(FILE *output,
+				 xmlDtdPtr dtd);
+XMLPUBFUN void XMLCALL	
+	xmlDebugDumpEntities	(FILE *output,
+				 xmlDocPtr doc);
+
+/****************************************************************
+ *								*
+ *	 		Checking routines			*
+ *								*
+ ****************************************************************/
+
+XMLPUBFUN int XMLCALL
+	xmlDebugCheckDocument	(FILE * output,
+				 xmlDocPtr doc);
+
+/****************************************************************
+ *								*
+ *	 		XML shell helpers			*
+ *								*
+ ****************************************************************/
+
+XMLPUBFUN void XMLCALL	
+	xmlLsOneNode		(FILE *output, xmlNodePtr node);
+XMLPUBFUN int XMLCALL	
+	xmlLsCountNode		(xmlNodePtr node);
+
+XMLPUBFUN const char * XMLCALL 
+	xmlBoolToText		(int boolval);
+
+/****************************************************************
+ *								*
+ *	 The XML shell related structures and functions		*
+ *								*
+ ****************************************************************/
+
+#ifdef LIBXML_XPATH_ENABLED
+/**
+ * xmlShellReadlineFunc:
+ * @prompt:  a string prompt
+ *
+ * This is a generic signature for the XML shell input function.
+ *
+ * Returns a string which will be freed by the Shell.
+ */
+typedef char * (* xmlShellReadlineFunc)(char *prompt);
+
+/**
+ * xmlShellCtxt:
+ *
+ * A debugging shell context.
+ * TODO: add the defined function tables.
+ */
+typedef struct _xmlShellCtxt xmlShellCtxt;
+typedef xmlShellCtxt *xmlShellCtxtPtr;
+struct _xmlShellCtxt {
+    char *filename;
+    xmlDocPtr doc;
+    xmlNodePtr node;
+    xmlXPathContextPtr pctxt;
+    int loaded;
+    FILE *output;
+    xmlShellReadlineFunc input;
+};
+
+/**
+ * xmlShellCmd:
+ * @ctxt:  a shell context
+ * @arg:  a string argument
+ * @node:  a first node
+ * @node2:  a second node
+ *
+ * This is a generic signature for the XML shell functions.
+ *
+ * Returns an int, negative returns indicating errors.
+ */
+typedef int (* xmlShellCmd) (xmlShellCtxtPtr ctxt,
+                             char *arg,
+			     xmlNodePtr node,
+			     xmlNodePtr node2);
+
+XMLPUBFUN void XMLCALL	
+	xmlShellPrintXPathError	(int errorType,
+				 const char *arg);
+XMLPUBFUN void XMLCALL	
+	xmlShellPrintXPathResult(xmlXPathObjectPtr list);
+XMLPUBFUN int XMLCALL	
+	xmlShellList		(xmlShellCtxtPtr ctxt,
+				 char *arg,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+XMLPUBFUN int XMLCALL	
+	xmlShellBase		(xmlShellCtxtPtr ctxt,
+				 char *arg,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+XMLPUBFUN int XMLCALL	
+	xmlShellDir		(xmlShellCtxtPtr ctxt,
+				 char *arg,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+XMLPUBFUN int XMLCALL	
+	xmlShellLoad		(xmlShellCtxtPtr ctxt,
+				 char *filename,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL	
+	xmlShellPrintNode	(xmlNodePtr node);
+XMLPUBFUN int XMLCALL	
+	xmlShellCat		(xmlShellCtxtPtr ctxt,
+				 char *arg,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+XMLPUBFUN int XMLCALL	
+	xmlShellWrite		(xmlShellCtxtPtr ctxt,
+				 char *filename,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+XMLPUBFUN int XMLCALL	
+	xmlShellSave		(xmlShellCtxtPtr ctxt,
+				 char *filename,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+#endif /* LIBXML_OUTPUT_ENABLED */
+#ifdef LIBXML_VALID_ENABLED
+XMLPUBFUN int XMLCALL	
+	xmlShellValidate	(xmlShellCtxtPtr ctxt,
+				 char *dtd,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+#endif /* LIBXML_VALID_ENABLED */
+XMLPUBFUN int XMLCALL	
+	xmlShellDu		(xmlShellCtxtPtr ctxt,
+				 char *arg,
+				 xmlNodePtr tree,
+				 xmlNodePtr node2);
+XMLPUBFUN int XMLCALL	
+	xmlShellPwd		(xmlShellCtxtPtr ctxt,
+				 char *buffer,
+				 xmlNodePtr node,
+				 xmlNodePtr node2);
+
+/*
+ * The Shell interface.
+ */
+XMLPUBFUN void XMLCALL	
+	xmlShell		(xmlDocPtr doc,
+				 char *filename,
+				 xmlShellReadlineFunc input,
+				 FILE *output);
+			 
+#endif /* LIBXML_XPATH_ENABLED */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_DEBUG_ENABLED */
+#endif /* __DEBUG_XML__ */
diff -Naur orig.ns-2.33/libxml/dict.h ns-2.33/libxml/dict.h
--- orig.ns-2.33/libxml/dict.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/dict.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,69 @@
+/*
+ * Summary: string dictionnary
+ * Description: dictionary of reusable strings, just used to avoid allocation
+ *         and freeing operations.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_DICT_H__
+#define __XML_DICT_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The dictionnary.
+ */
+typedef struct _xmlDict xmlDict;
+typedef xmlDict *xmlDictPtr;
+
+/*
+ * Constructor and destructor.
+ */
+XMLPUBFUN xmlDictPtr XMLCALL
+			xmlDictCreate	(void);
+XMLPUBFUN xmlDictPtr XMLCALL
+			xmlDictCreateSub(xmlDictPtr sub);
+XMLPUBFUN int XMLCALL
+			xmlDictReference(xmlDictPtr dict);
+XMLPUBFUN void XMLCALL			
+			xmlDictFree	(xmlDictPtr dict);
+
+/*
+ * Lookup of entry in the dictionnary.
+ */
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlDictLookup	(xmlDictPtr dict,
+		                         const xmlChar *name,
+		                         int len);
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlDictExists	(xmlDictPtr dict,
+		                         const xmlChar *name,
+		                         int len);
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlDictQLookup	(xmlDictPtr dict,
+		                         const xmlChar *prefix,
+		                         const xmlChar *name);
+XMLPUBFUN int XMLCALL
+			xmlDictOwns	(xmlDictPtr dict,
+					 const xmlChar *str);
+XMLPUBFUN int XMLCALL			
+			xmlDictSize	(xmlDictPtr dict);
+
+/*
+ * Cleanup function
+ */
+XMLPUBFUN void XMLCALL
+                        xmlDictCleanup  (void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* ! __XML_DICT_H__ */
diff -Naur orig.ns-2.33/libxml/encoding.h ns-2.33/libxml/encoding.h
--- orig.ns-2.33/libxml/encoding.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/encoding.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,226 @@
+/*
+ * Summary: interface for the encoding conversion functions
+ * Description: interface for the encoding conversion functions needed for
+ *              XML basic encoding and iconv() support.
+ *
+ * Related specs are
+ * rfc2044        (UTF-8 and UTF-16) F. Yergeau Alis Technologies
+ * [ISO-10646]    UTF-8 and UTF-16 in Annexes
+ * [ISO-8859-1]   ISO Latin-1 characters codes.
+ * [UNICODE]      The Unicode Consortium, "The Unicode Standard --
+ *                Worldwide Character Encoding -- Version 1.0", Addison-
+ *                Wesley, Volume 1, 1991, Volume 2, 1992.  UTF-8 is
+ *                described in Unicode Technical Report #4.
+ * [US-ASCII]     Coded Character Set--7-bit American Standard Code for
+ *                Information Interchange, ANSI X3.4-1986.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_CHAR_ENCODING_H__
+#define __XML_CHAR_ENCODING_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_ICONV_ENABLED
+#include <iconv.h>
+#endif
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * xmlCharEncoding:
+ *
+ * Predefined values for some standard encodings.
+ * Libxml does not do beforehand translation on UTF8 and ISOLatinX.
+ * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.
+ *
+ * Anything else would have to be translated to UTF8 before being
+ * given to the parser itself. The BOM for UTF16 and the encoding
+ * declaration are looked at and a converter is looked for at that
+ * point. If not found the parser stops here as asked by the XML REC. A
+ * converter can be registered by the user using xmlRegisterCharEncodingHandler
+ * but the current form doesn't allow stateful transcoding (a serious
+ * problem agreed !). If iconv has been found it will be used
+ * automatically and allow stateful transcoding, the simplest is then
+ * to be sure to enable iconv and to provide iconv libs for the encoding
+ * support needed.
+ *
+ * Note that the generic "UTF-16" is not a predefined value.  Instead, only
+ * the specific UTF-16LE and UTF-16BE are present.
+ */
+typedef enum {
+    XML_CHAR_ENCODING_ERROR=   -1, /* No char encoding detected */
+    XML_CHAR_ENCODING_NONE=	0, /* No char encoding detected */
+    XML_CHAR_ENCODING_UTF8=	1, /* UTF-8 */
+    XML_CHAR_ENCODING_UTF16LE=	2, /* UTF-16 little endian */
+    XML_CHAR_ENCODING_UTF16BE=	3, /* UTF-16 big endian */
+    XML_CHAR_ENCODING_UCS4LE=	4, /* UCS-4 little endian */
+    XML_CHAR_ENCODING_UCS4BE=	5, /* UCS-4 big endian */
+    XML_CHAR_ENCODING_EBCDIC=	6, /* EBCDIC uh! */
+    XML_CHAR_ENCODING_UCS4_2143=7, /* UCS-4 unusual ordering */
+    XML_CHAR_ENCODING_UCS4_3412=8, /* UCS-4 unusual ordering */
+    XML_CHAR_ENCODING_UCS2=	9, /* UCS-2 */
+    XML_CHAR_ENCODING_8859_1=	10,/* ISO-8859-1 ISO Latin 1 */
+    XML_CHAR_ENCODING_8859_2=	11,/* ISO-8859-2 ISO Latin 2 */
+    XML_CHAR_ENCODING_8859_3=	12,/* ISO-8859-3 */
+    XML_CHAR_ENCODING_8859_4=	13,/* ISO-8859-4 */
+    XML_CHAR_ENCODING_8859_5=	14,/* ISO-8859-5 */
+    XML_CHAR_ENCODING_8859_6=	15,/* ISO-8859-6 */
+    XML_CHAR_ENCODING_8859_7=	16,/* ISO-8859-7 */
+    XML_CHAR_ENCODING_8859_8=	17,/* ISO-8859-8 */
+    XML_CHAR_ENCODING_8859_9=	18,/* ISO-8859-9 */
+    XML_CHAR_ENCODING_2022_JP=  19,/* ISO-2022-JP */
+    XML_CHAR_ENCODING_SHIFT_JIS=20,/* Shift_JIS */
+    XML_CHAR_ENCODING_EUC_JP=   21,/* EUC-JP */
+    XML_CHAR_ENCODING_ASCII=    22 /* pure ASCII */
+} xmlCharEncoding;
+
+/**
+ * xmlCharEncodingInputFunc:
+ * @out:  a pointer to an array of bytes to store the UTF-8 result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of chars in the original encoding
+ * @inlen:  the length of @in
+ *
+ * Take a block of chars in the original encoding and try to convert
+ * it to an UTF-8 block of chars out.
+ *
+ * Returns the number of bytes written, -1 if lack of space, or -2
+ *     if the transcoding failed.
+ * The value of @inlen after return is the number of octets consumed
+ *     if the return value is positive, else unpredictiable.
+ * The value of @outlen after return is the number of octets consumed.
+ */
+typedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,
+                                         const unsigned char *in, int *inlen);
+
+
+/**
+ * xmlCharEncodingOutputFunc:
+ * @out:  a pointer to an array of bytes to store the result
+ * @outlen:  the length of @out
+ * @in:  a pointer to an array of UTF-8 chars
+ * @inlen:  the length of @in
+ *
+ * Take a block of UTF-8 chars in and try to convert it to another
+ * encoding.
+ * Note: a first call designed to produce heading info is called with
+ * in = NULL. If stateful this should also initialize the encoder state.
+ *
+ * Returns the number of bytes written, -1 if lack of space, or -2
+ *     if the transcoding failed.
+ * The value of @inlen after return is the number of octets consumed
+ *     if the return value is positive, else unpredictiable.
+ * The value of @outlen after return is the number of octets produced.
+ */
+typedef int (* xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,
+                                          const unsigned char *in, int *inlen);
+
+
+/*
+ * Block defining the handlers for non UTF-8 encodings.
+ * If iconv is supported, there are two extra fields.
+ */
+
+typedef struct _xmlCharEncodingHandler xmlCharEncodingHandler;
+typedef xmlCharEncodingHandler *xmlCharEncodingHandlerPtr;
+struct _xmlCharEncodingHandler {
+    char                       *name;
+    xmlCharEncodingInputFunc   input;
+    xmlCharEncodingOutputFunc  output;
+#ifdef LIBXML_ICONV_ENABLED
+    iconv_t                    iconv_in;
+    iconv_t                    iconv_out;
+#endif /* LIBXML_ICONV_ENABLED */
+};
+
+#ifdef __cplusplus
+}
+#endif
+#include <libxml/tree.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Interfaces for encoding handlers.
+ */
+XMLPUBFUN void XMLCALL	
+	xmlInitCharEncodingHandlers	(void);
+XMLPUBFUN void XMLCALL	
+	xmlCleanupCharEncodingHandlers	(void);
+XMLPUBFUN void XMLCALL	
+	xmlRegisterCharEncodingHandler	(xmlCharEncodingHandlerPtr handler);
+XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL
+	xmlGetCharEncodingHandler	(xmlCharEncoding enc);
+XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL
+	xmlFindCharEncodingHandler	(const char *name);
+XMLPUBFUN xmlCharEncodingHandlerPtr XMLCALL
+	xmlNewCharEncodingHandler	(const char *name, 
+                          		 xmlCharEncodingInputFunc input,
+                          		 xmlCharEncodingOutputFunc output);
+
+/*
+ * Interfaces for encoding names and aliases.
+ */
+XMLPUBFUN int XMLCALL	
+	xmlAddEncodingAlias		(const char *name,
+					 const char *alias);
+XMLPUBFUN int XMLCALL	
+	xmlDelEncodingAlias		(const char *alias);
+XMLPUBFUN const char * XMLCALL
+	xmlGetEncodingAlias		(const char *alias);
+XMLPUBFUN void XMLCALL	
+	xmlCleanupEncodingAliases	(void);
+XMLPUBFUN xmlCharEncoding XMLCALL
+	xmlParseCharEncoding		(const char *name);
+XMLPUBFUN const char * XMLCALL
+	xmlGetCharEncodingName		(xmlCharEncoding enc);
+
+/*
+ * Interfaces directly used by the parsers.
+ */
+XMLPUBFUN xmlCharEncoding XMLCALL
+	xmlDetectCharEncoding		(const unsigned char *in,
+					 int len);
+
+XMLPUBFUN int XMLCALL	
+	xmlCharEncOutFunc		(xmlCharEncodingHandler *handler,
+					 xmlBufferPtr out,
+					 xmlBufferPtr in);
+
+XMLPUBFUN int XMLCALL	
+	xmlCharEncInFunc		(xmlCharEncodingHandler *handler,
+					 xmlBufferPtr out,
+					 xmlBufferPtr in);
+XMLPUBFUN int XMLCALL
+	xmlCharEncFirstLine		(xmlCharEncodingHandler *handler,
+					 xmlBufferPtr out,
+					 xmlBufferPtr in);
+XMLPUBFUN int XMLCALL	
+	xmlCharEncCloseFunc		(xmlCharEncodingHandler *handler);
+
+/*
+ * Export a few useful functions
+ */
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN int XMLCALL	
+	UTF8Toisolat1			(unsigned char *out,
+					 int *outlen,
+					 const unsigned char *in,
+					 int *inlen);
+#endif /* LIBXML_OUTPUT_ENABLED */
+XMLPUBFUN int XMLCALL	
+	isolat1ToUTF8			(unsigned char *out,
+					 int *outlen,
+					 const unsigned char *in,
+					 int *inlen);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __XML_CHAR_ENCODING_H__ */
diff -Naur orig.ns-2.33/libxml/entities.h ns-2.33/libxml/entities.h
--- orig.ns-2.33/libxml/entities.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/entities.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,140 @@
+/*
+ * Summary: interface for the XML entities handling
+ * Description: this module provides some of the entity API needed
+ *              for the parser and applications.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_ENTITIES_H__
+#define __XML_ENTITIES_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The different valid entity types.
+ */
+typedef enum {
+    XML_INTERNAL_GENERAL_ENTITY = 1,
+    XML_EXTERNAL_GENERAL_PARSED_ENTITY = 2,
+    XML_EXTERNAL_GENERAL_UNPARSED_ENTITY = 3,
+    XML_INTERNAL_PARAMETER_ENTITY = 4,
+    XML_EXTERNAL_PARAMETER_ENTITY = 5,
+    XML_INTERNAL_PREDEFINED_ENTITY = 6
+} xmlEntityType;
+
+/*
+ * An unit of storage for an entity, contains the string, the value
+ * and the linkind data needed for the linking in the hash table.
+ */
+
+struct _xmlEntity {
+    void           *_private;	        /* application data */
+    xmlElementType          type;       /* XML_ENTITY_DECL, must be second ! */
+    const xmlChar          *name;	/* Entity name */
+    struct _xmlNode    *children;	/* First child link */
+    struct _xmlNode        *last;	/* Last child link */
+    struct _xmlDtd       *parent;	/* -> DTD */
+    struct _xmlNode        *next;	/* next sibling link  */
+    struct _xmlNode        *prev;	/* previous sibling link  */
+    struct _xmlDoc          *doc;       /* the containing document */
+
+    xmlChar                *orig;	/* content without ref substitution */
+    xmlChar             *content;	/* content or ndata if unparsed */
+    int                   length;	/* the content length */
+    xmlEntityType          etype;	/* The entity type */
+    const xmlChar    *ExternalID;	/* External identifier for PUBLIC */
+    const xmlChar      *SystemID;	/* URI for a SYSTEM or PUBLIC Entity */
+
+    struct _xmlEntity     *nexte;	/* unused */
+    const xmlChar           *URI;	/* the full URI as computed */
+    int                    owner;	/* does the entity own the childrens */
+    int			 checked;	/* was the entity content checked */
+};
+
+/*
+ * All entities are stored in an hash table.
+ * There is 2 separate hash tables for global and parameter entities.
+ */
+
+typedef struct _xmlHashTable xmlEntitiesTable;
+typedef xmlEntitiesTable *xmlEntitiesTablePtr;
+
+/*
+ * External functions:
+ */
+
+#ifdef LIBXML_LEGACY_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlInitializePredefinedEntities	(void);
+#endif /* LIBXML_LEGACY_ENABLED */
+XMLPUBFUN xmlEntityPtr XMLCALL
+			xmlAddDocEntity		(xmlDocPtr doc,
+						 const xmlChar *name,
+						 int type,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID,
+						 const xmlChar *content);
+XMLPUBFUN xmlEntityPtr XMLCALL		
+			xmlAddDtdEntity		(xmlDocPtr doc,
+						 const xmlChar *name,
+						 int type,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID,
+						 const xmlChar *content);
+XMLPUBFUN xmlEntityPtr XMLCALL		
+			xmlGetPredefinedEntity	(const xmlChar *name);
+XMLPUBFUN xmlEntityPtr XMLCALL		
+			xmlGetDocEntity		(xmlDocPtr doc,
+						 const xmlChar *name);
+XMLPUBFUN xmlEntityPtr XMLCALL		
+			xmlGetDtdEntity		(xmlDocPtr doc,
+						 const xmlChar *name);
+XMLPUBFUN xmlEntityPtr XMLCALL		
+			xmlGetParameterEntity	(xmlDocPtr doc,
+						 const xmlChar *name);
+#ifdef LIBXML_LEGACY_ENABLED
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlEncodeEntities	(xmlDocPtr doc,
+						 const xmlChar *input);
+#endif /* LIBXML_LEGACY_ENABLED */
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlEncodeEntitiesReentrant(xmlDocPtr doc,
+						 const xmlChar *input);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlEncodeSpecialChars	(xmlDocPtr doc,
+						 const xmlChar *input);
+XMLPUBFUN xmlEntitiesTablePtr XMLCALL	
+			xmlCreateEntitiesTable	(void);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlEntitiesTablePtr XMLCALL	
+			xmlCopyEntitiesTable	(xmlEntitiesTablePtr table);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN void XMLCALL			
+			xmlFreeEntitiesTable	(xmlEntitiesTablePtr table);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL			
+			xmlDumpEntitiesTable	(xmlBufferPtr buf,
+						 xmlEntitiesTablePtr table);
+XMLPUBFUN void XMLCALL			
+			xmlDumpEntityDecl	(xmlBufferPtr buf,
+						 xmlEntityPtr ent);
+#endif /* LIBXML_OUTPUT_ENABLED */
+#ifdef LIBXML_LEGACY_ENABLED
+XMLPUBFUN void XMLCALL			
+			xmlCleanupPredefinedEntities(void);
+#endif /* LIBXML_LEGACY_ENABLED */
+
+
+#ifdef __cplusplus
+}
+#endif
+
+# endif /* __XML_ENTITIES_H__ */
diff -Naur orig.ns-2.33/libxml/globals.h ns-2.33/libxml/globals.h
--- orig.ns-2.33/libxml/globals.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/globals.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,455 @@
+/*
+ * Summary: interface for all global variables of the library
+ * Description: all the global variables and thread handling for
+ *              those variables is handled by this module.
+ *
+ * The bottom of this file is automatically generated by build_glob.py
+ * based on the description file global.data
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
+ */
+
+#ifndef __XML_GLOBALS_H
+#define __XML_GLOBALS_H
+
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+#include <libxml/xmlerror.h>
+#include <libxml/SAX.h>
+#include <libxml/SAX2.h>
+#include <libxml/xmlmemory.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+XMLPUBFUN void XMLCALL xmlInitGlobals(void);
+XMLPUBFUN void XMLCALL xmlCleanupGlobals(void);
+
+typedef xmlParserInputBufferPtr (*xmlParserInputBufferCreateFilenameFunc) (const char *URI, xmlCharEncoding enc);
+typedef xmlOutputBufferPtr (*xmlOutputBufferCreateFilenameFunc) (const char *URI, xmlCharEncodingHandlerPtr encoder, int compression);
+XMLPUBFUN xmlParserInputBufferCreateFilenameFunc
+XMLCALL xmlParserInputBufferCreateFilenameDefault (xmlParserInputBufferCreateFilenameFunc func);
+XMLPUBFUN xmlOutputBufferCreateFilenameFunc
+XMLCALL xmlOutputBufferCreateFilenameDefault (xmlOutputBufferCreateFilenameFunc func);
+
+/*
+ * Externally global symbols which need to be protected for backwards
+ * compatibility support.
+ */
+
+#undef	docbDefaultSAXHandler
+#undef	htmlDefaultSAXHandler
+#undef	oldXMLWDcompatibility
+#undef	xmlBufferAllocScheme
+#undef	xmlDefaultBufferSize
+#undef	xmlDefaultSAXHandler
+#undef	xmlDefaultSAXLocator
+#undef	xmlDoValidityCheckingDefaultValue
+#undef	xmlFree
+#undef	xmlGenericError
+#undef	xmlStructuredError
+#undef	xmlGenericErrorContext
+#undef	xmlGetWarningsDefaultValue
+#undef	xmlIndentTreeOutput
+#undef  xmlTreeIndentString
+#undef	xmlKeepBlanksDefaultValue
+#undef	xmlLineNumbersDefaultValue
+#undef	xmlLoadExtDtdDefaultValue
+#undef	xmlMalloc
+#undef	xmlMallocAtomic
+#undef	xmlMemStrdup
+#undef	xmlParserDebugEntities
+#undef	xmlParserVersion
+#undef	xmlPedanticParserDefaultValue
+#undef	xmlRealloc
+#undef	xmlSaveNoEmptyTags
+#undef	xmlSubstituteEntitiesDefaultValue
+#undef  xmlRegisterNodeDefaultValue
+#undef  xmlDeregisterNodeDefaultValue
+#undef  xmlLastError
+#undef  xmlParserInputBufferCreateFilenameValue
+#undef  xmlOutputBufferCreateFilenameValue
+
+typedef void (*xmlRegisterNodeFunc) (xmlNodePtr node);
+typedef void (*xmlDeregisterNodeFunc) (xmlNodePtr node);
+
+typedef struct _xmlGlobalState xmlGlobalState;
+typedef xmlGlobalState *xmlGlobalStatePtr;
+struct _xmlGlobalState 
+{
+	const char *xmlParserVersion;
+
+	xmlSAXLocator xmlDefaultSAXLocator;
+	xmlSAXHandlerV1 xmlDefaultSAXHandler;
+	xmlSAXHandlerV1 docbDefaultSAXHandler;
+	xmlSAXHandlerV1 htmlDefaultSAXHandler;
+
+	xmlFreeFunc xmlFree;
+	xmlMallocFunc xmlMalloc;
+	xmlStrdupFunc xmlMemStrdup;
+	xmlReallocFunc xmlRealloc;
+
+	xmlGenericErrorFunc xmlGenericError;
+	xmlStructuredErrorFunc xmlStructuredError;
+	void *xmlGenericErrorContext;
+
+	int oldXMLWDcompatibility;
+
+	xmlBufferAllocationScheme xmlBufferAllocScheme;
+	int xmlDefaultBufferSize;
+
+	int xmlSubstituteEntitiesDefaultValue;
+	int xmlDoValidityCheckingDefaultValue;
+	int xmlGetWarningsDefaultValue;
+	int xmlKeepBlanksDefaultValue;
+	int xmlLineNumbersDefaultValue;
+	int xmlLoadExtDtdDefaultValue;
+	int xmlParserDebugEntities;
+	int xmlPedanticParserDefaultValue;
+
+	int xmlSaveNoEmptyTags;
+	int xmlIndentTreeOutput;
+	const char *xmlTreeIndentString;
+
+  	xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;
+  	xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;
+
+	xmlMallocFunc xmlMallocAtomic;
+	xmlError xmlLastError;
+
+	xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;
+	xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;
+};
+
+#ifdef __cplusplus
+}
+#endif
+#include <libxml/threads.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+XMLPUBFUN void XMLCALL	xmlInitializeGlobalState(xmlGlobalStatePtr gs);
+
+XMLPUBFUN void XMLCALL xmlThrDefSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler);
+
+XMLPUBFUN void XMLCALL xmlThrDefSetStructuredErrorFunc(void *ctx, xmlStructuredErrorFunc handler);
+
+XMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlRegisterNodeDefault(xmlRegisterNodeFunc func);
+XMLPUBFUN xmlRegisterNodeFunc XMLCALL xmlThrDefRegisterNodeDefault(xmlRegisterNodeFunc func);
+XMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlDeregisterNodeDefault(xmlDeregisterNodeFunc func);
+XMLPUBFUN xmlDeregisterNodeFunc XMLCALL xmlThrDefDeregisterNodeDefault(xmlDeregisterNodeFunc func);
+
+XMLPUBFUN xmlOutputBufferCreateFilenameFunc XMLCALL 
+	xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);
+XMLPUBFUN xmlParserInputBufferCreateFilenameFunc XMLCALL 
+	xmlThrDefParserInputBufferCreateFilenameDefault(xmlParserInputBufferCreateFilenameFunc func);
+
+/** DOC_DISABLE */
+/*
+ * In general the memory allocation entry points are not kept
+ * thread specific but this can be overridden by LIBXML_THREAD_ALLOC_ENABLED
+ *    - xmlMalloc
+ *    - xmlMallocAtomic
+ *    - xmlRealloc
+ *    - xmlMemStrdup
+ *    - xmlFree
+ */
+
+#ifdef LIBXML_THREAD_ALLOC_ENABLED
+#ifdef LIBXML_THREAD_ENABLED
+XMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMalloc(void);
+#define xmlMalloc \
+(*(__xmlMalloc()))
+#else
+XMLPUBVAR xmlMallocFunc xmlMalloc;
+#endif
+
+#ifdef LIBXML_THREAD_ENABLED
+XMLPUBFUN  xmlMallocFunc * XMLCALL __xmlMallocAtomic(void);
+#define xmlMallocAtomic \
+(*(__xmlMallocAtomic()))
+#else
+XMLPUBVAR xmlMallocFunc xmlMallocAtomic;
+#endif
+
+#ifdef LIBXML_THREAD_ENABLED
+XMLPUBFUN  xmlReallocFunc * XMLCALL __xmlRealloc(void);
+#define xmlRealloc \
+(*(__xmlRealloc()))
+#else
+XMLPUBVAR xmlReallocFunc xmlRealloc;
+#endif
+
+#ifdef LIBXML_THREAD_ENABLED
+XMLPUBFUN  xmlFreeFunc * XMLCALL __xmlFree(void);
+#define xmlFree \
+(*(__xmlFree()))
+#else
+XMLPUBVAR xmlFreeFunc xmlFree;
+#endif
+
+#ifdef LIBXML_THREAD_ENABLED
+XMLPUBFUN  xmlStrdupFunc * XMLCALL __xmlMemStrdup(void);
+#define xmlMemStrdup \
+(*(__xmlMemStrdup()))
+#else
+XMLPUBVAR xmlStrdupFunc xmlMemStrdup;
+#endif
+
+#else /* !LIBXML_THREAD_ALLOC_ENABLED */
+XMLPUBVAR xmlMallocFunc xmlMalloc;
+XMLPUBVAR xmlMallocFunc xmlMallocAtomic;
+XMLPUBVAR xmlReallocFunc xmlRealloc;
+XMLPUBVAR xmlFreeFunc xmlFree;
+XMLPUBVAR xmlStrdupFunc xmlMemStrdup;
+#endif /* LIBXML_THREAD_ALLOC_ENABLED */
+
+#ifdef LIBXML_DOCB_ENABLED
+XMLPUBFUN  xmlSAXHandlerV1 * XMLCALL __docbDefaultSAXHandler(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define docbDefaultSAXHandler \
+(*(__docbDefaultSAXHandler()))
+#else
+XMLPUBVAR xmlSAXHandlerV1 docbDefaultSAXHandler;
+#endif
+#endif
+
+#ifdef LIBXML_HTML_ENABLED
+XMLPUBFUN xmlSAXHandlerV1 * XMLCALL __htmlDefaultSAXHandler(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define htmlDefaultSAXHandler \
+(*(__htmlDefaultSAXHandler()))
+#else
+XMLPUBVAR xmlSAXHandlerV1 htmlDefaultSAXHandler;
+#endif
+#endif
+
+XMLPUBFUN xmlError * XMLCALL __xmlLastError(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlLastError \
+(*(__xmlLastError()))
+#else
+XMLPUBVAR xmlError xmlLastError;
+#endif
+
+/*
+ * Everything starting from the line below is
+ * Automatically generated by build_glob.py.
+ * Do not modify the previous line.
+ */
+
+
+XMLPUBFUN int * XMLCALL __oldXMLWDcompatibility(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define oldXMLWDcompatibility \
+(*(__oldXMLWDcompatibility()))
+#else
+XMLPUBVAR int oldXMLWDcompatibility;
+#endif
+
+XMLPUBFUN xmlBufferAllocationScheme * XMLCALL __xmlBufferAllocScheme(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlBufferAllocScheme \
+(*(__xmlBufferAllocScheme()))
+#else
+XMLPUBVAR xmlBufferAllocationScheme xmlBufferAllocScheme;
+#endif
+XMLPUBFUN xmlBufferAllocationScheme XMLCALL xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);
+
+XMLPUBFUN int * XMLCALL __xmlDefaultBufferSize(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlDefaultBufferSize \
+(*(__xmlDefaultBufferSize()))
+#else
+XMLPUBVAR int xmlDefaultBufferSize;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefDefaultBufferSize(int v);
+
+XMLPUBFUN xmlSAXHandlerV1 * XMLCALL __xmlDefaultSAXHandler(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlDefaultSAXHandler \
+(*(__xmlDefaultSAXHandler()))
+#else
+XMLPUBVAR xmlSAXHandlerV1 xmlDefaultSAXHandler;
+#endif
+
+XMLPUBFUN xmlSAXLocator * XMLCALL __xmlDefaultSAXLocator(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlDefaultSAXLocator \
+(*(__xmlDefaultSAXLocator()))
+#else
+XMLPUBVAR xmlSAXLocator xmlDefaultSAXLocator;
+#endif
+
+XMLPUBFUN int * XMLCALL __xmlDoValidityCheckingDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlDoValidityCheckingDefaultValue \
+(*(__xmlDoValidityCheckingDefaultValue()))
+#else
+XMLPUBVAR int xmlDoValidityCheckingDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefDoValidityCheckingDefaultValue(int v);
+
+XMLPUBFUN xmlGenericErrorFunc * XMLCALL __xmlGenericError(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlGenericError \
+(*(__xmlGenericError()))
+#else
+XMLPUBVAR xmlGenericErrorFunc xmlGenericError;
+#endif
+
+XMLPUBFUN xmlStructuredErrorFunc * XMLCALL __xmlStructuredError(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlStructuredError \
+(*(__xmlStructuredError()))
+#else
+XMLPUBVAR xmlStructuredErrorFunc xmlStructuredError;
+#endif
+
+XMLPUBFUN void * * XMLCALL __xmlGenericErrorContext(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlGenericErrorContext \
+(*(__xmlGenericErrorContext()))
+#else
+XMLPUBVAR void * xmlGenericErrorContext;
+#endif
+
+XMLPUBFUN int * XMLCALL __xmlGetWarningsDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlGetWarningsDefaultValue \
+(*(__xmlGetWarningsDefaultValue()))
+#else
+XMLPUBVAR int xmlGetWarningsDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefGetWarningsDefaultValue(int v);
+
+XMLPUBFUN int * XMLCALL __xmlIndentTreeOutput(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlIndentTreeOutput \
+(*(__xmlIndentTreeOutput()))
+#else
+XMLPUBVAR int xmlIndentTreeOutput;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefIndentTreeOutput(int v);
+
+XMLPUBFUN const char * * XMLCALL __xmlTreeIndentString(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlTreeIndentString \
+(*(__xmlTreeIndentString()))
+#else
+XMLPUBVAR const char * xmlTreeIndentString;
+#endif
+XMLPUBFUN const char * XMLCALL xmlThrDefTreeIndentString(const char * v);
+
+XMLPUBFUN int * XMLCALL __xmlKeepBlanksDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlKeepBlanksDefaultValue \
+(*(__xmlKeepBlanksDefaultValue()))
+#else
+XMLPUBVAR int xmlKeepBlanksDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefKeepBlanksDefaultValue(int v);
+
+XMLPUBFUN int * XMLCALL __xmlLineNumbersDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlLineNumbersDefaultValue \
+(*(__xmlLineNumbersDefaultValue()))
+#else
+XMLPUBVAR int xmlLineNumbersDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefLineNumbersDefaultValue(int v);
+
+XMLPUBFUN int * XMLCALL __xmlLoadExtDtdDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlLoadExtDtdDefaultValue \
+(*(__xmlLoadExtDtdDefaultValue()))
+#else
+XMLPUBVAR int xmlLoadExtDtdDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefLoadExtDtdDefaultValue(int v);
+
+XMLPUBFUN int * XMLCALL __xmlParserDebugEntities(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlParserDebugEntities \
+(*(__xmlParserDebugEntities()))
+#else
+XMLPUBVAR int xmlParserDebugEntities;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefParserDebugEntities(int v);
+
+XMLPUBFUN const char * * XMLCALL __xmlParserVersion(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlParserVersion \
+(*(__xmlParserVersion()))
+#else
+XMLPUBVAR const char * xmlParserVersion;
+#endif
+
+XMLPUBFUN int * XMLCALL __xmlPedanticParserDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlPedanticParserDefaultValue \
+(*(__xmlPedanticParserDefaultValue()))
+#else
+XMLPUBVAR int xmlPedanticParserDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefPedanticParserDefaultValue(int v);
+
+XMLPUBFUN int * XMLCALL __xmlSaveNoEmptyTags(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlSaveNoEmptyTags \
+(*(__xmlSaveNoEmptyTags()))
+#else
+XMLPUBVAR int xmlSaveNoEmptyTags;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefSaveNoEmptyTags(int v);
+
+XMLPUBFUN int * XMLCALL __xmlSubstituteEntitiesDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlSubstituteEntitiesDefaultValue \
+(*(__xmlSubstituteEntitiesDefaultValue()))
+#else
+XMLPUBVAR int xmlSubstituteEntitiesDefaultValue;
+#endif
+XMLPUBFUN int XMLCALL xmlThrDefSubstituteEntitiesDefaultValue(int v);
+
+XMLPUBFUN xmlRegisterNodeFunc * XMLCALL __xmlRegisterNodeDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlRegisterNodeDefaultValue \
+(*(__xmlRegisterNodeDefaultValue()))
+#else
+XMLPUBVAR xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;
+#endif
+
+XMLPUBFUN xmlDeregisterNodeFunc * XMLCALL __xmlDeregisterNodeDefaultValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlDeregisterNodeDefaultValue \
+(*(__xmlDeregisterNodeDefaultValue()))
+#else
+XMLPUBVAR xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;
+#endif
+
+XMLPUBFUN xmlParserInputBufferCreateFilenameFunc * XMLCALL __xmlParserInputBufferCreateFilenameValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlParserInputBufferCreateFilenameValue \
+(*(__xmlParserInputBufferCreateFilenameValue()))
+#else
+XMLPUBVAR xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;
+#endif
+
+XMLPUBFUN xmlOutputBufferCreateFilenameFunc * XMLCALL __xmlOutputBufferCreateFilenameValue(void);
+#ifdef LIBXML_THREAD_ENABLED
+#define xmlOutputBufferCreateFilenameValue \
+(*(__xmlOutputBufferCreateFilenameValue()))
+#else
+XMLPUBVAR xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __XML_GLOBALS_H */
diff -Naur orig.ns-2.33/libxml/hash.h ns-2.33/libxml/hash.h
--- orig.ns-2.33/libxml/hash.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/hash.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,233 @@
+/*
+ * Summary: Chained hash tables
+ * Description: This module implements the hash table support used in 
+ * 		various places in the library.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Bjorn Reese <bjorn.reese@systematic.dk>
+ */
+
+#ifndef __XML_HASH_H__
+#define __XML_HASH_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The hash table.
+ */
+typedef struct _xmlHashTable xmlHashTable;
+typedef xmlHashTable *xmlHashTablePtr;
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+#include <libxml/dict.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Recent version of gcc produce a warning when a function pointer is assigned
+ * to an object pointer, or vice versa.  The following macro is a dirty hack
+ * to allow suppression of the warning.  If your architecture has function
+ * pointers which are a different size than a void pointer, there may be some
+ * serious trouble within the library.
+ */
+/**
+ * XML_CAST_FPTR:
+ * @fptr:  pointer to a function
+ *
+ * Macro to do a casting from an object pointer to a
+ * function pointer without encountering a warning from
+ * gcc
+ *
+ * #define XML_CAST_FPTR(fptr) (*(void **)(&fptr))
+ * This macro violated ISO C aliasing rules (gcc4 on s390 broke)
+ * so it is disabled now
+ */
+
+#define XML_CAST_FPTR(fptr) fptr
+
+
+/*
+ * function types:
+ */
+/**
+ * xmlHashDeallocator:
+ * @payload:  the data in the hash
+ * @name:  the name associated
+ *
+ * Callback to free data from a hash.
+ */
+typedef void (*xmlHashDeallocator)(void *payload, xmlChar *name);
+/**
+ * xmlHashCopier:
+ * @payload:  the data in the hash
+ * @name:  the name associated
+ *
+ * Callback to copy data from a hash.
+ *
+ * Returns a copy of the data or NULL in case of error.
+ */
+typedef void *(*xmlHashCopier)(void *payload, xmlChar *name);
+/**
+ * xmlHashScanner:
+ * @payload:  the data in the hash
+ * @data:  extra scannner data
+ * @name:  the name associated
+ *
+ * Callback when scanning data in a hash with the simple scanner.
+ */
+typedef void (*xmlHashScanner)(void *payload, void *data, xmlChar *name);
+/**
+ * xmlHashScannerFull:
+ * @payload:  the data in the hash
+ * @data:  extra scannner data
+ * @name:  the name associated
+ * @name2:  the second name associated
+ * @name3:  the third name associated
+ *
+ * Callback when scanning data in a hash with the full scanner.
+ */
+typedef void (*xmlHashScannerFull)(void *payload, void *data,
+				   const xmlChar *name, const xmlChar *name2,
+				   const xmlChar *name3);
+
+/*
+ * Constructor and destructor.
+ */
+XMLPUBFUN xmlHashTablePtr XMLCALL
+			xmlHashCreate	(int size);
+XMLPUBFUN xmlHashTablePtr XMLCALL
+			xmlHashCreateDict(int size,
+					 xmlDictPtr dict);
+XMLPUBFUN void XMLCALL			
+			xmlHashFree	(xmlHashTablePtr table,
+					 xmlHashDeallocator f);
+
+/*
+ * Add a new entry to the hash table.
+ */
+XMLPUBFUN int XMLCALL			
+			xmlHashAddEntry	(xmlHashTablePtr table,
+		                         const xmlChar *name,
+		                         void *userdata);
+XMLPUBFUN int XMLCALL			
+			xmlHashUpdateEntry(xmlHashTablePtr table,
+		                         const xmlChar *name,
+		                         void *userdata,
+					 xmlHashDeallocator f);
+XMLPUBFUN int XMLCALL		    
+			xmlHashAddEntry2(xmlHashTablePtr table,
+		                         const xmlChar *name,
+		                         const xmlChar *name2,
+		                         void *userdata);
+XMLPUBFUN int XMLCALL			
+			xmlHashUpdateEntry2(xmlHashTablePtr table,
+		                         const xmlChar *name,
+		                         const xmlChar *name2,
+		                         void *userdata,
+					 xmlHashDeallocator f);
+XMLPUBFUN int XMLCALL			
+			xmlHashAddEntry3(xmlHashTablePtr table,
+		                         const xmlChar *name,
+		                         const xmlChar *name2,
+		                         const xmlChar *name3,
+		                         void *userdata);
+XMLPUBFUN int XMLCALL			
+			xmlHashUpdateEntry3(xmlHashTablePtr table,
+		                         const xmlChar *name,
+		                         const xmlChar *name2,
+		                         const xmlChar *name3,
+		                         void *userdata,
+					 xmlHashDeallocator f);
+
+/*
+ * Remove an entry from the hash table.
+ */
+XMLPUBFUN int XMLCALL     
+			xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,
+                           xmlHashDeallocator f);
+XMLPUBFUN int XMLCALL     
+			xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,
+                            const xmlChar *name2, xmlHashDeallocator f);
+XMLPUBFUN int  XMLCALL    
+			xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,
+                            const xmlChar *name2, const xmlChar *name3,
+                            xmlHashDeallocator f);
+
+/*
+ * Retrieve the userdata.
+ */
+XMLPUBFUN void * XMLCALL			
+			xmlHashLookup	(xmlHashTablePtr table,
+					 const xmlChar *name);
+XMLPUBFUN void * XMLCALL			
+			xmlHashLookup2	(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *name2);
+XMLPUBFUN void * XMLCALL			
+			xmlHashLookup3	(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *name2,
+					 const xmlChar *name3);
+XMLPUBFUN void * XMLCALL			
+			xmlHashQLookup	(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *prefix);
+XMLPUBFUN void * XMLCALL			
+			xmlHashQLookup2	(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *prefix,
+					 const xmlChar *name2,
+					 const xmlChar *prefix2);
+XMLPUBFUN void * XMLCALL			
+			xmlHashQLookup3	(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *prefix,
+					 const xmlChar *name2,
+					 const xmlChar *prefix2,
+					 const xmlChar *name3,
+					 const xmlChar *prefix3);
+
+/*
+ * Helpers.
+ */
+XMLPUBFUN xmlHashTablePtr XMLCALL		
+			xmlHashCopy	(xmlHashTablePtr table,
+					 xmlHashCopier f);
+XMLPUBFUN int XMLCALL			
+			xmlHashSize	(xmlHashTablePtr table);
+XMLPUBFUN void XMLCALL			
+			xmlHashScan	(xmlHashTablePtr table,
+					 xmlHashScanner f,
+					 void *data);
+XMLPUBFUN void XMLCALL			
+			xmlHashScan3	(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *name2,
+					 const xmlChar *name3,
+					 xmlHashScanner f,
+					 void *data);
+XMLPUBFUN void XMLCALL			
+			xmlHashScanFull	(xmlHashTablePtr table,
+					 xmlHashScannerFull f,
+					 void *data);
+XMLPUBFUN void XMLCALL			
+			xmlHashScanFull3(xmlHashTablePtr table,
+					 const xmlChar *name,
+					 const xmlChar *name2,
+					 const xmlChar *name3,
+					 xmlHashScannerFull f,
+					 void *data);
+#ifdef __cplusplus
+}
+#endif
+#endif /* ! __XML_HASH_H__ */
diff -Naur orig.ns-2.33/libxml/list.h ns-2.33/libxml/list.h
--- orig.ns-2.33/libxml/list.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/list.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,137 @@
+/*
+ * Summary: lists interfaces
+ * Description: this module implement the list support used in 
+ * various place in the library.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Gary Pennington <Gary.Pennington@uk.sun.com>
+ */
+
+#ifndef __XML_LINK_INCLUDE__
+#define __XML_LINK_INCLUDE__
+
+#include <libxml/xmlversion.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _xmlLink xmlLink;
+typedef xmlLink *xmlLinkPtr;
+
+typedef struct _xmlList xmlList;
+typedef xmlList *xmlListPtr;
+
+/**
+ * xmlListDeallocator:
+ * @lk:  the data to deallocate
+ *
+ * Callback function used to free data from a list.
+ */
+typedef void (*xmlListDeallocator) (xmlLinkPtr lk);
+/**
+ * xmlListDataCompare:
+ * @data0: the first data
+ * @data1: the second data
+ *
+ * Callback function used to compare 2 data.
+ *
+ * Returns 0 is equality, -1 or 1 otherwise depending on the ordering.
+ */
+typedef int  (*xmlListDataCompare) (const void *data0, const void *data1);
+/**
+ * xmlListWalker:
+ * @data: the data found in the list
+ * @user: extra user provided data to the walker
+ *
+ * Callback function used when walking a list with xmlListWalk().
+ *
+ * Returns 0 to stop walking the list, 1 otherwise.
+ */
+typedef int (*xmlListWalker) (const void *data, const void *user);
+
+/* Creation/Deletion */
+XMLPUBFUN xmlListPtr XMLCALL
+		xmlListCreate		(xmlListDeallocator deallocator,
+	                                 xmlListDataCompare compare);
+XMLPUBFUN void XMLCALL		
+		xmlListDelete		(xmlListPtr l);
+
+/* Basic Operators */
+XMLPUBFUN void * XMLCALL		
+		xmlListSearch		(xmlListPtr l,
+					 void *data);
+XMLPUBFUN void * XMLCALL		
+		xmlListReverseSearch	(xmlListPtr l,
+					 void *data);
+XMLPUBFUN int XMLCALL		
+		xmlListInsert		(xmlListPtr l,
+					 void *data) ;
+XMLPUBFUN int XMLCALL		
+		xmlListAppend		(xmlListPtr l,
+					 void *data) ;
+XMLPUBFUN int XMLCALL		
+		xmlListRemoveFirst	(xmlListPtr l,
+					 void *data);
+XMLPUBFUN int XMLCALL		
+		xmlListRemoveLast	(xmlListPtr l,
+					 void *data);
+XMLPUBFUN int XMLCALL		
+		xmlListRemoveAll	(xmlListPtr l,
+					 void *data);
+XMLPUBFUN void XMLCALL		
+		xmlListClear		(xmlListPtr l);
+XMLPUBFUN int XMLCALL		
+		xmlListEmpty		(xmlListPtr l);
+XMLPUBFUN xmlLinkPtr XMLCALL	
+		xmlListFront		(xmlListPtr l);
+XMLPUBFUN xmlLinkPtr XMLCALL	
+		xmlListEnd		(xmlListPtr l);
+XMLPUBFUN int XMLCALL		
+		xmlListSize		(xmlListPtr l);
+
+XMLPUBFUN void XMLCALL		
+		xmlListPopFront		(xmlListPtr l);
+XMLPUBFUN void XMLCALL		
+		xmlListPopBack		(xmlListPtr l);
+XMLPUBFUN int XMLCALL		
+		xmlListPushFront	(xmlListPtr l,
+					 void *data);
+XMLPUBFUN int XMLCALL		
+		xmlListPushBack		(xmlListPtr l,
+					 void *data);
+
+/* Advanced Operators */
+XMLPUBFUN void XMLCALL		
+		xmlListReverse		(xmlListPtr l);
+XMLPUBFUN void XMLCALL		
+		xmlListSort		(xmlListPtr l);
+XMLPUBFUN void XMLCALL		
+		xmlListWalk		(xmlListPtr l,
+					 xmlListWalker walker,
+					 const void *user);
+XMLPUBFUN void XMLCALL		
+		xmlListReverseWalk	(xmlListPtr l,
+					 xmlListWalker walker,
+					 const void *user);
+XMLPUBFUN void XMLCALL		
+		xmlListMerge		(xmlListPtr l1,
+					 xmlListPtr l2);
+XMLPUBFUN xmlListPtr XMLCALL	
+		xmlListDup		(const xmlListPtr old);
+XMLPUBFUN int XMLCALL		
+		xmlListCopy		(xmlListPtr cur,
+					 const xmlListPtr old);
+/* Link operators */
+XMLPUBFUN void * XMLCALL          
+		xmlLinkGetData          (xmlLinkPtr lk);
+
+/* xmlListUnique() */
+/* xmlListSwap */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __XML_LINK_INCLUDE__ */
diff -Naur orig.ns-2.33/libxml/nanoftp.h ns-2.33/libxml/nanoftp.h
--- orig.ns-2.33/libxml/nanoftp.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/nanoftp.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,143 @@
+/*
+ * Summary: minimal FTP implementation
+ * Description: minimal FTP implementation allowing to fetch resources
+ *              like external subset.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+ 
+#ifndef __NANO_FTP_H__
+#define __NANO_FTP_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_FTP_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * ftpListCallback: 
+ * @userData:  user provided data for the callback
+ * @filename:  the file name (including "->" when links are shown)
+ * @attrib:  the attribute string
+ * @owner:  the owner string
+ * @group:  the group string
+ * @size:  the file size
+ * @links:  the link count
+ * @year:  the year
+ * @month:  the month
+ * @day:  the day
+ * @hour:  the hour
+ * @minute:  the minute
+ *
+ * A callback for the xmlNanoFTPList command.
+ * Note that only one of year and day:minute are specified.
+ */
+typedef void (*ftpListCallback) (void *userData,
+	                         const char *filename, const char *attrib,
+	                         const char *owner, const char *group,
+				 unsigned long size, int links, int year,
+				 const char *month, int day, int hour,
+				 int minute);
+/**
+ * ftpDataCallback: 
+ * @userData: the user provided context
+ * @data: the data received
+ * @len: its size in bytes
+ *
+ * A callback for the xmlNanoFTPGet command.
+ */
+typedef void (*ftpDataCallback) (void *userData,
+				 const char *data,
+				 int len);
+
+/*
+ * Init
+ */
+XMLPUBFUN void XMLCALL
+	xmlNanoFTPInit		(void);
+XMLPUBFUN void XMLCALL	
+	xmlNanoFTPCleanup	(void);
+
+/*
+ * Creating/freeing contexts.
+ */
+XMLPUBFUN void * XMLCALL	
+	xmlNanoFTPNewCtxt	(const char *URL);
+XMLPUBFUN void XMLCALL	
+	xmlNanoFTPFreeCtxt	(void * ctx);
+XMLPUBFUN void * XMLCALL 	
+	xmlNanoFTPConnectTo	(const char *server,
+				 int port);
+/*
+ * Opening/closing session connections.
+ */
+XMLPUBFUN void * XMLCALL 	
+	xmlNanoFTPOpen		(const char *URL);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPConnect	(void *ctx);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPClose		(void *ctx);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPQuit		(void *ctx);
+XMLPUBFUN void XMLCALL	
+	xmlNanoFTPScanProxy	(const char *URL);
+XMLPUBFUN void XMLCALL	
+	xmlNanoFTPProxy		(const char *host,
+				 int port,
+				 const char *user,
+				 const char *passwd,
+				 int type);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPUpdateURL	(void *ctx,
+				 const char *URL);
+
+/*
+ * Rather internal commands.
+ */
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPGetResponse	(void *ctx);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPCheckResponse	(void *ctx);
+
+/*
+ * CD/DIR/GET handlers.
+ */
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPCwd		(void *ctx,
+				 const char *directory);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPDele		(void *ctx,
+				 const char *file);
+
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPGetConnection	(void *ctx);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPCloseConnection(void *ctx);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPList		(void *ctx,
+				 ftpListCallback callback,
+				 void *userData,
+				 const char *filename);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPGetSocket	(void *ctx,
+				 const char *filename);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPGet		(void *ctx,
+				 ftpDataCallback callback,
+				 void *userData,
+				 const char *filename);
+XMLPUBFUN int XMLCALL	
+	xmlNanoFTPRead		(void *ctx,
+				 void *dest,
+				 int len);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* LIBXML_FTP_ENABLED */
+#endif /* __NANO_FTP_H__ */
diff -Naur orig.ns-2.33/libxml/nanohttp.h ns-2.33/libxml/nanohttp.h
--- orig.ns-2.33/libxml/nanohttp.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/nanohttp.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,81 @@
+/*
+ * Summary: minimal HTTP implementation
+ * Description: minimal HTTP implementation allowing to fetch resources
+ *              like external subset.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+ 
+#ifndef __NANO_HTTP_H__
+#define __NANO_HTTP_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_HTTP_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+XMLPUBFUN void XMLCALL
+	xmlNanoHTTPInit		(void);
+XMLPUBFUN void XMLCALL	
+	xmlNanoHTTPCleanup	(void);
+XMLPUBFUN void XMLCALL	
+	xmlNanoHTTPScanProxy	(const char *URL);
+XMLPUBFUN int XMLCALL	
+	xmlNanoHTTPFetch	(const char *URL,
+				 const char *filename,
+				 char **contentType);
+XMLPUBFUN void * XMLCALL	
+	xmlNanoHTTPMethod	(const char *URL,
+				 const char *method,
+				 const char *input,
+				 char **contentType,
+				 const char *headers,
+				 int   ilen);
+XMLPUBFUN void * XMLCALL	
+	xmlNanoHTTPMethodRedir	(const char *URL,
+				 const char *method,
+				 const char *input,
+				 char **contentType,
+				 char **redir,
+				 const char *headers,
+				 int   ilen);
+XMLPUBFUN void * XMLCALL	
+	xmlNanoHTTPOpen		(const char *URL,
+				 char **contentType);
+XMLPUBFUN void * XMLCALL	
+	xmlNanoHTTPOpenRedir	(const char *URL,
+				 char **contentType,
+				 char **redir);
+XMLPUBFUN int XMLCALL	
+	xmlNanoHTTPReturnCode	(void *ctx);
+XMLPUBFUN const char * XMLCALL 
+	xmlNanoHTTPAuthHeader	(void *ctx);
+XMLPUBFUN const char * XMLCALL
+	xmlNanoHTTPRedir	(void *ctx);
+XMLPUBFUN int XMLCALL
+	xmlNanoHTTPContentLength( void * ctx );
+XMLPUBFUN const char * XMLCALL
+	xmlNanoHTTPEncoding	(void *ctx);
+XMLPUBFUN const char * XMLCALL
+	xmlNanoHTTPMimeType	(void *ctx);
+XMLPUBFUN int XMLCALL	
+	xmlNanoHTTPRead		(void *ctx,
+				 void *dest,
+				 int len);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN int XMLCALL	
+	xmlNanoHTTPSave		(void *ctxt,
+				 const char *filename);
+#endif /* LIBXML_OUTPUT_ENABLED */
+XMLPUBFUN void XMLCALL	
+	xmlNanoHTTPClose	(void *ctx);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_HTTP_ENABLED */
+#endif /* __NANO_HTTP_H__ */
diff -Naur orig.ns-2.33/libxml/parser.h ns-2.33/libxml/parser.h
--- orig.ns-2.33/libxml/parser.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/parser.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,1220 @@
+/*
+ * Summary: the core parser module
+ * Description: Interfaces, constants and types related to the XML parser
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_PARSER_H__
+#define __XML_PARSER_H__
+
+#include <stdarg.h>
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+#include <libxml/dict.h>
+#include <libxml/hash.h>
+#include <libxml/valid.h>
+#include <libxml/entities.h>
+#include <libxml/xmlerror.h>
+#include <libxml/xmlstring.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * XML_DEFAULT_VERSION:
+ *
+ * The default version of XML used: 1.0
+ */
+#define XML_DEFAULT_VERSION	"1.0"
+
+/**
+ * xmlParserInput:
+ *
+ * An xmlParserInput is an input flow for the XML processor.
+ * Each entity parsed is associated an xmlParserInput (except the
+ * few predefined ones). This is the case both for internal entities
+ * - in which case the flow is already completely in memory - or
+ * external entities - in which case we use the buf structure for
+ * progressive reading and I18N conversions to the internal UTF-8 format.
+ */
+
+/**
+ * xmlParserInputDeallocate:
+ * @str:  the string to deallocate
+ *
+ * Callback for freeing some parser input allocations.
+ */
+typedef void (* xmlParserInputDeallocate)(xmlChar *str);
+
+struct _xmlParserInput {
+    /* Input buffer */
+    xmlParserInputBufferPtr buf;      /* UTF-8 encoded buffer */
+
+    const char *filename;             /* The file analyzed, if any */
+    const char *directory;            /* the directory/base of the file */
+    const xmlChar *base;              /* Base of the array to parse */
+    const xmlChar *cur;               /* Current char being parsed */
+    const xmlChar *end;               /* end of the array to parse */
+    int length;                       /* length if known */
+    int line;                         /* Current line */
+    int col;                          /* Current column */
+    /*
+     * NOTE: consumed is only tested for equality in the parser code,
+     *       so even if there is an overflow this should not give troubles
+     *       for parsing very large instances.
+     */
+    unsigned long consumed;           /* How many xmlChars already consumed */
+    xmlParserInputDeallocate free;    /* function to deallocate the base */
+    const xmlChar *encoding;          /* the encoding string for entity */
+    const xmlChar *version;           /* the version string for entity */
+    int standalone;                   /* Was that entity marked standalone */
+    int id;                           /* an unique identifier for the entity */
+};
+
+/**
+ * xmlParserNodeInfo:
+ *
+ * The parser can be asked to collect Node informations, i.e. at what
+ * place in the file they were detected. 
+ * NOTE: This is off by default and not very well tested.
+ */
+typedef struct _xmlParserNodeInfo xmlParserNodeInfo;
+typedef xmlParserNodeInfo *xmlParserNodeInfoPtr;
+
+struct _xmlParserNodeInfo {
+  const struct _xmlNode* node;
+  /* Position & line # that text that created the node begins & ends on */
+  unsigned long begin_pos;
+  unsigned long begin_line;
+  unsigned long end_pos;
+  unsigned long end_line;
+};
+
+typedef struct _xmlParserNodeInfoSeq xmlParserNodeInfoSeq;
+typedef xmlParserNodeInfoSeq *xmlParserNodeInfoSeqPtr;
+struct _xmlParserNodeInfoSeq {
+  unsigned long maximum;
+  unsigned long length;
+  xmlParserNodeInfo* buffer;
+};
+
+/**
+ * xmlParserInputState:
+ *
+ * The parser is now working also as a state based parser.
+ * The recursive one use the state info for entities processing.
+ */
+typedef enum {
+    XML_PARSER_EOF = -1,	/* nothing is to be parsed */
+    XML_PARSER_START = 0,	/* nothing has been parsed */
+    XML_PARSER_MISC,		/* Misc* before int subset */
+    XML_PARSER_PI,		/* Within a processing instruction */
+    XML_PARSER_DTD,		/* within some DTD content */
+    XML_PARSER_PROLOG,		/* Misc* after internal subset */
+    XML_PARSER_COMMENT,		/* within a comment */
+    XML_PARSER_START_TAG,	/* within a start tag */
+    XML_PARSER_CONTENT,		/* within the content */
+    XML_PARSER_CDATA_SECTION,	/* within a CDATA section */
+    XML_PARSER_END_TAG,		/* within a closing tag */
+    XML_PARSER_ENTITY_DECL,	/* within an entity declaration */
+    XML_PARSER_ENTITY_VALUE,	/* within an entity value in a decl */
+    XML_PARSER_ATTRIBUTE_VALUE,	/* within an attribute value */
+    XML_PARSER_SYSTEM_LITERAL,	/* within a SYSTEM value */
+    XML_PARSER_EPILOG, 		/* the Misc* after the last end tag */
+    XML_PARSER_IGNORE,		/* within an IGNORED section */
+    XML_PARSER_PUBLIC_LITERAL 	/* within a PUBLIC value */
+} xmlParserInputState;
+
+/**
+ * XML_DETECT_IDS:
+ *
+ * Bit in the loadsubset context field to tell to do ID/REFs lookups.
+ * Use it to initialize xmlLoadExtDtdDefaultValue.
+ */
+#define XML_DETECT_IDS		2
+
+/**
+ * XML_COMPLETE_ATTRS:
+ *
+ * Bit in the loadsubset context field to tell to do complete the
+ * elements attributes lists with the ones defaulted from the DTDs.
+ * Use it to initialize xmlLoadExtDtdDefaultValue.
+ */
+#define XML_COMPLETE_ATTRS	4
+
+/**
+ * XML_SKIP_IDS:
+ *
+ * Bit in the loadsubset context field to tell to not do ID/REFs registration.
+ * Used to initialize xmlLoadExtDtdDefaultValue in some special cases.
+ */
+#define XML_SKIP_IDS		8
+
+/**
+ * xmlParserMode:
+ *
+ * A parser can operate in various modes
+ */
+typedef enum {
+    XML_PARSE_UNKNOWN = 0,
+    XML_PARSE_DOM = 1,
+    XML_PARSE_SAX = 2,
+    XML_PARSE_PUSH_DOM = 3,
+    XML_PARSE_PUSH_SAX = 4,
+    XML_PARSE_READER = 5
+} xmlParserMode;
+
+/**
+ * xmlParserCtxt:
+ *
+ * The parser context.
+ * NOTE This doesn't completely define the parser state, the (current ?)
+ *      design of the parser uses recursive function calls since this allow
+ *      and easy mapping from the production rules of the specification
+ *      to the actual code. The drawback is that the actual function call
+ *      also reflect the parser state. However most of the parsing routines
+ *      takes as the only argument the parser context pointer, so migrating
+ *      to a state based parser for progressive parsing shouldn't be too hard.
+ */
+struct _xmlParserCtxt {
+    struct _xmlSAXHandler *sax;       /* The SAX handler */
+    void            *userData;        /* For SAX interface only, used by DOM build */
+    xmlDocPtr           myDoc;        /* the document being built */
+    int            wellFormed;        /* is the document well formed */
+    int       replaceEntities;        /* shall we replace entities ? */
+    const xmlChar    *version;        /* the XML version string */
+    const xmlChar   *encoding;        /* the declared encoding, if any */
+    int            standalone;        /* standalone document */
+    int                  html;        /* an HTML(1)/Docbook(2) document */
+
+    /* Input stream stack */
+    xmlParserInputPtr  input;         /* Current input stream */
+    int                inputNr;       /* Number of current input streams */
+    int                inputMax;      /* Max number of input streams */
+    xmlParserInputPtr *inputTab;      /* stack of inputs */
+
+    /* Node analysis stack only used for DOM building */
+    xmlNodePtr         node;          /* Current parsed Node */
+    int                nodeNr;        /* Depth of the parsing stack */
+    int                nodeMax;       /* Max depth of the parsing stack */
+    xmlNodePtr        *nodeTab;       /* array of nodes */
+
+    int record_info;                  /* Whether node info should be kept */
+    xmlParserNodeInfoSeq node_seq;    /* info about each node parsed */
+
+    int errNo;                        /* error code */
+
+    int     hasExternalSubset;        /* reference and external subset */
+    int             hasPErefs;        /* the internal subset has PE refs */
+    int              external;        /* are we parsing an external entity */
+
+    int                 valid;        /* is the document valid */
+    int              validate;        /* shall we try to validate ? */
+    xmlValidCtxt        vctxt;        /* The validity context */
+
+    xmlParserInputState instate;      /* current type of input */
+    int                 token;        /* next char look-ahead */    
+
+    char           *directory;        /* the data directory */
+
+    /* Node name stack */
+    const xmlChar     *name;          /* Current parsed Node */
+    int                nameNr;        /* Depth of the parsing stack */
+    int                nameMax;       /* Max depth of the parsing stack */
+    const xmlChar *   *nameTab;       /* array of nodes */
+
+    long               nbChars;       /* number of xmlChar processed */
+    long            checkIndex;       /* used by progressive parsing lookup */
+    int             keepBlanks;       /* ugly but ... */
+    int             disableSAX;       /* SAX callbacks are disabled */
+    int               inSubset;       /* Parsing is in int 1/ext 2 subset */
+    const xmlChar *    intSubName;    /* name of subset */
+    xmlChar *          extSubURI;     /* URI of external subset */
+    xmlChar *          extSubSystem;  /* SYSTEM ID of external subset */
+
+    /* xml:space values */
+    int *              space;         /* Should the parser preserve spaces */
+    int                spaceNr;       /* Depth of the parsing stack */
+    int                spaceMax;      /* Max depth of the parsing stack */
+    int *              spaceTab;      /* array of space infos */
+
+    int                depth;         /* to prevent entity substitution loops */
+    xmlParserInputPtr  entity;        /* used to check entities boundaries */
+    int                charset;       /* encoding of the in-memory content
+				         actually an xmlCharEncoding */
+    int                nodelen;       /* Those two fields are there to */
+    int                nodemem;       /* Speed up large node parsing */
+    int                pedantic;      /* signal pedantic warnings */
+    void              *_private;      /* For user data, libxml won't touch it */
+
+    int                loadsubset;    /* should the external subset be loaded */
+    int                linenumbers;   /* set line number in element content */
+    void              *catalogs;      /* document's own catalog */
+    int                recovery;      /* run in recovery mode */
+    int                progressive;   /* is this a progressive parsing */
+    xmlDictPtr         dict;          /* dictionnary for the parser */
+    const xmlChar *   *atts;          /* array for the attributes callbacks */
+    int                maxatts;       /* the size of the array */
+    int                docdict;       /* use strings from dict to build tree */
+
+    /*
+     * pre-interned strings
+     */
+    const xmlChar *str_xml;
+    const xmlChar *str_xmlns;
+    const xmlChar *str_xml_ns;
+
+    /*
+     * Everything below is used only by the new SAX mode
+     */
+    int                sax2;          /* operating in the new SAX mode */
+    int                nsNr;          /* the number of inherited namespaces */
+    int                nsMax;         /* the size of the arrays */
+    const xmlChar *   *nsTab;         /* the array of prefix/namespace name */
+    int               *attallocs;     /* which attribute were allocated */
+    void *            *pushTab;       /* array of data for push */
+    xmlHashTablePtr    attsDefault;   /* defaulted attributes if any */
+    xmlHashTablePtr    attsSpecial;   /* non-CDATA attributes if any */
+    int                nsWellFormed;  /* is the document XML Nanespace okay */
+    int                options;       /* Extra options */
+
+    /*
+     * Those fields are needed only for treaming parsing so far
+     */
+    int               dictNames;    /* Use dictionary names for the tree */
+    int               freeElemsNr;  /* number of freed element nodes */
+    xmlNodePtr        freeElems;    /* List of freed element nodes */
+    int               freeAttrsNr;  /* number of freed attributes nodes */
+    xmlAttrPtr        freeAttrs;    /* List of freed attributes nodes */
+
+    /*
+     * the complete error informations for the last error.
+     */
+    xmlError          lastError;
+    xmlParserMode     parseMode;    /* the parser mode */
+};
+
+/**
+ * xmlSAXLocator:
+ *
+ * A SAX Locator.
+ */
+struct _xmlSAXLocator {
+    const xmlChar *(*getPublicId)(void *ctx);
+    const xmlChar *(*getSystemId)(void *ctx);
+    int (*getLineNumber)(void *ctx);
+    int (*getColumnNumber)(void *ctx);
+};
+
+/**
+ * xmlSAXHandler:
+ *
+ * A SAX handler is bunch of callbacks called by the parser when processing
+ * of the input generate data or structure informations.
+ */
+
+/**
+ * resolveEntitySAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @publicId: The public ID of the entity
+ * @systemId: The system ID of the entity
+ *
+ * Callback:
+ * The entity loader, to control the loading of external entities,
+ * the application can either:
+ *    - override this resolveEntity() callback in the SAX block
+ *    - or better use the xmlSetExternalEntityLoader() function to
+ *      set up it's own entity resolution routine
+ *
+ * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.
+ */
+typedef xmlParserInputPtr (*resolveEntitySAXFunc) (void *ctx,
+				const xmlChar *publicId,
+				const xmlChar *systemId);
+/**
+ * internalSubsetSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  the root element name
+ * @ExternalID:  the external ID
+ * @SystemID:  the SYSTEM ID (e.g. filename or URL)
+ *
+ * Callback on internal subset declaration.
+ */
+typedef void (*internalSubsetSAXFunc) (void *ctx,
+				const xmlChar *name,
+				const xmlChar *ExternalID,
+				const xmlChar *SystemID);
+/**
+ * externalSubsetSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  the root element name
+ * @ExternalID:  the external ID
+ * @SystemID:  the SYSTEM ID (e.g. filename or URL)
+ *
+ * Callback on external subset declaration.
+ */
+typedef void (*externalSubsetSAXFunc) (void *ctx,
+				const xmlChar *name,
+				const xmlChar *ExternalID,
+				const xmlChar *SystemID);
+/**
+ * getEntitySAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name: The entity name
+ *
+ * Get an entity by name.
+ *
+ * Returns the xmlEntityPtr if found.
+ */
+typedef xmlEntityPtr (*getEntitySAXFunc) (void *ctx,
+				const xmlChar *name);
+/**
+ * getParameterEntitySAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name: The entity name
+ *
+ * Get a parameter entity by name.
+ *
+ * Returns the xmlEntityPtr if found.
+ */
+typedef xmlEntityPtr (*getParameterEntitySAXFunc) (void *ctx,
+				const xmlChar *name);
+/**
+ * entityDeclSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  the entity name 
+ * @type:  the entity type 
+ * @publicId: The public ID of the entity
+ * @systemId: The system ID of the entity
+ * @content: the entity value (without processing).
+ *
+ * An entity definition has been parsed.
+ */
+typedef void (*entityDeclSAXFunc) (void *ctx,
+				const xmlChar *name,
+				int type,
+				const xmlChar *publicId,
+				const xmlChar *systemId,
+				xmlChar *content);
+/**
+ * notationDeclSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name: The name of the notation
+ * @publicId: The public ID of the entity
+ * @systemId: The system ID of the entity
+ *
+ * What to do when a notation declaration has been parsed.
+ */
+typedef void (*notationDeclSAXFunc)(void *ctx,
+				const xmlChar *name,
+				const xmlChar *publicId,
+				const xmlChar *systemId);
+/**
+ * attributeDeclSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @elem:  the name of the element
+ * @fullname:  the attribute name 
+ * @type:  the attribute type 
+ * @def:  the type of default value
+ * @defaultValue: the attribute default value
+ * @tree:  the tree of enumerated value set
+ *
+ * An attribute definition has been parsed.
+ */
+typedef void (*attributeDeclSAXFunc)(void *ctx,
+				const xmlChar *elem,
+				const xmlChar *fullname,
+				int type,
+				int def,
+				const xmlChar *defaultValue,
+				xmlEnumerationPtr tree);
+/**
+ * elementDeclSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  the element name 
+ * @type:  the element type 
+ * @content: the element value tree
+ *
+ * An element definition has been parsed.
+ */
+typedef void (*elementDeclSAXFunc)(void *ctx,
+				const xmlChar *name,
+				int type,
+				xmlElementContentPtr content);
+/**
+ * unparsedEntityDeclSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name: The name of the entity
+ * @publicId: The public ID of the entity
+ * @systemId: The system ID of the entity
+ * @notationName: the name of the notation
+ *
+ * What to do when an unparsed entity declaration is parsed.
+ */
+typedef void (*unparsedEntityDeclSAXFunc)(void *ctx,
+				const xmlChar *name,
+				const xmlChar *publicId,
+				const xmlChar *systemId,
+				const xmlChar *notationName);
+/**
+ * setDocumentLocatorSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @loc: A SAX Locator
+ *
+ * Receive the document locator at startup, actually xmlDefaultSAXLocator.
+ * Everything is available on the context, so this is useless in our case.
+ */
+typedef void (*setDocumentLocatorSAXFunc) (void *ctx,
+				xmlSAXLocatorPtr loc);
+/**
+ * startDocumentSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ *
+ * Called when the document start being processed.
+ */
+typedef void (*startDocumentSAXFunc) (void *ctx);
+/**
+ * endDocumentSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ *
+ * Called when the document end has been detected.
+ */
+typedef void (*endDocumentSAXFunc) (void *ctx);
+/**
+ * startElementSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  The element name, including namespace prefix
+ * @atts:  An array of name/value attributes pairs, NULL terminated
+ *
+ * Called when an opening tag has been processed.
+ */
+typedef void (*startElementSAXFunc) (void *ctx,
+				const xmlChar *name,
+				const xmlChar **atts);
+/**
+ * endElementSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  The element name
+ *
+ * Called when the end of an element has been detected.
+ */
+typedef void (*endElementSAXFunc) (void *ctx,
+				const xmlChar *name);
+/**
+ * attributeSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  The attribute name, including namespace prefix
+ * @value:  The attribute value
+ *
+ * Handle an attribute that has been read by the parser.
+ * The default handling is to convert the attribute into an
+ * DOM subtree and past it in a new xmlAttr element added to
+ * the element.
+ */
+typedef void (*attributeSAXFunc) (void *ctx,
+				const xmlChar *name,
+				const xmlChar *value);
+/**
+ * referenceSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @name:  The entity name
+ *
+ * Called when an entity reference is detected. 
+ */
+typedef void (*referenceSAXFunc) (void *ctx,
+				const xmlChar *name);
+/**
+ * charactersSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @ch:  a xmlChar string
+ * @len: the number of xmlChar
+ *
+ * Receiving some chars from the parser.
+ */
+typedef void (*charactersSAXFunc) (void *ctx,
+				const xmlChar *ch,
+				int len);
+/**
+ * ignorableWhitespaceSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @ch:  a xmlChar string
+ * @len: the number of xmlChar
+ *
+ * Receiving some ignorable whitespaces from the parser.
+ * UNUSED: by default the DOM building will use characters.
+ */
+typedef void (*ignorableWhitespaceSAXFunc) (void *ctx,
+				const xmlChar *ch,
+				int len);
+/**
+ * processingInstructionSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @target:  the target name
+ * @data: the PI data's
+ *
+ * A processing instruction has been parsed.
+ */
+typedef void (*processingInstructionSAXFunc) (void *ctx,
+				const xmlChar *target,
+				const xmlChar *data);
+/**
+ * commentSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @value:  the comment content
+ *
+ * A comment has been parsed.
+ */
+typedef void (*commentSAXFunc) (void *ctx,
+				const xmlChar *value);
+/**
+ * cdataBlockSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ * @value:  The pcdata content
+ * @len:  the block length
+ *
+ * Called when a pcdata block has been parsed.
+ */
+typedef void (*cdataBlockSAXFunc) (
+	                        void *ctx,
+				const xmlChar *value,
+				int len);
+/**
+ * warningSAXFunc:
+ * @ctx:  an XML parser context
+ * @msg:  the message to display/transmit
+ * @...:  extra parameters for the message display
+ * 
+ * Display and format a warning messages, callback.
+ */
+typedef void (XMLCDECL *warningSAXFunc) (void *ctx,
+				const char *msg, ...);
+/**
+ * errorSAXFunc:
+ * @ctx:  an XML parser context
+ * @msg:  the message to display/transmit
+ * @...:  extra parameters for the message display
+ * 
+ * Display and format an error messages, callback.
+ */
+typedef void (XMLCDECL *errorSAXFunc) (void *ctx,
+				const char *msg, ...);
+/**
+ * fatalErrorSAXFunc:
+ * @ctx:  an XML parser context
+ * @msg:  the message to display/transmit
+ * @...:  extra parameters for the message display
+ * 
+ * Display and format fatal error messages, callback.
+ * Note: so far fatalError() SAX callbacks are not used, error()
+ *       get all the callbacks for errors.
+ */
+typedef void (XMLCDECL *fatalErrorSAXFunc) (void *ctx,
+				const char *msg, ...);
+/**
+ * isStandaloneSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ *
+ * Is this document tagged standalone?
+ *
+ * Returns 1 if true
+ */
+typedef int (*isStandaloneSAXFunc) (void *ctx);
+/**
+ * hasInternalSubsetSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ *
+ * Does this document has an internal subset.
+ *
+ * Returns 1 if true
+ */
+typedef int (*hasInternalSubsetSAXFunc) (void *ctx);
+
+/**
+ * hasExternalSubsetSAXFunc:
+ * @ctx:  the user data (XML parser context)
+ *
+ * Does this document has an external subset?
+ *
+ * Returns 1 if true
+ */
+typedef int (*hasExternalSubsetSAXFunc) (void *ctx);
+
+/************************************************************************
+ *									*
+ *			The SAX version 2 API extensions		*
+ *									*
+ ************************************************************************/
+/**
+ * XML_SAX2_MAGIC:
+ *
+ * Special constant found in SAX2 blocks initialized fields
+ */
+#define XML_SAX2_MAGIC 0xDEEDBEAF
+
+/**
+ * startElementNsSAX2Func:
+ * @ctx:  the user data (XML parser context)
+ * @localname:  the local name of the element
+ * @prefix:  the element namespace prefix if available
+ * @URI:  the element namespace name if available
+ * @nb_namespaces:  number of namespace definitions on that node
+ * @namespaces:  pointer to the array of prefix/URI pairs namespace definitions
+ * @nb_attributes:  the number of attributes on that node
+ * @nb_defaulted:  the number of defaulted attributes. The defaulted
+ *                  ones are at the end of the array
+ * @attributes:  pointer to the array of (localname/prefix/URI/value/end)
+ *               attribute values.
+ *
+ * SAX2 callback when an element start has been detected by the parser.
+ * It provides the namespace informations for the element, as well as
+ * the new namespace declarations on the element.
+ */
+
+typedef void (*startElementNsSAX2Func) (void *ctx,
+					const xmlChar *localname,
+					const xmlChar *prefix,
+					const xmlChar *URI,
+					int nb_namespaces,
+					const xmlChar **namespaces,
+					int nb_attributes,
+					int nb_defaulted,
+					const xmlChar **attributes);
+ 
+/**
+ * endElementNsSAX2Func:
+ * @ctx:  the user data (XML parser context)
+ * @localname:  the local name of the element
+ * @prefix:  the element namespace prefix if available
+ * @URI:  the element namespace name if available
+ *
+ * SAX2 callback when an element end has been detected by the parser.
+ * It provides the namespace informations for the element.
+ */
+
+typedef void (*endElementNsSAX2Func)   (void *ctx,
+					const xmlChar *localname,
+					const xmlChar *prefix,
+					const xmlChar *URI);
+
+
+struct _xmlSAXHandler {
+    internalSubsetSAXFunc internalSubset;
+    isStandaloneSAXFunc isStandalone;
+    hasInternalSubsetSAXFunc hasInternalSubset;
+    hasExternalSubsetSAXFunc hasExternalSubset;
+    resolveEntitySAXFunc resolveEntity;
+    getEntitySAXFunc getEntity;
+    entityDeclSAXFunc entityDecl;
+    notationDeclSAXFunc notationDecl;
+    attributeDeclSAXFunc attributeDecl;
+    elementDeclSAXFunc elementDecl;
+    unparsedEntityDeclSAXFunc unparsedEntityDecl;
+    setDocumentLocatorSAXFunc setDocumentLocator;
+    startDocumentSAXFunc startDocument;
+    endDocumentSAXFunc endDocument;
+    startElementSAXFunc startElement;
+    endElementSAXFunc endElement;
+    referenceSAXFunc reference;
+    charactersSAXFunc characters;
+    ignorableWhitespaceSAXFunc ignorableWhitespace;
+    processingInstructionSAXFunc processingInstruction;
+    commentSAXFunc comment;
+    warningSAXFunc warning;
+    errorSAXFunc error;
+    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */
+    getParameterEntitySAXFunc getParameterEntity;
+    cdataBlockSAXFunc cdataBlock;
+    externalSubsetSAXFunc externalSubset;
+    unsigned int initialized;
+    /* The following fields are extensions available only on version 2 */
+    void *_private;
+    startElementNsSAX2Func startElementNs;
+    endElementNsSAX2Func endElementNs;
+    xmlStructuredErrorFunc serror;
+};
+
+/*
+ * SAX Version 1
+ */
+typedef struct _xmlSAXHandlerV1 xmlSAXHandlerV1;
+typedef xmlSAXHandlerV1 *xmlSAXHandlerV1Ptr;
+struct _xmlSAXHandlerV1 {
+    internalSubsetSAXFunc internalSubset;
+    isStandaloneSAXFunc isStandalone;
+    hasInternalSubsetSAXFunc hasInternalSubset;
+    hasExternalSubsetSAXFunc hasExternalSubset;
+    resolveEntitySAXFunc resolveEntity;
+    getEntitySAXFunc getEntity;
+    entityDeclSAXFunc entityDecl;
+    notationDeclSAXFunc notationDecl;
+    attributeDeclSAXFunc attributeDecl;
+    elementDeclSAXFunc elementDecl;
+    unparsedEntityDeclSAXFunc unparsedEntityDecl;
+    setDocumentLocatorSAXFunc setDocumentLocator;
+    startDocumentSAXFunc startDocument;
+    endDocumentSAXFunc endDocument;
+    startElementSAXFunc startElement;
+    endElementSAXFunc endElement;
+    referenceSAXFunc reference;
+    charactersSAXFunc characters;
+    ignorableWhitespaceSAXFunc ignorableWhitespace;
+    processingInstructionSAXFunc processingInstruction;
+    commentSAXFunc comment;
+    warningSAXFunc warning;
+    errorSAXFunc error;
+    fatalErrorSAXFunc fatalError; /* unused error() get all the errors */
+    getParameterEntitySAXFunc getParameterEntity;
+    cdataBlockSAXFunc cdataBlock;
+    externalSubsetSAXFunc externalSubset;
+    unsigned int initialized;
+};
+
+
+/**
+ * xmlExternalEntityLoader:
+ * @URL: The System ID of the resource requested
+ * @ID: The Public ID of the resource requested
+ * @context: the XML parser context 
+ *
+ * External entity loaders types.
+ *
+ * Returns the entity input parser.
+ */
+typedef xmlParserInputPtr (*xmlExternalEntityLoader) (const char *URL,
+					 const char *ID,
+					 xmlParserCtxtPtr context);
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <libxml/encoding.h>
+#include <libxml/xmlIO.h>
+#include <libxml/globals.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/*
+ * Init/Cleanup
+ */
+XMLPUBFUN void XMLCALL		
+		xmlInitParser		(void);
+XMLPUBFUN void XMLCALL		
+		xmlCleanupParser	(void);
+
+/*
+ * Input functions
+ */
+XMLPUBFUN int XMLCALL		
+		xmlParserInputRead	(xmlParserInputPtr in,
+					 int len);
+XMLPUBFUN int XMLCALL		
+		xmlParserInputGrow	(xmlParserInputPtr in,
+					 int len);
+
+/*
+ * Basic parsing Interfaces
+ */
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlParseDoc		(const xmlChar *cur);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlParseFile		(const char *filename);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlParseMemory		(const char *buffer,
+					 int size);
+#endif /* LIBXML_SAX1_ENABLED */
+XMLPUBFUN int XMLCALL		
+		xmlSubstituteEntitiesDefault(int val);
+XMLPUBFUN int XMLCALL		
+		xmlKeepBlanksDefault	(int val);
+XMLPUBFUN void XMLCALL		
+		xmlStopParser		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL		
+		xmlPedanticParserDefault(int val);
+XMLPUBFUN int XMLCALL		
+		xmlLineNumbersDefault	(int val);
+
+#ifdef LIBXML_SAX1_ENABLED
+/*
+ * Recovery mode 
+ */
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlRecoverDoc		(xmlChar *cur);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlRecoverMemory	(const char *buffer,
+					 int size);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlRecoverFile		(const char *filename);
+#endif /* LIBXML_SAX1_ENABLED */
+
+/*
+ * Less common routines and SAX interfaces
+ */
+XMLPUBFUN int XMLCALL		
+		xmlParseDocument	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL		
+		xmlParseExtParsedEnt	(xmlParserCtxtPtr ctxt);
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN int XMLCALL		
+		xmlSAXUserParseFile	(xmlSAXHandlerPtr sax,
+					 void *user_data,
+					 const char *filename);
+XMLPUBFUN int XMLCALL		
+		xmlSAXUserParseMemory	(xmlSAXHandlerPtr sax,
+					 void *user_data,
+					 const char *buffer,
+					 int size);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlSAXParseDoc		(xmlSAXHandlerPtr sax,
+					 const xmlChar *cur,
+					 int recovery);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlSAXParseMemory	(xmlSAXHandlerPtr sax,
+					 const char *buffer,
+                                   	 int size,
+					 int recovery);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,
+					 const char *buffer,
+                                   	 int size,
+					 int recovery,
+					 void *data);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlSAXParseFile		(xmlSAXHandlerPtr sax,
+					 const char *filename,
+					 int recovery);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlSAXParseFileWithData	(xmlSAXHandlerPtr sax,
+					 const char *filename,
+					 int recovery,
+					 void *data);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlSAXParseEntity	(xmlSAXHandlerPtr sax,
+					 const char *filename);
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlParseEntity		(const char *filename);
+#endif /* LIBXML_SAX1_ENABLED */
+
+#ifdef LIBXML_VALID_ENABLED
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlSAXParseDTD		(xmlSAXHandlerPtr sax,
+					 const xmlChar *ExternalID,
+					 const xmlChar *SystemID);
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlParseDTD		(const xmlChar *ExternalID,
+					 const xmlChar *SystemID);
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlIOParseDTD		(xmlSAXHandlerPtr sax,
+					 xmlParserInputBufferPtr input,
+					 xmlCharEncoding enc);
+#endif /* LIBXML_VALID_ENABLE */
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN int XMLCALL	
+		xmlParseBalancedChunkMemory(xmlDocPtr doc,
+					 xmlSAXHandlerPtr sax,
+					 void *user_data,
+					 int depth,
+					 const xmlChar *string,
+					 xmlNodePtr *lst);
+#endif /* LIBXML_SAX1_ENABLED */
+XMLPUBFUN xmlParserErrors XMLCALL
+		xmlParseInNodeContext	(xmlNodePtr node,
+					 const char *data,
+					 int datalen,
+					 int options,
+					 xmlNodePtr *lst);
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN int XMLCALL          
+		xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,
+                     xmlSAXHandlerPtr sax,
+                     void *user_data,
+                     int depth,
+                     const xmlChar *string,
+                     xmlNodePtr *lst,
+                     int recover);
+XMLPUBFUN int XMLCALL		
+		xmlParseExternalEntity	(xmlDocPtr doc,
+					 xmlSAXHandlerPtr sax,
+					 void *user_data,
+					 int depth,
+					 const xmlChar *URL,
+					 const xmlChar *ID,
+					 xmlNodePtr *lst);
+#endif /* LIBXML_SAX1_ENABLED */
+XMLPUBFUN int XMLCALL		
+		xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,
+					 const xmlChar *URL,
+					 const xmlChar *ID,
+					 xmlNodePtr *lst);
+
+/*
+ * Parser contexts handling.
+ */
+XMLPUBFUN xmlParserCtxtPtr XMLCALL	
+		xmlNewParserCtxt	(void);
+XMLPUBFUN int XMLCALL		
+		xmlInitParserCtxt	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL		
+		xmlClearParserCtxt	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL		
+		xmlFreeParserCtxt	(xmlParserCtxtPtr ctxt);
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlSetupParserForBuffer	(xmlParserCtxtPtr ctxt,
+					 const xmlChar* buffer,
+					 const char *filename);
+#endif /* LIBXML_SAX1_ENABLED */
+XMLPUBFUN xmlParserCtxtPtr XMLCALL 
+		xmlCreateDocParserCtxt	(const xmlChar *cur);
+
+#ifdef LIBXML_LEGACY_ENABLED
+/*
+ * Reading/setting optional parsing features.
+ */
+XMLPUBFUN int XMLCALL		
+		xmlGetFeaturesList	(int *len,
+					 const char **result);
+XMLPUBFUN int XMLCALL		
+		xmlGetFeature		(xmlParserCtxtPtr ctxt,
+					 const char *name,
+					 void *result);
+XMLPUBFUN int XMLCALL		
+		xmlSetFeature		(xmlParserCtxtPtr ctxt,
+					 const char *name,
+					 void *value);
+#endif /* LIBXML_LEGACY_ENABLED */
+
+#ifdef LIBXML_PUSH_ENABLED
+/*
+ * Interfaces for the Push mode.
+ */
+XMLPUBFUN xmlParserCtxtPtr XMLCALL 
+		xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,
+					 void *user_data,
+					 const char *chunk,
+					 int size,
+					 const char *filename);
+XMLPUBFUN int XMLCALL		 
+		xmlParseChunk		(xmlParserCtxtPtr ctxt,
+					 const char *chunk,
+					 int size,
+					 int terminate);
+#endif /* LIBXML_PUSH_ENABLED */
+
+/*
+ * Special I/O mode.
+ */
+
+XMLPUBFUN xmlParserCtxtPtr XMLCALL 
+		xmlCreateIOParserCtxt	(xmlSAXHandlerPtr sax,
+					 void *user_data,
+					 xmlInputReadCallback   ioread,
+					 xmlInputCloseCallback  ioclose,
+					 void *ioctx,
+					 xmlCharEncoding enc);
+
+XMLPUBFUN xmlParserInputPtr XMLCALL 
+		xmlNewIOInputStream	(xmlParserCtxtPtr ctxt,
+					 xmlParserInputBufferPtr input,
+					 xmlCharEncoding enc);
+
+/*
+ * Node infos.
+ */
+XMLPUBFUN const xmlParserNodeInfo* XMLCALL
+		xmlParserFindNodeInfo	(const xmlParserCtxtPtr ctxt,
+				         const xmlNodePtr node);
+XMLPUBFUN void XMLCALL		
+		xmlInitNodeInfoSeq	(xmlParserNodeInfoSeqPtr seq);
+XMLPUBFUN void XMLCALL		
+		xmlClearNodeInfoSeq	(xmlParserNodeInfoSeqPtr seq);
+XMLPUBFUN unsigned long XMLCALL 
+		xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,
+                                         const xmlNodePtr node);
+XMLPUBFUN void XMLCALL		
+		xmlParserAddNodeInfo	(xmlParserCtxtPtr ctxt,
+					 const xmlParserNodeInfoPtr info);
+
+/*
+ * External entities handling actually implemented in xmlIO.
+ */
+
+XMLPUBFUN void XMLCALL		
+		xmlSetExternalEntityLoader(xmlExternalEntityLoader f);
+XMLPUBFUN xmlExternalEntityLoader XMLCALL
+		xmlGetExternalEntityLoader(void);
+XMLPUBFUN xmlParserInputPtr XMLCALL
+		xmlLoadExternalEntity	(const char *URL,
+					 const char *ID,
+					 xmlParserCtxtPtr ctxt);
+
+/*
+ * Index lookup, actually implemented in the encoding module
+ */
+XMLPUBFUN long XMLCALL
+		xmlByteConsumed		(xmlParserCtxtPtr ctxt);
+
+/*
+ * New set of simpler/more flexible APIs
+ */
+/**
+ * xmlParserOption:
+ *
+ * This is the set of XML parser options that can be passed down
+ * to the xmlReadDoc() and similar calls.
+ */
+typedef enum {
+    XML_PARSE_RECOVER	= 1<<0,	/* recover on errors */
+    XML_PARSE_NOENT	= 1<<1,	/* substitute entities */
+    XML_PARSE_DTDLOAD	= 1<<2,	/* load the external subset */
+    XML_PARSE_DTDATTR	= 1<<3,	/* default DTD attributes */
+    XML_PARSE_DTDVALID	= 1<<4,	/* validate with the DTD */
+    XML_PARSE_NOERROR	= 1<<5,	/* suppress error reports */
+    XML_PARSE_NOWARNING	= 1<<6,	/* suppress warning reports */
+    XML_PARSE_PEDANTIC	= 1<<7,	/* pedantic error reporting */
+    XML_PARSE_NOBLANKS	= 1<<8,	/* remove blank nodes */
+    XML_PARSE_SAX1	= 1<<9,	/* use the SAX1 interface internally */
+    XML_PARSE_XINCLUDE	= 1<<10,/* Implement XInclude substitition  */
+    XML_PARSE_NONET	= 1<<11,/* Forbid network access */
+    XML_PARSE_NODICT	= 1<<12,/* Do not reuse the context dictionnary */
+    XML_PARSE_NSCLEAN	= 1<<13,/* remove redundant namespaces declarations */
+    XML_PARSE_NOCDATA	= 1<<14,/* merge CDATA as text nodes */
+    XML_PARSE_NOXINCNODE= 1<<15,/* do not generate XINCLUDE START/END nodes */
+    XML_PARSE_COMPACT   = 1<<16 /* compact small text nodes; no modification of
+                                   the tree allowed afterwards (will possibly
+				   crash if you try to modify the tree) */
+} xmlParserOption;
+
+XMLPUBFUN void XMLCALL
+		xmlCtxtReset		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+		xmlCtxtResetPush	(xmlParserCtxtPtr ctxt,
+					 const char *chunk,
+					 int size,
+					 const char *filename,
+					 const char *encoding);
+XMLPUBFUN int XMLCALL
+		xmlCtxtUseOptions	(xmlParserCtxtPtr ctxt,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlReadDoc		(const xmlChar *cur,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlReadFile		(const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlReadMemory		(const char *buffer,
+					 int size,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlReadFd		(int fd,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlReadIO		(xmlInputReadCallback ioread,
+					 xmlInputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlCtxtReadDoc		(xmlParserCtxtPtr ctxt,
+					 const xmlChar *cur,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlCtxtReadFile		(xmlParserCtxtPtr ctxt,
+					 const char *filename,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlCtxtReadMemory		(xmlParserCtxtPtr ctxt,
+					 const char *buffer,
+					 int size,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlCtxtReadFd		(xmlParserCtxtPtr ctxt,
+					 int fd,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlDocPtr XMLCALL
+		xmlCtxtReadIO		(xmlParserCtxtPtr ctxt,
+					 xmlInputReadCallback ioread,
+					 xmlInputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+
+/*
+ * Library wide options
+ */
+/**
+ * xmlFeature:
+ *
+ * Used to examine the existance of features that can be enabled
+ * or disabled at compile-time.
+ * They used to be called XML_FEATURE_xxx but this clashed with Expat
+ */
+typedef enum {
+    XML_WITH_THREAD = 1,
+    XML_WITH_TREE = 2,
+    XML_WITH_OUTPUT = 3,
+    XML_WITH_PUSH = 4,
+    XML_WITH_READER = 5,
+    XML_WITH_PATTERN = 6,
+    XML_WITH_WRITER = 7,
+    XML_WITH_SAX1 = 8,
+    XML_WITH_FTP = 9,
+    XML_WITH_HTTP = 10,
+    XML_WITH_VALID = 11,
+    XML_WITH_HTML = 12,
+    XML_WITH_LEGACY = 13,
+    XML_WITH_C14N = 14,
+    XML_WITH_CATALOG = 15,
+    XML_WITH_XPATH = 16,
+    XML_WITH_XPTR = 17,
+    XML_WITH_XINCLUDE = 18,
+    XML_WITH_ICONV = 19,
+    XML_WITH_ISO8859X = 20,
+    XML_WITH_UNICODE = 21,
+    XML_WITH_REGEXP = 22,
+    XML_WITH_AUTOMATA = 23,
+    XML_WITH_EXPR = 24,
+    XML_WITH_SCHEMAS = 25,
+    XML_WITH_SCHEMATRON = 26,
+    XML_WITH_MODULES = 27,
+    XML_WITH_DEBUG = 28,
+    XML_WITH_DEBUG_MEM = 29,
+    XML_WITH_DEBUG_RUN = 30,
+    XML_WITH_ZLIB = 31,
+    XML_WITH_NONE = 99999 /* just to be sure of allocation size */
+} xmlFeature;
+
+XMLPUBFUN int XMLCALL
+		xmlHasFeature		(xmlFeature feature);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_PARSER_H__ */
+
diff -Naur orig.ns-2.33/libxml/parserInternals.h ns-2.33/libxml/parserInternals.h
--- orig.ns-2.33/libxml/parserInternals.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/parserInternals.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,602 @@
+/*
+ * Summary: internals routines exported by the parser.
+ * Description: this module exports a number of internal parsing routines
+ *              they are not really all intended for applications but
+ *              can prove useful doing low level processing.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_PARSER_INTERNALS_H__
+#define __XML_PARSER_INTERNALS_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/parser.h>
+#include <libxml/HTMLparser.h>
+#include <libxml/chvalid.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlParserMaxDepth:
+ *
+ * arbitrary depth limit for the XML documents that we allow to 
+ * process. This is not a limitation of the parser but a safety 
+ * boundary feature.
+ */
+XMLPUBVAR unsigned int xmlParserMaxDepth;
+
+ /**
+  * XML_MAX_NAMELEN:
+  *
+  * Identifiers can be longer, but this will be more costly
+  * at runtime.
+  */
+#define XML_MAX_NAMELEN 100
+
+/**
+ * INPUT_CHUNK:
+ *
+ * The parser tries to always have that amount of input ready.
+ * One of the point is providing context when reporting errors.
+ */
+#define INPUT_CHUNK	250
+
+/************************************************************************
+ *									*
+ * UNICODE version of the macros.      					*
+ *									*
+ ************************************************************************/
+/**
+ * IS_BYTE_CHAR:
+ * @c:  an byte value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ * [2] Char ::= #x9 | #xA | #xD | [#x20...]
+ * any byte character in the accepted range
+ */
+#define IS_BYTE_CHAR(c)	 xmlIsChar_ch(c)
+
+/**
+ * IS_CHAR:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ * [2] Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD]
+ *                  | [#x10000-#x10FFFF]
+ * any Unicode character, excluding the surrogate blocks, FFFE, and FFFF.
+ */
+#define IS_CHAR(c)   xmlIsCharQ(c)
+
+/**
+ * IS_CHAR_CH:
+ * @c: an xmlChar (usually an unsigned char)
+ *
+ * Behaves like IS_CHAR on single-byte value
+ */
+#define IS_CHAR_CH(c)  xmlIsChar_ch(c)
+
+/**
+ * IS_BLANK:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ * [3] S ::= (#x20 | #x9 | #xD | #xA)+
+ */
+#define IS_BLANK(c)  xmlIsBlankQ(c)
+
+/**
+ * IS_BLANK_CH:
+ * @c:  an xmlChar value (normally unsigned char)
+ *
+ * Behaviour same as IS_BLANK
+ */
+#define IS_BLANK_CH(c)  xmlIsBlank_ch(c)
+
+/**
+ * IS_BASECHAR:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ * [85] BaseChar ::= ... long list see REC ...
+ */
+#define IS_BASECHAR(c) xmlIsBaseCharQ(c)
+
+/**
+ * IS_DIGIT:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ * [88] Digit ::= ... long list see REC ...
+ */
+#define IS_DIGIT(c) xmlIsDigitQ(c)
+
+/**
+ * IS_DIGIT_CH:
+ * @c:  an xmlChar value (usually an unsigned char)
+ *
+ * Behaves like IS_DIGIT but with a single byte argument
+ */
+#define IS_DIGIT_CH(c)  xmlIsDigit_ch(c)
+
+/**
+ * IS_COMBINING:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ * [87] CombiningChar ::= ... long list see REC ...
+ */
+#define IS_COMBINING(c) xmlIsCombiningQ(c)
+
+/**
+ * IS_COMBINING_CH:
+ * @c:  an xmlChar (usually an unsigned char)
+ *
+ * Always false (all combining chars > 0xff)
+ */
+#define IS_COMBINING_CH(c) 0 
+
+/**
+ * IS_EXTENDER:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ *
+ * [89] Extender ::= #x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 |
+ *                   #x0E46 | #x0EC6 | #x3005 | [#x3031-#x3035] |
+ *                   [#x309D-#x309E] | [#x30FC-#x30FE]
+ */
+#define IS_EXTENDER(c) xmlIsExtenderQ(c)
+
+/**
+ * IS_EXTENDER_CH:
+ * @c:  an xmlChar value (usually an unsigned char)
+ *
+ * Behaves like IS_EXTENDER but with a single-byte argument
+ */
+#define IS_EXTENDER_CH(c)  xmlIsExtender_ch(c)
+
+/**
+ * IS_IDEOGRAPHIC:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ *
+ * [86] Ideographic ::= [#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]
+ */
+#define IS_IDEOGRAPHIC(c) xmlIsIdeographicQ(c)
+
+/**
+ * IS_LETTER:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ *
+ * [84] Letter ::= BaseChar | Ideographic 
+ */
+#define IS_LETTER(c) (IS_BASECHAR(c) || IS_IDEOGRAPHIC(c))
+
+/**
+ * IS_LETTER_CH:
+ * @c:  an xmlChar value (normally unsigned char)
+ *
+ * Macro behaves like IS_LETTER, but only check base chars
+ *
+ */
+#define IS_LETTER_CH(c) xmlIsBaseChar_ch(c)
+
+/**
+ * IS_ASCII_LETTER:
+ * @c: an xmlChar value
+ *
+ * Macro to check [a-zA-Z]
+ *
+ */
+#define IS_ASCII_LETTER(c)	(((0x41 <= (c)) && ((c) <= 0x5a)) || \
+				 ((0x61 <= (c)) && ((c) <= 0x7a)))
+
+/**
+ * IS_ASCII_DIGIT:
+ * @c: an xmlChar value
+ *
+ * Macro to check [0-9]
+ *
+ */
+#define IS_ASCII_DIGIT(c)	((0x30 <= (c)) && ((c) <= 0x39))
+
+/**
+ * IS_PUBIDCHAR:
+ * @c:  an UNICODE value (int)
+ *
+ * Macro to check the following production in the XML spec:
+ *
+ *
+ * [13] PubidChar ::= #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]
+ */
+#define IS_PUBIDCHAR(c)	xmlIsPubidCharQ(c)
+
+/**
+ * IS_PUBIDCHAR_CH:
+ * @c:  an xmlChar value (normally unsigned char)
+ *
+ * Same as IS_PUBIDCHAR but for single-byte value
+ */
+#define IS_PUBIDCHAR_CH(c) xmlIsPubidChar_ch(c)
+
+/**
+ * SKIP_EOL:
+ * @p:  and UTF8 string pointer
+ *
+ * Skips the end of line chars.
+ */
+#define SKIP_EOL(p) 							\
+    if (*(p) == 0x13) { p++ ; if (*(p) == 0x10) p++; }			\
+    if (*(p) == 0x10) { p++ ; if (*(p) == 0x13) p++; }
+
+/**
+ * MOVETO_ENDTAG:
+ * @p:  and UTF8 string pointer
+ *
+ * Skips to the next '>' char.
+ */
+#define MOVETO_ENDTAG(p)						\
+    while ((*p) && (*(p) != '>')) (p)++
+
+/**
+ * MOVETO_STARTTAG:
+ * @p:  and UTF8 string pointer
+ *
+ * Skips to the next '<' char.
+ */
+#define MOVETO_STARTTAG(p)						\
+    while ((*p) && (*(p) != '<')) (p)++
+
+/**
+ * Global variables used for predefined strings.
+ */
+XMLPUBVAR const xmlChar xmlStringText[];
+XMLPUBVAR const xmlChar xmlStringTextNoenc[];
+XMLPUBVAR const xmlChar xmlStringComment[];
+
+/*
+ * Function to finish the work of the macros where needed.
+ */
+XMLPUBFUN int XMLCALL                   xmlIsLetter     (int c);
+
+/**
+ * Parser context.
+ */
+XMLPUBFUN xmlParserCtxtPtr XMLCALL	
+			xmlCreateFileParserCtxt	(const char *filename);
+XMLPUBFUN xmlParserCtxtPtr XMLCALL	
+			xmlCreateURLParserCtxt	(const char *filename,
+						 int options);
+XMLPUBFUN xmlParserCtxtPtr XMLCALL	
+			xmlCreateMemoryParserCtxt(const char *buffer,
+						 int size);
+XMLPUBFUN xmlParserCtxtPtr XMLCALL	
+			xmlCreateEntityParserCtxt(const xmlChar *URL,
+						 const xmlChar *ID,
+						 const xmlChar *base);
+XMLPUBFUN int XMLCALL			
+			xmlSwitchEncoding	(xmlParserCtxtPtr ctxt,
+						 xmlCharEncoding enc);
+XMLPUBFUN int XMLCALL			
+			xmlSwitchToEncoding	(xmlParserCtxtPtr ctxt,
+					 xmlCharEncodingHandlerPtr handler);
+XMLPUBFUN int XMLCALL			
+			xmlSwitchInputEncoding	(xmlParserCtxtPtr ctxt,
+						 xmlParserInputPtr input,
+					 xmlCharEncodingHandlerPtr handler);
+
+#ifdef IN_LIBXML
+/* internal error reporting */
+XMLPUBFUN void XMLCALL
+			__xmlErrEncoding	(xmlParserCtxtPtr ctxt,
+						 xmlParserErrors xmlerr,
+						 const char *msg,
+						 const xmlChar * str1,
+						 const xmlChar * str2);
+#endif
+
+/**
+ * Input Streams.
+ */
+XMLPUBFUN xmlParserInputPtr XMLCALL	
+			xmlNewStringInputStream	(xmlParserCtxtPtr ctxt,
+						 const xmlChar *buffer);
+XMLPUBFUN xmlParserInputPtr XMLCALL	
+			xmlNewEntityInputStream	(xmlParserCtxtPtr ctxt,
+						 xmlEntityPtr entity);
+XMLPUBFUN void XMLCALL			
+			xmlPushInput		(xmlParserCtxtPtr ctxt,
+						 xmlParserInputPtr input);
+XMLPUBFUN xmlChar XMLCALL			
+			xmlPopInput		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlFreeInputStream	(xmlParserInputPtr input);
+XMLPUBFUN xmlParserInputPtr XMLCALL	
+			xmlNewInputFromFile	(xmlParserCtxtPtr ctxt,
+						 const char *filename);
+XMLPUBFUN xmlParserInputPtr XMLCALL	
+			xmlNewInputStream	(xmlParserCtxtPtr ctxt);
+
+/**
+ * Namespaces.
+ */
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlSplitQName		(xmlParserCtxtPtr ctxt,
+						 const xmlChar *name,
+						 xmlChar **prefix);
+
+/**
+ * Generic production rules.
+ */
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlParseName		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseNmtoken		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseEntityValue	(xmlParserCtxtPtr ctxt,
+						 xmlChar **orig);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseAttValue	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseSystemLiteral	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParsePubidLiteral	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseCharData	(xmlParserCtxtPtr ctxt,
+						 int cdata);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseExternalID	(xmlParserCtxtPtr ctxt,
+						 xmlChar **publicID,
+						 int strict);
+XMLPUBFUN void XMLCALL			
+			xmlParseComment		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlParsePITarget	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParsePI		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseNotationDecl	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseEntityDecl	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+			xmlParseDefaultDecl	(xmlParserCtxtPtr ctxt,
+						 xmlChar **value);
+XMLPUBFUN xmlEnumerationPtr XMLCALL	
+			xmlParseNotationType	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlEnumerationPtr XMLCALL	
+			xmlParseEnumerationType	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+			xmlParseEnumeratedType	(xmlParserCtxtPtr ctxt,
+						 xmlEnumerationPtr *tree);
+XMLPUBFUN int XMLCALL			
+			xmlParseAttributeType	(xmlParserCtxtPtr ctxt,
+						 xmlEnumerationPtr *tree);
+XMLPUBFUN void XMLCALL			
+			xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlElementContentPtr XMLCALL	
+			xmlParseElementMixedContentDecl
+						(xmlParserCtxtPtr ctxt,
+						 int inputchk);
+XMLPUBFUN xmlElementContentPtr XMLCALL	
+			xmlParseElementChildrenContentDecl
+						(xmlParserCtxtPtr ctxt,
+						 int inputchk);
+XMLPUBFUN int XMLCALL			
+			xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,
+						 const xmlChar *name,
+						 xmlElementContentPtr *result);
+XMLPUBFUN int XMLCALL			
+			xmlParseElementDecl	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseMarkupDecl	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+			xmlParseCharRef		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlEntityPtr XMLCALL		
+			xmlParseEntityRef	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseReference	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParsePEReference	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseDocTypeDecl	(xmlParserCtxtPtr ctxt);
+#ifdef LIBXML_SAX1_ENABLED
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlParseAttribute	(xmlParserCtxtPtr ctxt,
+						 xmlChar **value);
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlParseStartTag	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseEndTag		(xmlParserCtxtPtr ctxt);
+#endif /* LIBXML_SAX1_ENABLED */
+XMLPUBFUN void XMLCALL			
+			xmlParseCDSect		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseContent		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseElement		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseVersionNum	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseVersionInfo	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseEncName		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN const xmlChar * XMLCALL		
+			xmlParseEncodingDecl	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+			xmlParseSDDecl		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseXMLDecl		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseTextDecl	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseMisc		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+			xmlParseExternalSubset	(xmlParserCtxtPtr ctxt,
+						 const xmlChar *ExternalID,
+						 const xmlChar *SystemID); 
+/**
+ * XML_SUBSTITUTE_NONE:
+ *
+ * If no entities need to be substituted.
+ */
+#define XML_SUBSTITUTE_NONE	0
+/**
+ * XML_SUBSTITUTE_REF:
+ *
+ * Whether general entities need to be substituted.
+ */
+#define XML_SUBSTITUTE_REF	1
+/**
+ * XML_SUBSTITUTE_PEREF:
+ *
+ * Whether parameter entities need to be substituted.
+ */
+#define XML_SUBSTITUTE_PEREF	2
+/**
+ * XML_SUBSTITUTE_BOTH:
+ *
+ * Both general and parameter entities need to be substituted.
+ */
+#define XML_SUBSTITUTE_BOTH 	3
+
+XMLPUBFUN xmlChar * XMLCALL
+		xmlStringDecodeEntities		(xmlParserCtxtPtr ctxt,
+						 const xmlChar *str,
+						 int what,
+						 xmlChar end,
+						 xmlChar  end2,
+						 xmlChar end3);
+XMLPUBFUN xmlChar * XMLCALL
+		xmlStringLenDecodeEntities	(xmlParserCtxtPtr ctxt,
+						 const xmlChar *str,
+						 int len,
+						 int what,
+						 xmlChar end,
+						 xmlChar  end2,
+						 xmlChar end3);
+
+/*
+ * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.
+ */
+XMLPUBFUN int XMLCALL			nodePush		(xmlParserCtxtPtr ctxt,
+						 xmlNodePtr value);
+XMLPUBFUN xmlNodePtr XMLCALL		nodePop			(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			inputPush		(xmlParserCtxtPtr ctxt,
+						 xmlParserInputPtr value);
+XMLPUBFUN xmlParserInputPtr XMLCALL	inputPop		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN const xmlChar * XMLCALL	namePop			(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			namePush		(xmlParserCtxtPtr ctxt,
+						 const xmlChar *value);
+
+/*
+ * other commodities shared between parser.c and parserInternals.
+ */
+XMLPUBFUN int XMLCALL			xmlSkipBlankChars	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			xmlStringCurrentChar	(xmlParserCtxtPtr ctxt,
+						 const xmlChar *cur,
+						 int *len);
+XMLPUBFUN void XMLCALL			xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			xmlCheckLanguageID	(const xmlChar *lang);
+
+/*
+ * Really core function shared with HTML parser.
+ */
+XMLPUBFUN int XMLCALL			xmlCurrentChar		(xmlParserCtxtPtr ctxt,
+						 int *len);
+XMLPUBFUN int XMLCALL		xmlCopyCharMultiByte	(xmlChar *out,
+						 int val);
+XMLPUBFUN int XMLCALL			xmlCopyChar		(int len,
+						 xmlChar *out,
+						 int val);
+XMLPUBFUN void XMLCALL			xmlNextChar		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			xmlParserInputShrink	(xmlParserInputPtr in);
+
+#ifdef LIBXML_HTML_ENABLED
+/*
+ * Actually comes from the HTML parser but launched from the init stuff.
+ */
+XMLPUBFUN void XMLCALL			htmlInitAutoClose	(void);
+XMLPUBFUN htmlParserCtxtPtr XMLCALL	htmlCreateFileParserCtxt(const char *filename,
+	                                         const char *encoding);
+#endif
+
+/*
+ * Specific function to keep track of entities references
+ * and used by the XSLT debugger.
+ */
+#ifdef LIBXML_LEGACY_ENABLED
+/**
+ * xmlEntityReferenceFunc:
+ * @ent: the entity
+ * @firstNode:  the fist node in the chunk
+ * @lastNode:  the last nod in the chunk
+ *
+ * Callback function used when one needs to be able to track back the
+ * provenance of a chunk of nodes inherited from an entity replacement.
+ */
+typedef	void	(*xmlEntityReferenceFunc)	(xmlEntityPtr ent,
+						 xmlNodePtr firstNode,
+						 xmlNodePtr lastNode);
+  
+XMLPUBFUN void XMLCALL		xmlSetEntityReferenceFunc	(xmlEntityReferenceFunc func);
+
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlParseQuotedString	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL
+                        xmlParseNamespace       (xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlNamespaceParseNSDef	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlScanName		(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlNamespaceParseNCName	(xmlParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL	xmlParserHandleReference(xmlParserCtxtPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL		
+			xmlNamespaceParseQName	(xmlParserCtxtPtr ctxt,
+						 xmlChar **prefix);
+/**
+ * Entities
+ */
+XMLPUBFUN xmlChar * XMLCALL
+		xmlDecodeEntities		(xmlParserCtxtPtr ctxt,
+						 int len,
+						 int what,
+						 xmlChar end,
+						 xmlChar  end2,
+						 xmlChar end3);
+XMLPUBFUN void XMLCALL			
+			xmlHandleEntity		(xmlParserCtxtPtr ctxt,
+						 xmlEntityPtr entity);
+
+#endif /* LIBXML_LEGACY_ENABLED */
+
+#ifdef IN_LIBXML
+/*
+ * internal only
+ */
+XMLPUBFUN void XMLCALL
+	xmlErrMemory		(xmlParserCtxtPtr ctxt,
+				 const char *extra);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_PARSER_INTERNALS_H__ */
diff -Naur orig.ns-2.33/libxml/pattern.h ns-2.33/libxml/pattern.h
--- orig.ns-2.33/libxml/pattern.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/pattern.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,100 @@
+/*
+ * Summary: pattern expression handling
+ * Description: allows to compile and test pattern expressions for nodes
+ *              either in a tree or based on a parser state.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_PATTERN_H__
+#define __XML_PATTERN_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+#include <libxml/dict.h>
+
+#ifdef LIBXML_PATTERN_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlPattern:
+ *
+ * A compiled (XPath based) pattern to select nodes
+ */
+typedef struct _xmlPattern xmlPattern;
+typedef xmlPattern *xmlPatternPtr;
+
+/**
+ * xmlPatternFlags:
+ *
+ * This is the set of options affecting the behaviour of pattern
+ * matching with this module
+ *
+ */
+typedef enum {
+    XML_PATTERN_DEFAULT		= 0,	/* simple pattern match */
+    XML_PATTERN_XPATH		= 1<<0,	/* standard XPath pattern */
+    XML_PATTERN_XSSEL		= 1<<1,	/* XPath subset for schema selector */
+    XML_PATTERN_XSFIELD		= 1<<2	/* XPath subset for schema field */
+} xmlPatternFlags;
+
+XMLPUBFUN void XMLCALL
+			xmlFreePattern		(xmlPatternPtr comp);
+
+XMLPUBFUN void XMLCALL
+			xmlFreePatternList	(xmlPatternPtr comp);
+
+XMLPUBFUN xmlPatternPtr XMLCALL
+			xmlPatterncompile	(const xmlChar *pattern,
+						 xmlDict *dict,
+						 int flags,
+						 const xmlChar **namespaces);
+XMLPUBFUN int XMLCALL
+			xmlPatternMatch		(xmlPatternPtr comp,
+						 xmlNodePtr node);
+
+/* streaming interfaces */
+typedef struct _xmlStreamCtxt xmlStreamCtxt;
+typedef xmlStreamCtxt *xmlStreamCtxtPtr;
+
+XMLPUBFUN int XMLCALL
+			xmlPatternStreamable	(xmlPatternPtr comp);
+XMLPUBFUN int XMLCALL
+			xmlPatternMaxDepth	(xmlPatternPtr comp);
+XMLPUBFUN int XMLCALL
+			xmlPatternMinDepth	(xmlPatternPtr comp);
+XMLPUBFUN int XMLCALL
+			xmlPatternFromRoot	(xmlPatternPtr comp);
+XMLPUBFUN xmlStreamCtxtPtr XMLCALL
+			xmlPatternGetStreamCtxt	(xmlPatternPtr comp);
+XMLPUBFUN void XMLCALL
+			xmlFreeStreamCtxt	(xmlStreamCtxtPtr stream);
+XMLPUBFUN int XMLCALL
+			xmlStreamPushNode	(xmlStreamCtxtPtr stream,
+						 const xmlChar *name,
+						 const xmlChar *ns,
+						 int nodeType);
+XMLPUBFUN int XMLCALL
+			xmlStreamPush		(xmlStreamCtxtPtr stream,
+						 const xmlChar *name,
+						 const xmlChar *ns);
+XMLPUBFUN int XMLCALL
+			xmlStreamPushAttr	(xmlStreamCtxtPtr stream,
+						 const xmlChar *name,
+						 const xmlChar *ns);
+XMLPUBFUN int XMLCALL
+			xmlStreamPop		(xmlStreamCtxtPtr stream);
+XMLPUBFUN int XMLCALL
+			xmlStreamWantsAnyNode	(xmlStreamCtxtPtr stream);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_PATTERN_ENABLED */
+
+#endif /* __XML_PATTERN_H__ */
diff -Naur orig.ns-2.33/libxml/relaxng.h ns-2.33/libxml/relaxng.h
--- orig.ns-2.33/libxml/relaxng.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/relaxng.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,196 @@
+/*
+ * Summary: implementation of the Relax-NG validation
+ * Description: implementation of the Relax-NG validation
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_RELAX_NG__
+#define __XML_RELAX_NG__
+
+#include <libxml/xmlversion.h>
+#include <libxml/hash.h>
+#include <libxml/xmlstring.h>
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct _xmlRelaxNG xmlRelaxNG;
+typedef xmlRelaxNG *xmlRelaxNGPtr;
+
+
+/**
+ * A schemas validation context
+ */
+typedef void (XMLCDECL *xmlRelaxNGValidityErrorFunc) (void *ctx, const char *msg, ...);
+typedef void (XMLCDECL *xmlRelaxNGValidityWarningFunc) (void *ctx, const char *msg, ...);
+
+typedef struct _xmlRelaxNGParserCtxt xmlRelaxNGParserCtxt;
+typedef xmlRelaxNGParserCtxt *xmlRelaxNGParserCtxtPtr;
+
+typedef struct _xmlRelaxNGValidCtxt xmlRelaxNGValidCtxt;
+typedef xmlRelaxNGValidCtxt *xmlRelaxNGValidCtxtPtr;
+
+/*
+ * xmlRelaxNGValidErr:
+ *
+ * List of possible Relax NG validation errors
+ */
+typedef enum {
+    XML_RELAXNG_OK = 0,
+    XML_RELAXNG_ERR_MEMORY,
+    XML_RELAXNG_ERR_TYPE,
+    XML_RELAXNG_ERR_TYPEVAL,
+    XML_RELAXNG_ERR_DUPID,
+    XML_RELAXNG_ERR_TYPECMP,
+    XML_RELAXNG_ERR_NOSTATE,
+    XML_RELAXNG_ERR_NODEFINE,
+    XML_RELAXNG_ERR_LISTEXTRA,
+    XML_RELAXNG_ERR_LISTEMPTY,
+    XML_RELAXNG_ERR_INTERNODATA,
+    XML_RELAXNG_ERR_INTERSEQ,
+    XML_RELAXNG_ERR_INTEREXTRA,
+    XML_RELAXNG_ERR_ELEMNAME,
+    XML_RELAXNG_ERR_ATTRNAME,
+    XML_RELAXNG_ERR_ELEMNONS,
+    XML_RELAXNG_ERR_ATTRNONS,
+    XML_RELAXNG_ERR_ELEMWRONGNS,
+    XML_RELAXNG_ERR_ATTRWRONGNS,
+    XML_RELAXNG_ERR_ELEMEXTRANS,
+    XML_RELAXNG_ERR_ATTREXTRANS,
+    XML_RELAXNG_ERR_ELEMNOTEMPTY,
+    XML_RELAXNG_ERR_NOELEM,
+    XML_RELAXNG_ERR_NOTELEM,
+    XML_RELAXNG_ERR_ATTRVALID,
+    XML_RELAXNG_ERR_CONTENTVALID,
+    XML_RELAXNG_ERR_EXTRACONTENT,
+    XML_RELAXNG_ERR_INVALIDATTR,
+    XML_RELAXNG_ERR_DATAELEM,
+    XML_RELAXNG_ERR_VALELEM,
+    XML_RELAXNG_ERR_LISTELEM,
+    XML_RELAXNG_ERR_DATATYPE,
+    XML_RELAXNG_ERR_VALUE,
+    XML_RELAXNG_ERR_LIST,
+    XML_RELAXNG_ERR_NOGRAMMAR,
+    XML_RELAXNG_ERR_EXTRADATA,
+    XML_RELAXNG_ERR_LACKDATA,
+    XML_RELAXNG_ERR_INTERNAL,
+    XML_RELAXNG_ERR_ELEMWRONG,
+    XML_RELAXNG_ERR_TEXTWRONG
+} xmlRelaxNGValidErr;
+
+/*
+ * xmlRelaxNGParserFlags:
+ *
+ * List of possible Relax NG Parser flags
+ */
+typedef enum {
+    XML_RELAXNGP_NONE = 0,
+    XML_RELAXNGP_FREE_DOC = 1,
+    XML_RELAXNGP_CRNG = 2
+} xmlRelaxNGParserFlag;
+
+XMLPUBFUN int XMLCALL
+		    xmlRelaxNGInitTypes		(void);
+XMLPUBFUN void XMLCALL			
+		    xmlRelaxNGCleanupTypes	(void);
+
+/*
+ * Interfaces for parsing.
+ */
+XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL 
+		    xmlRelaxNGNewParserCtxt	(const char *URL);
+XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL 
+		    xmlRelaxNGNewMemParserCtxt	(const char *buffer,
+						 int size);
+XMLPUBFUN xmlRelaxNGParserCtxtPtr XMLCALL   
+		    xmlRelaxNGNewDocParserCtxt	(xmlDocPtr doc);
+
+XMLPUBFUN int XMLCALL
+		    xmlRelaxParserSetFlag	(xmlRelaxNGParserCtxtPtr ctxt,
+		    				 int flag);
+
+XMLPUBFUN void XMLCALL		
+		    xmlRelaxNGFreeParserCtxt	(xmlRelaxNGParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL			
+		    xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,
+					 xmlRelaxNGValidityErrorFunc err,
+					 xmlRelaxNGValidityWarningFunc warn,
+					 void *ctx);
+XMLPUBFUN int XMLCALL
+		    xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,
+					 xmlRelaxNGValidityErrorFunc *err,
+					 xmlRelaxNGValidityWarningFunc *warn,
+					 void **ctx);
+XMLPUBFUN void XMLCALL
+		    xmlRelaxNGSetParserStructuredErrors(
+					 xmlRelaxNGParserCtxtPtr ctxt,
+					 xmlStructuredErrorFunc serror,
+					 void *ctx);
+XMLPUBFUN xmlRelaxNGPtr XMLCALL	
+		    xmlRelaxNGParse		(xmlRelaxNGParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL		
+		    xmlRelaxNGFree		(xmlRelaxNGPtr schema);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		
+		    xmlRelaxNGDump		(FILE *output,
+					 xmlRelaxNGPtr schema);
+XMLPUBFUN void XMLCALL
+		    xmlRelaxNGDumpTree	(FILE * output,
+					 xmlRelaxNGPtr schema);
+#endif /* LIBXML_OUTPUT_ENABLED */
+/*
+ * Interfaces for validating
+ */
+XMLPUBFUN void XMLCALL		
+		    xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
+					 xmlRelaxNGValidityErrorFunc err,
+					 xmlRelaxNGValidityWarningFunc warn,
+					 void *ctx);
+XMLPUBFUN int XMLCALL	
+		    xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,
+					 xmlRelaxNGValidityErrorFunc *err,
+					 xmlRelaxNGValidityWarningFunc *warn,
+					 void **ctx);
+XMLPUBFUN void XMLCALL
+			xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,
+					  xmlStructuredErrorFunc serror, void *ctx);
+XMLPUBFUN xmlRelaxNGValidCtxtPtr XMLCALL	
+		    xmlRelaxNGNewValidCtxt	(xmlRelaxNGPtr schema);
+XMLPUBFUN void XMLCALL			
+		    xmlRelaxNGFreeValidCtxt	(xmlRelaxNGValidCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+		    xmlRelaxNGValidateDoc	(xmlRelaxNGValidCtxtPtr ctxt,
+					 	 xmlDocPtr doc);
+/*
+ * Interfaces for progressive validation when possible
+ */
+XMLPUBFUN int XMLCALL	
+		    xmlRelaxNGValidatePushElement	(xmlRelaxNGValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem);
+XMLPUBFUN int XMLCALL	
+		    xmlRelaxNGValidatePushCData	(xmlRelaxNGValidCtxtPtr ctxt,
+					 const xmlChar *data,
+					 int len);
+XMLPUBFUN int XMLCALL	
+		    xmlRelaxNGValidatePopElement	(xmlRelaxNGValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem);
+XMLPUBFUN int XMLCALL	
+		    xmlRelaxNGValidateFullElement	(xmlRelaxNGValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_SCHEMAS_ENABLED */
+
+#endif /* __XML_RELAX_NG__ */
diff -Naur orig.ns-2.33/libxml/schemasInternals.h ns-2.33/libxml/schemasInternals.h
--- orig.ns-2.33/libxml/schemasInternals.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/schemasInternals.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,958 @@
+/*
+ * Summary: internal interfaces for XML Schemas
+ * Description: internal interfaces for the XML Schemas handling
+ *              and schema validity checking
+ *		The Schemas development is a Work In Progress.
+ *              Some of those interfaces are not garanteed to be API or ABI stable !
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_SCHEMA_INTERNALS_H__
+#define __XML_SCHEMA_INTERNALS_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#include <libxml/xmlregexp.h>
+#include <libxml/hash.h>
+#include <libxml/dict.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    XML_SCHEMAS_UNKNOWN = 0,
+    XML_SCHEMAS_STRING,
+    XML_SCHEMAS_NORMSTRING,
+    XML_SCHEMAS_DECIMAL,
+    XML_SCHEMAS_TIME,
+    XML_SCHEMAS_GDAY,
+    XML_SCHEMAS_GMONTH,
+    XML_SCHEMAS_GMONTHDAY,
+    XML_SCHEMAS_GYEAR,
+    XML_SCHEMAS_GYEARMONTH,
+    XML_SCHEMAS_DATE,
+    XML_SCHEMAS_DATETIME,
+    XML_SCHEMAS_DURATION,
+    XML_SCHEMAS_FLOAT,
+    XML_SCHEMAS_DOUBLE,
+    XML_SCHEMAS_BOOLEAN,
+    XML_SCHEMAS_TOKEN,
+    XML_SCHEMAS_LANGUAGE,
+    XML_SCHEMAS_NMTOKEN,
+    XML_SCHEMAS_NMTOKENS,
+    XML_SCHEMAS_NAME,
+    XML_SCHEMAS_QNAME,
+    XML_SCHEMAS_NCNAME,
+    XML_SCHEMAS_ID,
+    XML_SCHEMAS_IDREF,
+    XML_SCHEMAS_IDREFS,
+    XML_SCHEMAS_ENTITY,
+    XML_SCHEMAS_ENTITIES,
+    XML_SCHEMAS_NOTATION,
+    XML_SCHEMAS_ANYURI,
+    XML_SCHEMAS_INTEGER,
+    XML_SCHEMAS_NPINTEGER,
+    XML_SCHEMAS_NINTEGER,
+    XML_SCHEMAS_NNINTEGER,
+    XML_SCHEMAS_PINTEGER,
+    XML_SCHEMAS_INT,
+    XML_SCHEMAS_UINT,
+    XML_SCHEMAS_LONG,
+    XML_SCHEMAS_ULONG,
+    XML_SCHEMAS_SHORT,
+    XML_SCHEMAS_USHORT,
+    XML_SCHEMAS_BYTE,
+    XML_SCHEMAS_UBYTE,
+    XML_SCHEMAS_HEXBINARY,
+    XML_SCHEMAS_BASE64BINARY,
+    XML_SCHEMAS_ANYTYPE,
+    XML_SCHEMAS_ANYSIMPLETYPE
+} xmlSchemaValType;
+
+/*
+ * XML Schemas defines multiple type of types.
+ */
+typedef enum {
+    XML_SCHEMA_TYPE_BASIC = 1, /* A built-in datatype */
+    XML_SCHEMA_TYPE_ANY,
+    XML_SCHEMA_TYPE_FACET,
+    XML_SCHEMA_TYPE_SIMPLE,
+    XML_SCHEMA_TYPE_COMPLEX,
+    XML_SCHEMA_TYPE_SEQUENCE = 6,
+    XML_SCHEMA_TYPE_CHOICE,
+    XML_SCHEMA_TYPE_ALL,
+    XML_SCHEMA_TYPE_SIMPLE_CONTENT,
+    XML_SCHEMA_TYPE_COMPLEX_CONTENT,
+    XML_SCHEMA_TYPE_UR,
+    XML_SCHEMA_TYPE_RESTRICTION,
+    XML_SCHEMA_TYPE_EXTENSION,
+    XML_SCHEMA_TYPE_ELEMENT,
+    XML_SCHEMA_TYPE_ATTRIBUTE,
+    XML_SCHEMA_TYPE_ATTRIBUTEGROUP,
+    XML_SCHEMA_TYPE_GROUP,
+    XML_SCHEMA_TYPE_NOTATION,
+    XML_SCHEMA_TYPE_LIST,
+    XML_SCHEMA_TYPE_UNION,
+    XML_SCHEMA_TYPE_ANY_ATTRIBUTE,
+    XML_SCHEMA_TYPE_IDC_UNIQUE,
+    XML_SCHEMA_TYPE_IDC_KEY,
+    XML_SCHEMA_TYPE_IDC_KEYREF,
+    XML_SCHEMA_TYPE_PARTICLE = 25, 
+    XML_SCHEMA_TYPE_ATTRIBUTE_USE, 
+    XML_SCHEMA_FACET_MININCLUSIVE = 1000,
+    XML_SCHEMA_FACET_MINEXCLUSIVE,
+    XML_SCHEMA_FACET_MAXINCLUSIVE,
+    XML_SCHEMA_FACET_MAXEXCLUSIVE,
+    XML_SCHEMA_FACET_TOTALDIGITS,
+    XML_SCHEMA_FACET_FRACTIONDIGITS,
+    XML_SCHEMA_FACET_PATTERN,
+    XML_SCHEMA_FACET_ENUMERATION,
+    XML_SCHEMA_FACET_WHITESPACE,
+    XML_SCHEMA_FACET_LENGTH,
+    XML_SCHEMA_FACET_MAXLENGTH,
+    XML_SCHEMA_FACET_MINLENGTH,
+    XML_SCHEMA_EXTRA_QNAMEREF = 2000,
+    XML_SCHEMA_EXTRA_ATTR_USE_PROHIB
+} xmlSchemaTypeType;
+
+typedef enum {
+    XML_SCHEMA_CONTENT_UNKNOWN = 0,
+    XML_SCHEMA_CONTENT_EMPTY = 1,
+    XML_SCHEMA_CONTENT_ELEMENTS,
+    XML_SCHEMA_CONTENT_MIXED,
+    XML_SCHEMA_CONTENT_SIMPLE,
+    XML_SCHEMA_CONTENT_MIXED_OR_ELEMENTS, /* Obsolete */
+    XML_SCHEMA_CONTENT_BASIC,
+    XML_SCHEMA_CONTENT_ANY
+} xmlSchemaContentType;
+
+typedef struct _xmlSchemaVal xmlSchemaVal;
+typedef xmlSchemaVal *xmlSchemaValPtr;
+
+typedef struct _xmlSchemaType xmlSchemaType;
+typedef xmlSchemaType *xmlSchemaTypePtr;
+
+typedef struct _xmlSchemaFacet xmlSchemaFacet;
+typedef xmlSchemaFacet *xmlSchemaFacetPtr;
+
+/**
+ * Annotation
+ */
+typedef struct _xmlSchemaAnnot xmlSchemaAnnot;
+typedef xmlSchemaAnnot *xmlSchemaAnnotPtr;
+struct _xmlSchemaAnnot {
+    struct _xmlSchemaAnnot *next;
+    xmlNodePtr content;         /* the annotation */
+};
+
+/**
+ * XML_SCHEMAS_ANYATTR_SKIP:
+ *
+ * Skip unknown attribute from validation
+ * Obsolete, not used anymore.
+ */
+#define XML_SCHEMAS_ANYATTR_SKIP        1
+/**
+ * XML_SCHEMAS_ANYATTR_LAX:
+ *
+ * Ignore validation non definition on attributes
+ * Obsolete, not used anymore.
+ */
+#define XML_SCHEMAS_ANYATTR_LAX                2
+/**
+ * XML_SCHEMAS_ANYATTR_STRICT:
+ *
+ * Apply strict validation rules on attributes
+ * Obsolete, not used anymore.
+ */
+#define XML_SCHEMAS_ANYATTR_STRICT        3
+/**
+ * XML_SCHEMAS_ANY_SKIP:
+ *
+ * Skip unknown attribute from validation
+ */
+#define XML_SCHEMAS_ANY_SKIP        1
+/**
+ * XML_SCHEMAS_ANY_LAX:
+ *
+ * Used by wildcards.
+ * Validate if type found, don't worry if not found
+ */
+#define XML_SCHEMAS_ANY_LAX                2
+/**
+ * XML_SCHEMAS_ANY_STRICT:
+ *
+ * Used by wildcards.
+ * Apply strict validation rules
+ */
+#define XML_SCHEMAS_ANY_STRICT        3
+/**
+ * XML_SCHEMAS_ATTR_USE_PROHIBITED:
+ *
+ * Used by wildcards.
+ * The attribute is prohibited.
+ */
+#define XML_SCHEMAS_ATTR_USE_PROHIBITED 0
+/**
+ * XML_SCHEMAS_ATTR_USE_REQUIRED:
+ *
+ * The attribute is required.
+ */
+#define XML_SCHEMAS_ATTR_USE_REQUIRED 1
+/**
+ * XML_SCHEMAS_ATTR_USE_OPTIONAL:
+ *
+ * The attribute is optional.
+ */
+#define XML_SCHEMAS_ATTR_USE_OPTIONAL 2
+/**
+ * XML_SCHEMAS_ATTR_GLOBAL:
+ *
+ * allow elements in no namespace
+ */
+#define XML_SCHEMAS_ATTR_GLOBAL        1 << 0
+/**
+ * XML_SCHEMAS_ATTR_NSDEFAULT:
+ *
+ * allow elements in no namespace
+ */
+#define XML_SCHEMAS_ATTR_NSDEFAULT        1 << 7
+/**
+ * XML_SCHEMAS_ATTR_INTERNAL_RESOLVED:
+ *
+ * this is set when the "type" and "ref" references
+ * have been resolved.
+ */
+#define XML_SCHEMAS_ATTR_INTERNAL_RESOLVED        1 << 8
+/**
+ * XML_SCHEMAS_ATTR_FIXED:
+ *
+ * the attribute has a fixed value
+ */
+#define XML_SCHEMAS_ATTR_FIXED        1 << 9
+
+/**
+ * xmlSchemaAttribute:
+ * An attribute definition.
+ */
+
+typedef struct _xmlSchemaAttribute xmlSchemaAttribute;
+typedef xmlSchemaAttribute *xmlSchemaAttributePtr;
+struct _xmlSchemaAttribute {
+    xmlSchemaTypeType type;
+    struct _xmlSchemaAttribute *next; /* the next attribute (not used?) */
+    const xmlChar *name; /* the name of the declaration */
+    const xmlChar *id; /* Deprecated; not used */
+    const xmlChar *ref; /* Deprecated; not used */
+    const xmlChar *refNs; /* Deprecated; not used */
+    const xmlChar *typeName; /* the local name of the type definition */
+    const xmlChar *typeNs; /* the ns URI of the type definition */
+    xmlSchemaAnnotPtr annot;
+
+    xmlSchemaTypePtr base; /* Deprecated; not used */
+    int occurs; /* Deprecated; not used */
+    const xmlChar *defValue; /* The initial value of the value constraint */
+    xmlSchemaTypePtr subtypes; /* the type definition */
+    xmlNodePtr node;
+    const xmlChar *targetNamespace;
+    int flags;
+    const xmlChar *refPrefix; /* Deprecated; not used */
+    xmlSchemaValPtr defVal; /* The compiled value constraint */
+    xmlSchemaAttributePtr refDecl; /* Deprecated; not used */
+};
+
+/**
+ * xmlSchemaAttributeLink:
+ * Used to build a list of attribute uses on complexType definitions.
+ * WARNING: Deprecated; not used.
+ */
+typedef struct _xmlSchemaAttributeLink xmlSchemaAttributeLink;
+typedef xmlSchemaAttributeLink *xmlSchemaAttributeLinkPtr;
+struct _xmlSchemaAttributeLink {
+    struct _xmlSchemaAttributeLink *next;/* the next attribute link ... */
+    struct _xmlSchemaAttribute *attr;/* the linked attribute */
+};
+
+/**
+ * XML_SCHEMAS_WILDCARD_COMPLETE:
+ *
+ * If the wildcard is complete.
+ */
+#define XML_SCHEMAS_WILDCARD_COMPLETE 1 << 0
+
+/**
+ * xmlSchemaCharValueLink:
+ * Used to build a list of namespaces on wildcards.
+ */
+typedef struct _xmlSchemaWildcardNs xmlSchemaWildcardNs;
+typedef xmlSchemaWildcardNs *xmlSchemaWildcardNsPtr;
+struct _xmlSchemaWildcardNs {
+    struct _xmlSchemaWildcardNs *next;/* the next constraint link ... */
+    const xmlChar *value;/* the value */
+};
+
+/**
+ * xmlSchemaWildcard.
+ * A wildcard.
+ */
+typedef struct _xmlSchemaWildcard xmlSchemaWildcard;
+typedef xmlSchemaWildcard *xmlSchemaWildcardPtr;
+struct _xmlSchemaWildcard {
+    xmlSchemaTypeType type;        /* The kind of type */
+    const xmlChar *id; /* Deprecated; not used */
+    xmlSchemaAnnotPtr annot;
+    xmlNodePtr node;
+    int minOccurs; /* Deprecated; not used */
+    int maxOccurs; /* Deprecated; not used */
+    int processContents;
+    int any; /* Indicates if the ns constraint is of ##any */
+    xmlSchemaWildcardNsPtr nsSet; /* The list of allowed namespaces */
+    xmlSchemaWildcardNsPtr negNsSet; /* The negated namespace */
+    int flags;
+};
+
+/**
+ * XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED:
+ *
+ * The attribute wildcard has been already builded.
+ */
+#define XML_SCHEMAS_ATTRGROUP_WILDCARD_BUILDED 1 << 0
+/**
+ * XML_SCHEMAS_ATTRGROUP_GLOBAL:
+ *
+ * The attribute wildcard has been already builded.
+ */
+#define XML_SCHEMAS_ATTRGROUP_GLOBAL 1 << 1
+/**
+ * XML_SCHEMAS_ATTRGROUP_MARKED:
+ *
+ * Marks the attr group as marked; used for circular checks.
+ */
+#define XML_SCHEMAS_ATTRGROUP_MARKED 1 << 2
+
+/**
+ * XML_SCHEMAS_ATTRGROUP_REDEFINED:
+ *
+ * The attr group was redefined.
+ */
+#define XML_SCHEMAS_ATTRGROUP_REDEFINED 1 << 3
+/**
+ * XML_SCHEMAS_ATTRGROUP_HAS_REFS:
+ *
+ * Whether this attr. group contains attr. group references.
+ */
+#define XML_SCHEMAS_ATTRGROUP_HAS_REFS 1 << 4
+
+/**
+ * An attribute group definition.
+ *
+ * xmlSchemaAttribute and xmlSchemaAttributeGroup start of structures
+ * must be kept similar
+ */
+typedef struct _xmlSchemaAttributeGroup xmlSchemaAttributeGroup;
+typedef xmlSchemaAttributeGroup *xmlSchemaAttributeGroupPtr;
+struct _xmlSchemaAttributeGroup {
+    xmlSchemaTypeType type;        /* The kind of type */
+    struct _xmlSchemaAttribute *next;/* the next attribute if in a group ... */
+    const xmlChar *name;
+    const xmlChar *id;
+    const xmlChar *ref; /* Deprecated; not used */
+    const xmlChar *refNs; /* Deprecated; not used */
+    xmlSchemaAnnotPtr annot;
+
+    xmlSchemaAttributePtr attributes; /* Deprecated; not used */
+    xmlNodePtr node;
+    int flags;
+    xmlSchemaWildcardPtr attributeWildcard;
+    const xmlChar *refPrefix; /* Deprecated; not used */
+    xmlSchemaAttributeGroupPtr refItem; /* Deprecated; not used */
+    const xmlChar *targetNamespace;
+    void *attrUses;
+};
+
+/**
+ * xmlSchemaTypeLink:
+ * Used to build a list of types (e.g. member types of
+ * simpleType with variety "union").
+ */
+typedef struct _xmlSchemaTypeLink xmlSchemaTypeLink;
+typedef xmlSchemaTypeLink *xmlSchemaTypeLinkPtr;
+struct _xmlSchemaTypeLink {
+    struct _xmlSchemaTypeLink *next;/* the next type link ... */
+    xmlSchemaTypePtr type;/* the linked type */
+};
+
+/**
+ * xmlSchemaFacetLink:
+ * Used to build a list of facets.
+ */
+typedef struct _xmlSchemaFacetLink xmlSchemaFacetLink;
+typedef xmlSchemaFacetLink *xmlSchemaFacetLinkPtr;
+struct _xmlSchemaFacetLink {
+    struct _xmlSchemaFacetLink *next;/* the next facet link ... */
+    xmlSchemaFacetPtr facet;/* the linked facet */
+};
+
+/**
+ * XML_SCHEMAS_TYPE_MIXED:
+ *
+ * the element content type is mixed
+ */
+#define XML_SCHEMAS_TYPE_MIXED                1 << 0
+/**
+ * XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION:
+ *
+ * the simple or complex type has a derivation method of "extension".
+ */
+#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_EXTENSION                1 << 1
+/**
+ * XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION:
+ *
+ * the simple or complex type has a derivation method of "restriction".
+ */
+#define XML_SCHEMAS_TYPE_DERIVATION_METHOD_RESTRICTION                1 << 2
+/**
+ * XML_SCHEMAS_TYPE_GLOBAL:
+ *
+ * the type is global
+ */
+#define XML_SCHEMAS_TYPE_GLOBAL                1 << 3
+/**
+ * XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD:
+ *
+ * the complexType owns an attribute wildcard, i.e.
+ * it can be freed by the complexType
+ */
+#define XML_SCHEMAS_TYPE_OWNED_ATTR_WILDCARD    1 << 4 /* Obsolete. */
+/**
+ * XML_SCHEMAS_TYPE_VARIETY_ABSENT:
+ *
+ * the simpleType has a variety of "absent".
+ * TODO: Actually not necessary :-/, since if
+ * none of the variety flags occur then it's
+ * automatically absent.
+ */
+#define XML_SCHEMAS_TYPE_VARIETY_ABSENT    1 << 5
+/**
+ * XML_SCHEMAS_TYPE_VARIETY_LIST:
+ *
+ * the simpleType has a variety of "list".
+ */
+#define XML_SCHEMAS_TYPE_VARIETY_LIST    1 << 6
+/**
+ * XML_SCHEMAS_TYPE_VARIETY_UNION:
+ *
+ * the simpleType has a variety of "union".
+ */
+#define XML_SCHEMAS_TYPE_VARIETY_UNION    1 << 7
+/**
+ * XML_SCHEMAS_TYPE_VARIETY_ATOMIC:
+ *
+ * the simpleType has a variety of "union".
+ */
+#define XML_SCHEMAS_TYPE_VARIETY_ATOMIC    1 << 8
+/**
+ * XML_SCHEMAS_TYPE_FINAL_EXTENSION:
+ *
+ * the complexType has a final of "extension".
+ */
+#define XML_SCHEMAS_TYPE_FINAL_EXTENSION    1 << 9
+/**
+ * XML_SCHEMAS_TYPE_FINAL_RESTRICTION:
+ *
+ * the simpleType/complexType has a final of "restriction".
+ */
+#define XML_SCHEMAS_TYPE_FINAL_RESTRICTION    1 << 10
+/**
+ * XML_SCHEMAS_TYPE_FINAL_LIST:
+ *
+ * the simpleType has a final of "list".
+ */
+#define XML_SCHEMAS_TYPE_FINAL_LIST    1 << 11
+/**
+ * XML_SCHEMAS_TYPE_FINAL_UNION:
+ *
+ * the simpleType has a final of "union".
+ */
+#define XML_SCHEMAS_TYPE_FINAL_UNION    1 << 12
+/**
+ * XML_SCHEMAS_TYPE_FINAL_DEFAULT:
+ *
+ * the simpleType has a final of "default".
+ */
+#define XML_SCHEMAS_TYPE_FINAL_DEFAULT    1 << 13
+/**
+ * XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE:
+ *
+ * Marks the item as a builtin primitive.
+ */
+#define XML_SCHEMAS_TYPE_BUILTIN_PRIMITIVE    1 << 14
+/**
+ * XML_SCHEMAS_TYPE_MARKED:
+ *
+ * Marks the item as marked; used for circular checks.
+ */
+#define XML_SCHEMAS_TYPE_MARKED        1 << 16
+/**
+ * XML_SCHEMAS_TYPE_BLOCK_DEFAULT:
+ *
+ * the complexType did not specify 'block' so use the default of the
+ * <schema> item.
+ */
+#define XML_SCHEMAS_TYPE_BLOCK_DEFAULT    1 << 17
+/**
+ * XML_SCHEMAS_TYPE_BLOCK_EXTENSION:
+ *
+ * the complexType has a 'block' of "extension".
+ */
+#define XML_SCHEMAS_TYPE_BLOCK_EXTENSION    1 << 18
+/**
+ * XML_SCHEMAS_TYPE_BLOCK_RESTRICTION:
+ *
+ * the complexType has a 'block' of "restriction".
+ */
+#define XML_SCHEMAS_TYPE_BLOCK_RESTRICTION    1 << 19
+/**
+ * XML_SCHEMAS_TYPE_ABSTRACT:
+ *
+ * the simple/complexType is abstract.
+ */
+#define XML_SCHEMAS_TYPE_ABSTRACT    1 << 20
+/**
+ * XML_SCHEMAS_TYPE_FACETSNEEDVALUE:
+ *
+ * indicates if the facets need a computed value
+ */
+#define XML_SCHEMAS_TYPE_FACETSNEEDVALUE    1 << 21
+/**
+ * XML_SCHEMAS_TYPE_INTERNAL_RESOLVED:
+ *
+ * indicates that the type was typefixed
+ */
+#define XML_SCHEMAS_TYPE_INTERNAL_RESOLVED    1 << 22
+/**
+ * XML_SCHEMAS_TYPE_INTERNAL_INVALID:
+ *
+ * indicates that the type is invalid
+ */
+#define XML_SCHEMAS_TYPE_INTERNAL_INVALID    1 << 23
+/**
+ * XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE:
+ *
+ * a whitespace-facet value of "preserve"
+ */
+#define XML_SCHEMAS_TYPE_WHITESPACE_PRESERVE    1 << 24
+/**
+ * XML_SCHEMAS_TYPE_WHITESPACE_REPLACE:
+ *
+ * a whitespace-facet value of "replace"
+ */
+#define XML_SCHEMAS_TYPE_WHITESPACE_REPLACE    1 << 25
+/**
+ * XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE:
+ *
+ * a whitespace-facet value of "collapse"
+ */
+#define XML_SCHEMAS_TYPE_WHITESPACE_COLLAPSE    1 << 26
+/**
+ * XML_SCHEMAS_TYPE_HAS_FACETS:
+ *
+ * has facets
+ */
+#define XML_SCHEMAS_TYPE_HAS_FACETS    1 << 27
+/**
+ * XML_SCHEMAS_TYPE_NORMVALUENEEDED:
+ *
+ * indicates if the facets (pattern) need a normalized value
+ */
+#define XML_SCHEMAS_TYPE_NORMVALUENEEDED    1 << 28
+
+/**
+ * XML_SCHEMAS_TYPE_FIXUP_1:
+ *
+ * First stage of fixup was done.
+ */
+#define XML_SCHEMAS_TYPE_FIXUP_1    1 << 29
+
+/**
+ * XML_SCHEMAS_TYPE_REDEFINED:
+ *
+ * The type was redefined.
+ */
+#define XML_SCHEMAS_TYPE_REDEFINED    1 << 30
+/**
+ * XML_SCHEMAS_TYPE_REDEFINING:
+ *
+ * The type redefines an other type.
+ */
+/* #define XML_SCHEMAS_TYPE_REDEFINING    1 << 31 */
+
+/**
+ * _xmlSchemaType:
+ *
+ * Schemas type definition.
+ */
+struct _xmlSchemaType {
+    xmlSchemaTypeType type; /* The kind of type */
+    struct _xmlSchemaType *next; /* the next type if in a sequence ... */
+    const xmlChar *name;
+    const xmlChar *id ; /* Deprecated; not used */
+    const xmlChar *ref; /* Deprecated; not used */
+    const xmlChar *refNs; /* Deprecated; not used */
+    xmlSchemaAnnotPtr annot;
+    xmlSchemaTypePtr subtypes;
+    xmlSchemaAttributePtr attributes; /* Deprecated; not used */
+    xmlNodePtr node;
+    int minOccurs; /* Deprecated; not used */
+    int maxOccurs; /* Deprecated; not used */
+
+    int flags;
+    xmlSchemaContentType contentType;
+    const xmlChar *base; /* Base type's local name */
+    const xmlChar *baseNs; /* Base type's target namespace */
+    xmlSchemaTypePtr baseType; /* The base type component */
+    xmlSchemaFacetPtr facets; /* Local facets */
+    struct _xmlSchemaType *redef; /* Deprecated; not used */
+    int recurse; /* Obsolete */
+    xmlSchemaAttributeLinkPtr *attributeUses; /* Deprecated; not used */
+    xmlSchemaWildcardPtr attributeWildcard;
+    int builtInType; /* Type of built-in types. */
+    xmlSchemaTypeLinkPtr memberTypes; /* member-types if a union type. */
+    xmlSchemaFacetLinkPtr facetSet; /* All facets (incl. inherited) */
+    const xmlChar *refPrefix; /* Deprecated; not used */
+    xmlSchemaTypePtr contentTypeDef; /* Used for the simple content of complex types.
+                                        Could we use @subtypes for this? */
+    xmlRegexpPtr contModel; /* Holds the automaton of the content model */
+    const xmlChar *targetNamespace;
+    void *attrUses;
+};
+
+/*
+ * xmlSchemaElement:
+ * An element definition.
+ *
+ * xmlSchemaType, xmlSchemaFacet and xmlSchemaElement start of
+ * structures must be kept similar
+ */
+/**
+ * XML_SCHEMAS_ELEM_NILLABLE:
+ *
+ * the element is nillable
+ */
+#define XML_SCHEMAS_ELEM_NILLABLE        1 << 0
+/**
+ * XML_SCHEMAS_ELEM_GLOBAL:
+ *
+ * the element is global
+ */
+#define XML_SCHEMAS_ELEM_GLOBAL                1 << 1
+/**
+ * XML_SCHEMAS_ELEM_DEFAULT:
+ *
+ * the element has a default value
+ */
+#define XML_SCHEMAS_ELEM_DEFAULT        1 << 2
+/**
+ * XML_SCHEMAS_ELEM_FIXED:
+ *
+ * the element has a fixed value
+ */
+#define XML_SCHEMAS_ELEM_FIXED                1 << 3
+/**
+ * XML_SCHEMAS_ELEM_ABSTRACT:
+ *
+ * the element is abstract
+ */
+#define XML_SCHEMAS_ELEM_ABSTRACT        1 << 4
+/**
+ * XML_SCHEMAS_ELEM_TOPLEVEL:
+ *
+ * the element is top level
+ * obsolete: use XML_SCHEMAS_ELEM_GLOBAL instead
+ */
+#define XML_SCHEMAS_ELEM_TOPLEVEL        1 << 5
+/**
+ * XML_SCHEMAS_ELEM_REF:
+ *
+ * the element is a reference to a type
+ */
+#define XML_SCHEMAS_ELEM_REF                1 << 6
+/**
+ * XML_SCHEMAS_ELEM_NSDEFAULT:
+ *
+ * allow elements in no namespace
+ * Obsolete, not used anymore.
+ */
+#define XML_SCHEMAS_ELEM_NSDEFAULT        1 << 7
+/**
+ * XML_SCHEMAS_ELEM_INTERNAL_RESOLVED:
+ *
+ * this is set when "type", "ref", "substitutionGroup"
+ * references have been resolved.
+ */
+#define XML_SCHEMAS_ELEM_INTERNAL_RESOLVED        1 << 8
+ /**
+ * XML_SCHEMAS_ELEM_CIRCULAR:
+ *
+ * a helper flag for the search of circular references.
+ */
+#define XML_SCHEMAS_ELEM_CIRCULAR        1 << 9
+/**
+ * XML_SCHEMAS_ELEM_BLOCK_ABSENT:
+ *
+ * the "block" attribute is absent
+ */
+#define XML_SCHEMAS_ELEM_BLOCK_ABSENT        1 << 10
+/**
+ * XML_SCHEMAS_ELEM_BLOCK_EXTENSION:
+ *
+ * disallowed substitutions are absent
+ */
+#define XML_SCHEMAS_ELEM_BLOCK_EXTENSION        1 << 11
+/**
+ * XML_SCHEMAS_ELEM_BLOCK_RESTRICTION:
+ *
+ * disallowed substitutions: "restriction"
+ */
+#define XML_SCHEMAS_ELEM_BLOCK_RESTRICTION        1 << 12
+/**
+ * XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION:
+ *
+ * disallowed substitutions: "substituion"
+ */
+#define XML_SCHEMAS_ELEM_BLOCK_SUBSTITUTION        1 << 13
+/**
+ * XML_SCHEMAS_ELEM_FINAL_ABSENT:
+ *
+ * substitution group exclusions are absent
+ */
+#define XML_SCHEMAS_ELEM_FINAL_ABSENT        1 << 14
+/**
+ * XML_SCHEMAS_ELEM_FINAL_EXTENSION:
+ *
+ * substitution group exclusions: "extension"
+ */
+#define XML_SCHEMAS_ELEM_FINAL_EXTENSION        1 << 15
+/**
+ * XML_SCHEMAS_ELEM_FINAL_RESTRICTION:
+ *
+ * substitution group exclusions: "restriction"
+ */
+#define XML_SCHEMAS_ELEM_FINAL_RESTRICTION        1 << 16
+/**
+ * XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD:
+ *
+ * the declaration is a substitution group head
+ */
+#define XML_SCHEMAS_ELEM_SUBST_GROUP_HEAD        1 << 17
+/**
+ * XML_SCHEMAS_ELEM_INTERNAL_CHECKED:
+ *
+ * this is set when the elem decl has been checked against
+ * all constraints
+ */
+#define XML_SCHEMAS_ELEM_INTERNAL_CHECKED        1 << 18
+
+typedef struct _xmlSchemaElement xmlSchemaElement;
+typedef xmlSchemaElement *xmlSchemaElementPtr;
+struct _xmlSchemaElement {
+    xmlSchemaTypeType type; /* The kind of type */
+    struct _xmlSchemaType *next; /* Not used? */
+    const xmlChar *name;
+    const xmlChar *id; /* Deprecated; not used */
+    const xmlChar *ref; /* Deprecated; not used */
+    const xmlChar *refNs; /* Deprecated; not used */
+    xmlSchemaAnnotPtr annot;
+    xmlSchemaTypePtr subtypes; /* the type definition */
+    xmlSchemaAttributePtr attributes;
+    xmlNodePtr node;
+    int minOccurs; /* Deprecated; not used */
+    int maxOccurs; /* Deprecated; not used */
+
+    int flags;
+    const xmlChar *targetNamespace;
+    const xmlChar *namedType;
+    const xmlChar *namedTypeNs;
+    const xmlChar *substGroup;
+    const xmlChar *substGroupNs;
+    const xmlChar *scope;
+    const xmlChar *value; /* The original value of the value constraint. */
+    struct _xmlSchemaElement *refDecl; /* This will now be used for the
+                                          substitution group affiliation */
+    xmlRegexpPtr contModel; /* Obsolete for WXS, maybe used for RelaxNG */
+    xmlSchemaContentType contentType;
+    const xmlChar *refPrefix; /* Deprecated; not used */
+    xmlSchemaValPtr defVal; /* The compiled value contraint. */
+    void *idcs; /* The identity-constraint defs */
+};
+
+/*
+ * XML_SCHEMAS_FACET_UNKNOWN:
+ *
+ * unknown facet handling
+ */
+#define XML_SCHEMAS_FACET_UNKNOWN        0
+/*
+ * XML_SCHEMAS_FACET_PRESERVE:
+ *
+ * preserve the type of the facet
+ */
+#define XML_SCHEMAS_FACET_PRESERVE        1
+/*
+ * XML_SCHEMAS_FACET_REPLACE:
+ *
+ * replace the type of the facet
+ */
+#define XML_SCHEMAS_FACET_REPLACE        2
+/*
+ * XML_SCHEMAS_FACET_COLLAPSE:
+ *
+ * collapse the types of the facet
+ */
+#define XML_SCHEMAS_FACET_COLLAPSE        3
+/**
+ * A facet definition.
+ */
+struct _xmlSchemaFacet {
+    xmlSchemaTypeType type;        /* The kind of type */
+    struct _xmlSchemaFacet *next;/* the next type if in a sequence ... */
+    const xmlChar *value; /* The original value */
+    const xmlChar *id; /* Obsolete */
+    xmlSchemaAnnotPtr annot;
+    xmlNodePtr node;
+    int fixed; /* XML_SCHEMAS_FACET_PRESERVE, etc. */
+    int whitespace;
+    xmlSchemaValPtr val; /* The compiled value */
+    xmlRegexpPtr    regexp; /* The regex for patterns */
+};
+
+/**
+ * A notation definition.
+ */
+typedef struct _xmlSchemaNotation xmlSchemaNotation;
+typedef xmlSchemaNotation *xmlSchemaNotationPtr;
+struct _xmlSchemaNotation {
+    xmlSchemaTypeType type; /* The kind of type */
+    const xmlChar *name;
+    xmlSchemaAnnotPtr annot;
+    const xmlChar *identifier;
+    const xmlChar *targetNamespace;
+};
+
+/*
+* TODO: Actually all those flags used for the schema should sit
+* on the schema parser context, since they are used only
+* during parsing an XML schema document, and not available
+* on the component level as per spec.
+*/
+/**
+ * XML_SCHEMAS_QUALIF_ELEM:
+ *
+ * Reflects elementFormDefault == qualified in
+ * an XML schema document.
+ */
+#define XML_SCHEMAS_QUALIF_ELEM                1 << 0
+/**
+ * XML_SCHEMAS_QUALIF_ATTR:
+ *
+ * Reflects attributeFormDefault == qualified in
+ * an XML schema document.
+ */
+#define XML_SCHEMAS_QUALIF_ATTR            1 << 1
+/**
+ * XML_SCHEMAS_FINAL_DEFAULT_EXTENSION:
+ *
+ * the schema has "extension" in the set of finalDefault.
+ */
+#define XML_SCHEMAS_FINAL_DEFAULT_EXTENSION        1 << 2
+/**
+ * XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION:
+ *
+ * the schema has "restriction" in the set of finalDefault.
+ */
+#define XML_SCHEMAS_FINAL_DEFAULT_RESTRICTION            1 << 3
+/**
+ * XML_SCHEMAS_FINAL_DEFAULT_LIST:
+ *
+ * the cshema has "list" in the set of finalDefault.
+ */
+#define XML_SCHEMAS_FINAL_DEFAULT_LIST            1 << 4
+/**
+ * XML_SCHEMAS_FINAL_DEFAULT_UNION:
+ *
+ * the schema has "union" in the set of finalDefault.
+ */
+#define XML_SCHEMAS_FINAL_DEFAULT_UNION            1 << 5
+/**
+ * XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION:
+ *
+ * the schema has "extension" in the set of blockDefault.
+ */
+#define XML_SCHEMAS_BLOCK_DEFAULT_EXTENSION            1 << 6
+/**
+ * XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION:
+ *
+ * the schema has "restriction" in the set of blockDefault.
+ */
+#define XML_SCHEMAS_BLOCK_DEFAULT_RESTRICTION            1 << 7
+/**
+ * XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION:
+ *
+ * the schema has "substitution" in the set of blockDefault.
+ */
+#define XML_SCHEMAS_BLOCK_DEFAULT_SUBSTITUTION            1 << 8
+/**
+ * XML_SCHEMAS_INCLUDING_CONVERT_NS:
+ *
+ * the schema is currently including an other schema with
+ * no target namespace.
+ */
+#define XML_SCHEMAS_INCLUDING_CONVERT_NS            1 << 9
+/**
+ * _xmlSchema:
+ *
+ * A Schemas definition
+ */
+struct _xmlSchema {
+    const xmlChar *name; /* schema name */
+    const xmlChar *targetNamespace; /* the target namespace */
+    const xmlChar *version;
+    const xmlChar *id; /* Obsolete */
+    xmlDocPtr doc;
+    xmlSchemaAnnotPtr annot;
+    int flags;
+
+    xmlHashTablePtr typeDecl;
+    xmlHashTablePtr attrDecl;
+    xmlHashTablePtr attrgrpDecl;
+    xmlHashTablePtr elemDecl;
+    xmlHashTablePtr notaDecl;
+
+    xmlHashTablePtr schemasImports;
+
+    void *_private;        /* unused by the library for users or bindings */
+    xmlHashTablePtr groupDecl;
+    xmlDictPtr      dict;
+    void *includes;     /* the includes, this is opaque for now */
+    int preserve;        /* whether to free the document */
+    int counter; /* used to give ononymous components unique names */
+    xmlHashTablePtr idcDef; /* All identity-constraint defs. */
+    void *volatiles; /* Obsolete */
+};
+
+XMLPUBFUN void XMLCALL         xmlSchemaFreeType        (xmlSchemaTypePtr type);
+XMLPUBFUN void XMLCALL         xmlSchemaFreeWildcard(xmlSchemaWildcardPtr wildcard);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_SCHEMAS_ENABLED */
+#endif /* __XML_SCHEMA_INTERNALS_H__ */
diff -Naur orig.ns-2.33/libxml/schematron.h ns-2.33/libxml/schematron.h
--- orig.ns-2.33/libxml/schematron.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/schematron.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,124 @@
+/*
+ * Summary: XML Schemastron implementation
+ * Description: interface to the XML Schematron validity checking.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_SCHEMATRON_H__
+#define __XML_SCHEMATRON_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_SCHEMATRON_ENABLED
+
+#include <libxml/tree.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    XML_SCHEMATRON_OUT_QUIET = 1 << 0,	/* quiet no report */
+    XML_SCHEMATRON_OUT_TEXT = 1 << 1,	/* build a textual report */
+    XML_SCHEMATRON_OUT_XML = 1 << 2,	/* output SVRL */
+    XML_SCHEMATRON_OUT_FILE = 1 << 8,	/* output to a file descriptor */
+    XML_SCHEMATRON_OUT_BUFFER = 1 << 9,	/* output to a buffer */
+    XML_SCHEMATRON_OUT_IO = 1 << 10	/* output to I/O mechanism */
+} xmlSchematronValidOptions;
+
+/**
+ * The schemas related types are kept internal
+ */
+typedef struct _xmlSchematron xmlSchematron;
+typedef xmlSchematron *xmlSchematronPtr;
+
+/**
+ * A schemas validation context
+ */
+typedef void (*xmlSchematronValidityErrorFunc) (void *ctx, const char *msg, ...);
+typedef void (*xmlSchematronValidityWarningFunc) (void *ctx, const char *msg, ...);
+
+typedef struct _xmlSchematronParserCtxt xmlSchematronParserCtxt;
+typedef xmlSchematronParserCtxt *xmlSchematronParserCtxtPtr;
+
+typedef struct _xmlSchematronValidCtxt xmlSchematronValidCtxt;
+typedef xmlSchematronValidCtxt *xmlSchematronValidCtxtPtr;
+
+/*
+ * Interfaces for parsing.
+ */
+XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL 
+	    xmlSchematronNewParserCtxt	(const char *URL);
+XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL 
+	    xmlSchematronNewMemParserCtxt(const char *buffer,
+					 int size);
+XMLPUBFUN xmlSchematronParserCtxtPtr XMLCALL
+	    xmlSchematronNewDocParserCtxt(xmlDocPtr doc);
+XMLPUBFUN void XMLCALL		
+	    xmlSchematronFreeParserCtxt	(xmlSchematronParserCtxtPtr ctxt);
+/*****
+XMLPUBFUN void XMLCALL		
+	    xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,
+					 xmlSchematronValidityErrorFunc err,
+					 xmlSchematronValidityWarningFunc warn,
+					 void *ctx);
+XMLPUBFUN int XMLCALL
+		xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,
+					xmlSchematronValidityErrorFunc * err,
+					xmlSchematronValidityWarningFunc * warn,
+					void **ctx);
+XMLPUBFUN int XMLCALL
+		xmlSchematronIsValid	(xmlSchematronValidCtxtPtr ctxt);
+ *****/
+XMLPUBFUN xmlSchematronPtr XMLCALL	
+	    xmlSchematronParse		(xmlSchematronParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL		
+	    xmlSchematronFree		(xmlSchematronPtr schema);
+/*
+ * Interfaces for validating
+ */
+/******
+XMLPUBFUN void XMLCALL
+	    xmlSchematronSetValidStructuredErrors(
+	                                  xmlSchematronValidCtxtPtr ctxt,
+					  xmlStructuredErrorFunc serror,
+					  void *ctx);
+XMLPUBFUN void XMLCALL		
+	    xmlSchematronSetValidErrors	(xmlSchematronValidCtxtPtr ctxt,
+					 xmlSchematronValidityErrorFunc err,
+					 xmlSchematronValidityWarningFunc warn,
+					 void *ctx);
+XMLPUBFUN int XMLCALL
+	    xmlSchematronGetValidErrors	(xmlSchematronValidCtxtPtr ctxt,
+					 xmlSchematronValidityErrorFunc *err,
+					 xmlSchematronValidityWarningFunc *warn,
+					 void **ctx);
+XMLPUBFUN int XMLCALL
+	    xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,
+					 int options);
+XMLPUBFUN int XMLCALL
+	    xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+            xmlSchematronValidateOneElement (xmlSchematronValidCtxtPtr ctxt,
+			                 xmlNodePtr elem);
+ *******/
+
+XMLPUBFUN xmlSchematronValidCtxtPtr XMLCALL	
+	    xmlSchematronNewValidCtxt	(xmlSchematronPtr schema,
+	    				 int options);
+XMLPUBFUN void XMLCALL			
+	    xmlSchematronFreeValidCtxt	(xmlSchematronValidCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+	    xmlSchematronValidateDoc	(xmlSchematronValidCtxtPtr ctxt,
+					 xmlDocPtr instance);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_SCHEMATRON_ENABLED */
+#endif /* __XML_SCHEMATRON_H__ */
diff -Naur orig.ns-2.33/libxml/threads.h ns-2.33/libxml/threads.h
--- orig.ns-2.33/libxml/threads.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/threads.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,84 @@
+/**
+ * Summary: interfaces for thread handling
+ * Description: set of generic threading related routines
+ *              should work with pthreads, Windows native or TLS threads
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_THREADS_H__
+#define __XML_THREADS_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * xmlMutex are a simple mutual exception locks.
+ */
+typedef struct _xmlMutex xmlMutex;
+typedef xmlMutex *xmlMutexPtr;
+
+/*
+ * xmlRMutex are reentrant mutual exception locks.
+ */
+typedef struct _xmlRMutex xmlRMutex;
+typedef xmlRMutex *xmlRMutexPtr;
+
+#ifdef __cplusplus
+}
+#endif
+#include <libxml/globals.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+XMLPUBFUN xmlMutexPtr XMLCALL		
+			xmlNewMutex	(void);
+XMLPUBFUN void XMLCALL			
+			xmlMutexLock	(xmlMutexPtr tok);
+XMLPUBFUN void XMLCALL			
+			xmlMutexUnlock	(xmlMutexPtr tok);
+XMLPUBFUN void XMLCALL			
+			xmlFreeMutex	(xmlMutexPtr tok);
+
+XMLPUBFUN xmlRMutexPtr XMLCALL		
+			xmlNewRMutex	(void);
+XMLPUBFUN void XMLCALL			
+			xmlRMutexLock	(xmlRMutexPtr tok);
+XMLPUBFUN void XMLCALL			
+			xmlRMutexUnlock	(xmlRMutexPtr tok);
+XMLPUBFUN void XMLCALL			
+			xmlFreeRMutex	(xmlRMutexPtr tok);
+
+/*
+ * Library wide APIs.
+ */
+XMLPUBFUN void XMLCALL			
+			xmlInitThreads	(void);
+XMLPUBFUN void XMLCALL			
+			xmlLockLibrary	(void);
+XMLPUBFUN void XMLCALL			
+			xmlUnlockLibrary(void);
+XMLPUBFUN int XMLCALL			
+			xmlGetThreadId	(void);
+XMLPUBFUN int XMLCALL			
+			xmlIsMainThread	(void);
+XMLPUBFUN void XMLCALL			
+			xmlCleanupThreads(void);
+XMLPUBFUN xmlGlobalStatePtr XMLCALL	
+			xmlGetGlobalState(void);
+
+#if defined(HAVE_WIN32_THREADS) && !defined(HAVE_COMPILER_TLS) && defined(LIBXML_STATIC_FOR_DLL)
+int XMLCALL xmlDllMain(void *hinstDLL, unsigned long fdwReason, void *lpvReserved);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* __XML_THREADS_H__ */
diff -Naur orig.ns-2.33/libxml/tree.h ns-2.33/libxml/tree.h
--- orig.ns-2.33/libxml/tree.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/tree.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,1213 @@
+/*
+ * Summary: interfaces for tree manipulation
+ * Description: this module describes the structures found in an tree resulting
+ *              from an XML or HTML parsing, as well as the API provided for
+ *              various processing on that tree
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_TREE_H__
+#define __XML_TREE_H__
+
+#include <stdio.h>
+#include <libxml/xmlversion.h>
+#include <libxml/xmlstring.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Some of the basic types pointer to structures:
+ */
+/* xmlIO.h */
+typedef struct _xmlParserInputBuffer xmlParserInputBuffer;
+typedef xmlParserInputBuffer *xmlParserInputBufferPtr;
+
+typedef struct _xmlOutputBuffer xmlOutputBuffer;
+typedef xmlOutputBuffer *xmlOutputBufferPtr;
+
+/* parser.h */
+typedef struct _xmlParserInput xmlParserInput;
+typedef xmlParserInput *xmlParserInputPtr;
+
+typedef struct _xmlParserCtxt xmlParserCtxt;
+typedef xmlParserCtxt *xmlParserCtxtPtr;
+
+typedef struct _xmlSAXLocator xmlSAXLocator;
+typedef xmlSAXLocator *xmlSAXLocatorPtr;
+
+typedef struct _xmlSAXHandler xmlSAXHandler;
+typedef xmlSAXHandler *xmlSAXHandlerPtr;
+
+/* entities.h */
+typedef struct _xmlEntity xmlEntity;
+typedef xmlEntity *xmlEntityPtr;
+
+/**
+ * BASE_BUFFER_SIZE:
+ *
+ * default buffer size 4000.
+ */
+#define BASE_BUFFER_SIZE 4096
+
+/**
+ * LIBXML_NAMESPACE_DICT:
+ *
+ * Defines experimental behaviour:
+ * 1) xmlNs gets an additional field @context (a xmlDoc)
+ * 2) when creating a tree, xmlNs->href is stored in the dict of xmlDoc.
+ */
+/* #define LIBXML_NAMESPACE_DICT */
+
+/**
+ * xmlBufferAllocationScheme:
+ *
+ * A buffer allocation scheme can be defined to either match exactly the
+ * need or double it's allocated size each time it is found too small.
+ */
+
+typedef enum {
+    XML_BUFFER_ALLOC_DOUBLEIT,
+    XML_BUFFER_ALLOC_EXACT,
+    XML_BUFFER_ALLOC_IMMUTABLE
+} xmlBufferAllocationScheme;
+
+/**
+ * xmlBuffer:
+ *
+ * A buffer structure.
+ */
+typedef struct _xmlBuffer xmlBuffer;
+typedef xmlBuffer *xmlBufferPtr;
+struct _xmlBuffer {
+    xmlChar *content;		/* The buffer content UTF8 */
+    unsigned int use;		/* The buffer size used */
+    unsigned int size;		/* The buffer size */
+    xmlBufferAllocationScheme alloc; /* The realloc method */
+};
+
+/**
+ * XML_XML_NAMESPACE:
+ *
+ * This is the namespace for the special xml: prefix predefined in the
+ * XML Namespace specification.
+ */
+#define XML_XML_NAMESPACE \
+    (const xmlChar *) "http://www.w3.org/XML/1998/namespace"
+
+/**
+ * XML_XML_ID:
+ *
+ * This is the name for the special xml:id attribute
+ */
+#define XML_XML_ID (const xmlChar *) "xml:id"
+
+/*
+ * The different element types carried by an XML tree.
+ *
+ * NOTE: This is synchronized with DOM Level1 values
+ *       See http://www.w3.org/TR/REC-DOM-Level-1/
+ *
+ * Actually this had diverged a bit, and now XML_DOCUMENT_TYPE_NODE should
+ * be deprecated to use an XML_DTD_NODE.
+ */
+typedef enum {
+    XML_ELEMENT_NODE=		1,
+    XML_ATTRIBUTE_NODE=		2,
+    XML_TEXT_NODE=		3,
+    XML_CDATA_SECTION_NODE=	4,
+    XML_ENTITY_REF_NODE=	5,
+    XML_ENTITY_NODE=		6,
+    XML_PI_NODE=		7,
+    XML_COMMENT_NODE=		8,
+    XML_DOCUMENT_NODE=		9,
+    XML_DOCUMENT_TYPE_NODE=	10,
+    XML_DOCUMENT_FRAG_NODE=	11,
+    XML_NOTATION_NODE=		12,
+    XML_HTML_DOCUMENT_NODE=	13,
+    XML_DTD_NODE=		14,
+    XML_ELEMENT_DECL=		15,
+    XML_ATTRIBUTE_DECL=		16,
+    XML_ENTITY_DECL=		17,
+    XML_NAMESPACE_DECL=		18,
+    XML_XINCLUDE_START=		19,
+    XML_XINCLUDE_END=		20
+#ifdef LIBXML_DOCB_ENABLED
+   ,XML_DOCB_DOCUMENT_NODE=	21
+#endif
+} xmlElementType;
+
+
+/**
+ * xmlNotation:
+ *
+ * A DTD Notation definition.
+ */
+
+typedef struct _xmlNotation xmlNotation;
+typedef xmlNotation *xmlNotationPtr;
+struct _xmlNotation {
+    const xmlChar               *name;	        /* Notation name */
+    const xmlChar               *PublicID;	/* Public identifier, if any */
+    const xmlChar               *SystemID;	/* System identifier, if any */
+};
+
+/**
+ * xmlAttributeType:
+ *
+ * A DTD Attribute type definition.
+ */
+
+typedef enum {
+    XML_ATTRIBUTE_CDATA = 1,
+    XML_ATTRIBUTE_ID,
+    XML_ATTRIBUTE_IDREF	,
+    XML_ATTRIBUTE_IDREFS,
+    XML_ATTRIBUTE_ENTITY,
+    XML_ATTRIBUTE_ENTITIES,
+    XML_ATTRIBUTE_NMTOKEN,
+    XML_ATTRIBUTE_NMTOKENS,
+    XML_ATTRIBUTE_ENUMERATION,
+    XML_ATTRIBUTE_NOTATION
+} xmlAttributeType;
+
+/**
+ * xmlAttributeDefault:
+ *
+ * A DTD Attribute default definition.
+ */
+
+typedef enum {
+    XML_ATTRIBUTE_NONE = 1,
+    XML_ATTRIBUTE_REQUIRED,
+    XML_ATTRIBUTE_IMPLIED,
+    XML_ATTRIBUTE_FIXED
+} xmlAttributeDefault;
+
+/**
+ * xmlEnumeration:
+ *
+ * List structure used when there is an enumeration in DTDs.
+ */
+
+typedef struct _xmlEnumeration xmlEnumeration;
+typedef xmlEnumeration *xmlEnumerationPtr;
+struct _xmlEnumeration {
+    struct _xmlEnumeration    *next;	/* next one */
+    const xmlChar            *name;	/* Enumeration name */
+};
+
+/**
+ * xmlAttribute:
+ *
+ * An Attribute declaration in a DTD.
+ */
+
+typedef struct _xmlAttribute xmlAttribute;
+typedef xmlAttribute *xmlAttributePtr;
+struct _xmlAttribute {
+    void           *_private;	        /* application data */
+    xmlElementType          type;       /* XML_ATTRIBUTE_DECL, must be second ! */
+    const xmlChar          *name;	/* Attribute name */
+    struct _xmlNode    *children;	/* NULL */
+    struct _xmlNode        *last;	/* NULL */
+    struct _xmlDtd       *parent;	/* -> DTD */
+    struct _xmlNode        *next;	/* next sibling link  */
+    struct _xmlNode        *prev;	/* previous sibling link  */
+    struct _xmlDoc          *doc;       /* the containing document */
+
+    struct _xmlAttribute  *nexth;	/* next in hash table */
+    xmlAttributeType       atype;	/* The attribute type */
+    xmlAttributeDefault      def;	/* the default */
+    const xmlChar  *defaultValue;	/* or the default value */
+    xmlEnumerationPtr       tree;       /* or the enumeration tree if any */
+    const xmlChar        *prefix;	/* the namespace prefix if any */
+    const xmlChar          *elem;	/* Element holding the attribute */
+};
+
+/**
+ * xmlElementContentType:
+ *
+ * Possible definitions of element content types.
+ */
+typedef enum {
+    XML_ELEMENT_CONTENT_PCDATA = 1,
+    XML_ELEMENT_CONTENT_ELEMENT,
+    XML_ELEMENT_CONTENT_SEQ,
+    XML_ELEMENT_CONTENT_OR
+} xmlElementContentType;
+
+/**
+ * xmlElementContentOccur:
+ *
+ * Possible definitions of element content occurrences.
+ */
+typedef enum {
+    XML_ELEMENT_CONTENT_ONCE = 1,
+    XML_ELEMENT_CONTENT_OPT,
+    XML_ELEMENT_CONTENT_MULT,
+    XML_ELEMENT_CONTENT_PLUS
+} xmlElementContentOccur;
+
+/**
+ * xmlElementContent:
+ *
+ * An XML Element content as stored after parsing an element definition
+ * in a DTD.
+ */
+
+typedef struct _xmlElementContent xmlElementContent;
+typedef xmlElementContent *xmlElementContentPtr;
+struct _xmlElementContent {
+    xmlElementContentType     type;	/* PCDATA, ELEMENT, SEQ or OR */
+    xmlElementContentOccur    ocur;	/* ONCE, OPT, MULT or PLUS */
+    const xmlChar             *name;	/* Element name */
+    struct _xmlElementContent *c1;	/* first child */
+    struct _xmlElementContent *c2;	/* second child */
+    struct _xmlElementContent *parent;	/* parent */
+    const xmlChar             *prefix;	/* Namespace prefix */
+};
+
+/**
+ * xmlElementTypeVal:
+ *
+ * The different possibilities for an element content type.
+ */
+
+typedef enum {
+    XML_ELEMENT_TYPE_UNDEFINED = 0,
+    XML_ELEMENT_TYPE_EMPTY = 1,
+    XML_ELEMENT_TYPE_ANY,
+    XML_ELEMENT_TYPE_MIXED,
+    XML_ELEMENT_TYPE_ELEMENT
+} xmlElementTypeVal;
+
+#ifdef __cplusplus
+}
+#endif
+#include <libxml/xmlregexp.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlElement:
+ *
+ * An XML Element declaration from a DTD.
+ */
+
+typedef struct _xmlElement xmlElement;
+typedef xmlElement *xmlElementPtr;
+struct _xmlElement {
+    void           *_private;	        /* application data */
+    xmlElementType          type;       /* XML_ELEMENT_DECL, must be second ! */
+    const xmlChar          *name;	/* Element name */
+    struct _xmlNode    *children;	/* NULL */
+    struct _xmlNode        *last;	/* NULL */
+    struct _xmlDtd       *parent;	/* -> DTD */
+    struct _xmlNode        *next;	/* next sibling link  */
+    struct _xmlNode        *prev;	/* previous sibling link  */
+    struct _xmlDoc          *doc;       /* the containing document */
+
+    xmlElementTypeVal      etype;	/* The type */
+    xmlElementContentPtr content;	/* the allowed element content */
+    xmlAttributePtr   attributes;	/* List of the declared attributes */
+    const xmlChar        *prefix;	/* the namespace prefix if any */
+#ifdef LIBXML_REGEXP_ENABLED
+    xmlRegexpPtr       contModel;	/* the validating regexp */
+#else
+    void	      *contModel;
+#endif
+};
+
+
+/**
+ * XML_LOCAL_NAMESPACE:
+ *
+ * A namespace declaration node.
+ */
+#define XML_LOCAL_NAMESPACE XML_NAMESPACE_DECL
+typedef xmlElementType xmlNsType;
+
+/**
+ * xmlNs:
+ *
+ * An XML namespace.
+ * Note that prefix == NULL is valid, it defines the default namespace
+ * within the subtree (until overridden).
+ *
+ * xmlNsType is unified with xmlElementType.
+ */
+
+typedef struct _xmlNs xmlNs;
+typedef xmlNs *xmlNsPtr;
+struct _xmlNs {
+    struct _xmlNs  *next;	/* next Ns link for this node  */
+    xmlNsType      type;	/* global or local */
+    const xmlChar *href;	/* URL for the namespace */
+    const xmlChar *prefix;	/* prefix for the namespace */
+    void           *_private;   /* application data */
+    struct _xmlDoc *context;		/* normally an xmlDoc */
+};
+
+/**
+ * xmlDtd:
+ *
+ * An XML DTD, as defined by <!DOCTYPE ... There is actually one for
+ * the internal subset and for the external subset.
+ */
+typedef struct _xmlDtd xmlDtd;
+typedef xmlDtd *xmlDtdPtr;
+struct _xmlDtd {
+    void           *_private;	/* application data */
+    xmlElementType  type;       /* XML_DTD_NODE, must be second ! */
+    const xmlChar *name;	/* Name of the DTD */
+    struct _xmlNode *children;	/* the value of the property link */
+    struct _xmlNode *last;	/* last child link */
+    struct _xmlDoc  *parent;	/* child->parent link */
+    struct _xmlNode *next;	/* next sibling link  */
+    struct _xmlNode *prev;	/* previous sibling link  */
+    struct _xmlDoc  *doc;	/* the containing document */
+
+    /* End of common part */
+    void          *notations;   /* Hash table for notations if any */
+    void          *elements;    /* Hash table for elements if any */
+    void          *attributes;  /* Hash table for attributes if any */
+    void          *entities;    /* Hash table for entities if any */
+    const xmlChar *ExternalID;	/* External identifier for PUBLIC DTD */
+    const xmlChar *SystemID;	/* URI for a SYSTEM or PUBLIC DTD */
+    void          *pentities;   /* Hash table for param entities if any */
+};
+
+/**
+ * xmlAttr:
+ *
+ * An attribute on an XML node.
+ */
+typedef struct _xmlAttr xmlAttr;
+typedef xmlAttr *xmlAttrPtr;
+struct _xmlAttr {
+    void           *_private;	/* application data */
+    xmlElementType   type;      /* XML_ATTRIBUTE_NODE, must be second ! */
+    const xmlChar   *name;      /* the name of the property */
+    struct _xmlNode *children;	/* the value of the property */
+    struct _xmlNode *last;	/* NULL */
+    struct _xmlNode *parent;	/* child->parent link */
+    struct _xmlAttr *next;	/* next sibling link  */
+    struct _xmlAttr *prev;	/* previous sibling link  */
+    struct _xmlDoc  *doc;	/* the containing document */
+    xmlNs           *ns;        /* pointer to the associated namespace */
+    xmlAttributeType atype;     /* the attribute type if validating */
+    void            *psvi;	/* for type/PSVI informations */
+};
+
+/**
+ * xmlID:
+ *
+ * An XML ID instance.
+ */
+
+typedef struct _xmlID xmlID;
+typedef xmlID *xmlIDPtr;
+struct _xmlID {
+    struct _xmlID    *next;	/* next ID */
+    const xmlChar    *value;	/* The ID name */
+    xmlAttrPtr        attr;	/* The attribute holding it */
+    const xmlChar    *name;	/* The attribute if attr is not available */
+    int               lineno;	/* The line number if attr is not available */
+    struct _xmlDoc   *doc;	/* The document holding the ID */
+};
+
+/**
+ * xmlRef:
+ *
+ * An XML IDREF instance.
+ */
+
+typedef struct _xmlRef xmlRef;
+typedef xmlRef *xmlRefPtr;
+struct _xmlRef {
+    struct _xmlRef    *next;	/* next Ref */
+    const xmlChar     *value;	/* The Ref name */
+    xmlAttrPtr        attr;	/* The attribute holding it */
+    const xmlChar    *name;	/* The attribute if attr is not available */
+    int               lineno;	/* The line number if attr is not available */
+};
+
+/**
+ * xmlNode:
+ *
+ * A node in an XML tree.
+ */
+typedef struct _xmlNode xmlNode;
+typedef xmlNode *xmlNodePtr;
+struct _xmlNode {
+    void           *_private;	/* application data */
+    xmlElementType   type;	/* type number, must be second ! */
+    const xmlChar   *name;      /* the name of the node, or the entity */
+    struct _xmlNode *children;	/* parent->childs link */
+    struct _xmlNode *last;	/* last child link */
+    struct _xmlNode *parent;	/* child->parent link */
+    struct _xmlNode *next;	/* next sibling link  */
+    struct _xmlNode *prev;	/* previous sibling link  */
+    struct _xmlDoc  *doc;	/* the containing document */
+
+    /* End of common part */
+    xmlNs           *ns;        /* pointer to the associated namespace */
+    xmlChar         *content;   /* the content */
+    struct _xmlAttr *properties;/* properties list */
+    xmlNs           *nsDef;     /* namespace definitions on this node */
+    void            *psvi;	/* for type/PSVI informations */
+    unsigned short   line;	/* line number */
+    unsigned short   extra;	/* extra data for XPath/XSLT */
+};
+
+/**
+ * XML_GET_CONTENT:
+ *
+ * Macro to extract the content pointer of a node.
+ */
+#define XML_GET_CONTENT(n)					\
+    ((n)->type == XML_ELEMENT_NODE ? NULL : (n)->content)
+
+/**
+ * XML_GET_LINE:
+ *
+ * Macro to extract the line number of an element node. 
+ */
+#define XML_GET_LINE(n)						\
+    (xmlGetLineNo(n))
+
+
+/**
+ * xmlDoc:
+ *
+ * An XML document.
+ */
+typedef struct _xmlDoc xmlDoc;
+typedef xmlDoc *xmlDocPtr;
+struct _xmlDoc {
+    void           *_private;	/* application data */
+    xmlElementType  type;       /* XML_DOCUMENT_NODE, must be second ! */
+    char           *name;	/* name/filename/URI of the document */
+    struct _xmlNode *children;	/* the document tree */
+    struct _xmlNode *last;	/* last child link */
+    struct _xmlNode *parent;	/* child->parent link */
+    struct _xmlNode *next;	/* next sibling link  */
+    struct _xmlNode *prev;	/* previous sibling link  */
+    struct _xmlDoc  *doc;	/* autoreference to itself */
+
+    /* End of common part */
+    int             compression;/* level of zlib compression */
+    int             standalone; /* standalone document (no external refs) 
+				     1 if standalone="yes"
+				     0 if standalone="no"
+				    -1 if there is no XML declaration
+				    -2 if there is an XML declaration, but no
+					standalone attribute was specified */
+    struct _xmlDtd  *intSubset;	/* the document internal subset */
+    struct _xmlDtd  *extSubset;	/* the document external subset */
+    struct _xmlNs   *oldNs;	/* Global namespace, the old way */
+    const xmlChar  *version;	/* the XML version string */
+    const xmlChar  *encoding;   /* external initial encoding, if any */
+    void           *ids;        /* Hash table for ID attributes if any */
+    void           *refs;       /* Hash table for IDREFs attributes if any */
+    const xmlChar  *URL;	/* The URI for that document */
+    int             charset;    /* encoding of the in-memory content
+				   actually an xmlCharEncoding */
+    struct _xmlDict *dict;      /* dict used to allocate names or NULL */
+    void           *psvi;	/* for type/PSVI informations */
+};
+
+
+typedef struct _xmlDOMWrapCtxt xmlDOMWrapCtxt;
+typedef xmlDOMWrapCtxt *xmlDOMWrapCtxtPtr;
+
+/**
+ * xmlDOMWrapAcquireNsFunction:
+ * @ctxt:  a DOM wrapper context
+ * @node:  the context node (element or attribute) 
+ * @nsName:  the requested namespace name
+ * @nsPrefix:  the requested namespace prefix 
+ *
+ * A function called to acquire namespaces (xmlNs) from the wrapper.
+ *
+ * Returns an xmlNsPtr or NULL in case of an error.
+ */
+typedef xmlNsPtr (*xmlDOMWrapAcquireNsFunction) (xmlDOMWrapCtxtPtr ctxt,
+						 xmlNodePtr node,
+						 const xmlChar *nsName,
+						 const xmlChar *nsPrefix);
+
+/**
+ * xmlDOMWrapCtxt:
+ *
+ * Context for DOM wrapper-operations.
+ */
+struct _xmlDOMWrapCtxt {
+    void * _private;
+    /*
+    * The type of this context, just in case we need specialized
+    * contexts in the future.
+    */
+    int type;
+    /*
+    * Internal namespace map used for various operations.
+    */
+    void * namespaceMap;
+    /*
+    * Use this one to acquire an xmlNsPtr intended for node->ns.
+    * (Note that this is not intended for elem->nsDef).
+    */
+    xmlDOMWrapAcquireNsFunction getNsForNodeFunc;
+};
+
+/**
+ * xmlChildrenNode:
+ *
+ * Macro for compatibility naming layer with libxml1. Maps
+ * to "children."
+ */
+#ifndef xmlChildrenNode
+#define xmlChildrenNode children
+#endif
+
+/**
+ * xmlRootNode:
+ *
+ * Macro for compatibility naming layer with libxml1. Maps 
+ * to "children".
+ */
+#ifndef xmlRootNode
+#define xmlRootNode children
+#endif
+
+/*
+ * Variables.
+ */
+
+/*
+ * Some helper functions
+ */
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_DEBUG_ENABLED) || defined (LIBXML_HTML_ENABLED) || defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_DOCB_ENABLED)
+XMLPUBFUN int XMLCALL
+		xmlValidateNCName	(const xmlChar *value,
+					 int space);
+#endif
+
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN int XMLCALL		
+		xmlValidateQName	(const xmlChar *value,
+					 int space);
+XMLPUBFUN int XMLCALL		
+		xmlValidateName		(const xmlChar *value,
+					 int space);
+XMLPUBFUN int XMLCALL		
+		xmlValidateNMToken	(const xmlChar *value,
+					 int space);
+#endif
+
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlBuildQName		(const xmlChar *ncname,
+					 const xmlChar *prefix,
+					 xmlChar *memory,
+					 int len);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlSplitQName2		(const xmlChar *name,
+					 xmlChar **prefix);
+XMLPUBFUN const xmlChar * XMLCALL	
+		xmlSplitQName3		(const xmlChar *name,
+					 int *len);
+
+/*
+ * Handling Buffers.
+ */
+
+XMLPUBFUN void XMLCALL		
+		xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);
+XMLPUBFUN xmlBufferAllocationScheme XMLCALL	 
+		xmlGetBufferAllocationScheme(void);
+
+XMLPUBFUN xmlBufferPtr XMLCALL	
+		xmlBufferCreate		(void);
+XMLPUBFUN xmlBufferPtr XMLCALL	
+		xmlBufferCreateSize	(size_t size);
+XMLPUBFUN xmlBufferPtr XMLCALL	
+		xmlBufferCreateStatic	(void *mem,
+					 size_t size);
+XMLPUBFUN int XMLCALL		
+		xmlBufferResize		(xmlBufferPtr buf,
+					 unsigned int size);
+XMLPUBFUN void XMLCALL		
+		xmlBufferFree		(xmlBufferPtr buf);
+XMLPUBFUN int XMLCALL		
+		xmlBufferDump		(FILE *file,
+					 xmlBufferPtr buf);
+XMLPUBFUN int XMLCALL		
+		xmlBufferAdd		(xmlBufferPtr buf,
+					 const xmlChar *str,
+					 int len);
+XMLPUBFUN int XMLCALL		
+		xmlBufferAddHead	(xmlBufferPtr buf,
+					 const xmlChar *str,
+					 int len);
+XMLPUBFUN int XMLCALL		
+		xmlBufferCat		(xmlBufferPtr buf,
+					 const xmlChar *str);
+XMLPUBFUN int XMLCALL	
+		xmlBufferCCat		(xmlBufferPtr buf,
+					 const char *str);
+XMLPUBFUN int XMLCALL		
+		xmlBufferShrink		(xmlBufferPtr buf,
+					 unsigned int len);
+XMLPUBFUN int XMLCALL		
+		xmlBufferGrow		(xmlBufferPtr buf,
+					 unsigned int len);
+XMLPUBFUN void XMLCALL		
+		xmlBufferEmpty		(xmlBufferPtr buf);
+XMLPUBFUN const xmlChar* XMLCALL	
+		xmlBufferContent	(const xmlBufferPtr buf);
+XMLPUBFUN void XMLCALL		
+		xmlBufferSetAllocationScheme(xmlBufferPtr buf,
+					 xmlBufferAllocationScheme scheme);
+XMLPUBFUN int XMLCALL		
+		xmlBufferLength		(const xmlBufferPtr buf);
+
+/*
+ * Creating/freeing new structures.
+ */
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlCreateIntSubset	(xmlDocPtr doc,
+					 const xmlChar *name,
+					 const xmlChar *ExternalID,
+					 const xmlChar *SystemID);
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlNewDtd		(xmlDocPtr doc,
+					 const xmlChar *name,
+					 const xmlChar *ExternalID,
+					 const xmlChar *SystemID);
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlGetIntSubset		(xmlDocPtr doc);
+XMLPUBFUN void XMLCALL		
+		xmlFreeDtd		(xmlDtdPtr cur);
+#ifdef LIBXML_LEGACY_ENABLED
+XMLPUBFUN xmlNsPtr XMLCALL	
+		xmlNewGlobalNs		(xmlDocPtr doc,
+					 const xmlChar *href,
+					 const xmlChar *prefix);
+#endif /* LIBXML_LEGACY_ENABLED */
+XMLPUBFUN xmlNsPtr XMLCALL	
+		xmlNewNs		(xmlNodePtr node,
+					 const xmlChar *href,
+					 const xmlChar *prefix);
+XMLPUBFUN void XMLCALL		
+		xmlFreeNs		(xmlNsPtr cur);
+XMLPUBFUN void XMLCALL		
+		xmlFreeNsList		(xmlNsPtr cur);
+XMLPUBFUN xmlDocPtr XMLCALL 	
+		xmlNewDoc		(const xmlChar *version);
+XMLPUBFUN void XMLCALL		
+		xmlFreeDoc		(xmlDocPtr cur);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlNewDocProp		(xmlDocPtr doc,
+					 const xmlChar *name,
+					 const xmlChar *value);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
+    defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlNewProp		(xmlNodePtr node,
+					 const xmlChar *name,
+					 const xmlChar *value);
+#endif
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlNewNsProp		(xmlNodePtr node,
+					 xmlNsPtr ns,
+					 const xmlChar *name,
+					 const xmlChar *value);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlNewNsPropEatName	(xmlNodePtr node,
+					 xmlNsPtr ns,
+					 xmlChar *name,
+					 const xmlChar *value);
+XMLPUBFUN void XMLCALL		
+		xmlFreePropList		(xmlAttrPtr cur);
+XMLPUBFUN void XMLCALL		
+		xmlFreeProp		(xmlAttrPtr cur);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlCopyProp		(xmlNodePtr target,
+					 xmlAttrPtr cur);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlCopyPropList		(xmlNodePtr target,
+					 xmlAttrPtr cur);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlDtdPtr XMLCALL	
+		xmlCopyDtd		(xmlDtdPtr dtd);
+#endif /* LIBXML_TREE_ENABLED */
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN xmlDocPtr XMLCALL	
+		xmlCopyDoc		(xmlDocPtr doc,
+					 int recursive);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
+/*
+ * Creating new nodes.
+ */
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocNode		(xmlDocPtr doc,
+					 xmlNsPtr ns,
+					 const xmlChar *name,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocNodeEatName	(xmlDocPtr doc,
+					 xmlNsPtr ns,
+					 xmlChar *name,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewNode		(xmlNsPtr ns,
+					 const xmlChar *name);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewNodeEatName	(xmlNsPtr ns,
+					 xmlChar *name);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewChild		(xmlNodePtr parent,
+					 xmlNsPtr ns,
+					 const xmlChar *name,
+					 const xmlChar *content);
+#endif
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocText		(xmlDocPtr doc,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewText		(const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocPI		(xmlDocPtr doc,
+					 const xmlChar *name,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewPI		(const xmlChar *name,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocTextLen	(xmlDocPtr doc,
+					 const xmlChar *content,
+					 int len);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewTextLen		(const xmlChar *content,
+					 int len);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocComment	(xmlDocPtr doc,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewComment		(const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewCDataBlock	(xmlDocPtr doc,
+					 const xmlChar *content,
+					 int len);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewCharRef		(xmlDocPtr doc,
+					 const xmlChar *name);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewReference		(xmlDocPtr doc,
+					 const xmlChar *name);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlCopyNode		(const xmlNodePtr node,
+					 int recursive);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlDocCopyNode		(const xmlNodePtr node,
+					 xmlDocPtr doc,
+					 int recursive);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlDocCopyNodeList	(xmlDocPtr doc,
+					 const xmlNodePtr node);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlCopyNodeList		(const xmlNodePtr node);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewTextChild		(xmlNodePtr parent,
+					 xmlNsPtr ns,
+					 const xmlChar *name,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocRawNode	(xmlDocPtr doc,
+					 xmlNsPtr ns,
+					 const xmlChar *name,
+					 const xmlChar *content);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlNewDocFragment	(xmlDocPtr doc);
+#endif /* LIBXML_TREE_ENABLED */
+
+/*
+ * Navigating.
+ */
+XMLPUBFUN long XMLCALL		
+		xmlGetLineNo		(xmlNodePtr node);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlGetNodePath		(xmlNodePtr node);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) */
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlDocGetRootElement	(xmlDocPtr doc);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlGetLastChild		(xmlNodePtr parent);
+XMLPUBFUN int XMLCALL		
+		xmlNodeIsText		(xmlNodePtr node);
+XMLPUBFUN int XMLCALL		
+		xmlIsBlankNode		(xmlNodePtr node);
+
+/*
+ * Changing the structure.
+ */
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlDocSetRootElement	(xmlDocPtr doc,
+					 xmlNodePtr root);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlNodeSetName		(xmlNodePtr cur,
+					 const xmlChar *name);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlAddChild		(xmlNodePtr parent,
+					 xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlAddChildList		(xmlNodePtr parent,
+					 xmlNodePtr cur);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlReplaceNode		(xmlNodePtr old,
+					 xmlNodePtr cur);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) */
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \
+    defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlAddPrevSibling	(xmlNodePtr cur,
+					 xmlNodePtr elem);
+#endif /* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED */
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlAddSibling		(xmlNodePtr cur,
+					 xmlNodePtr elem);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlAddNextSibling	(xmlNodePtr cur,
+					 xmlNodePtr elem);
+XMLPUBFUN void XMLCALL		
+		xmlUnlinkNode		(xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlTextMerge		(xmlNodePtr first,
+					 xmlNodePtr second);
+XMLPUBFUN int XMLCALL		
+		xmlTextConcat		(xmlNodePtr node,
+					 const xmlChar *content,
+					 int len);
+XMLPUBFUN void XMLCALL		
+		xmlFreeNodeList		(xmlNodePtr cur);
+XMLPUBFUN void XMLCALL		
+		xmlFreeNode		(xmlNodePtr cur);
+XMLPUBFUN void XMLCALL		
+		xmlSetTreeDoc		(xmlNodePtr tree,
+					 xmlDocPtr doc);
+XMLPUBFUN void XMLCALL		
+		xmlSetListDoc		(xmlNodePtr list,
+					 xmlDocPtr doc);
+/*
+ * Namespaces.
+ */
+XMLPUBFUN xmlNsPtr XMLCALL	
+		xmlSearchNs		(xmlDocPtr doc,
+					 xmlNodePtr node,
+					 const xmlChar *nameSpace);
+XMLPUBFUN xmlNsPtr XMLCALL	
+		xmlSearchNsByHref	(xmlDocPtr doc,
+					 xmlNodePtr node,
+					 const xmlChar *href);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN xmlNsPtr * XMLCALL	
+		xmlGetNsList		(xmlDocPtr doc,
+					 xmlNodePtr node);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) */
+
+XMLPUBFUN void XMLCALL		
+		xmlSetNs		(xmlNodePtr node,
+					 xmlNsPtr ns);
+XMLPUBFUN xmlNsPtr XMLCALL	
+		xmlCopyNamespace	(xmlNsPtr cur);
+XMLPUBFUN xmlNsPtr XMLCALL	
+		xmlCopyNamespaceList	(xmlNsPtr cur);
+
+/*
+ * Changing the content.
+ */
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlSetProp		(xmlNodePtr node,
+					 const xmlChar *name,
+					 const xmlChar *value);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlSetNsProp		(xmlNodePtr node,
+					 xmlNsPtr ns,
+					 const xmlChar *name,
+					 const xmlChar *value);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) */
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlGetNoNsProp		(xmlNodePtr node,
+					 const xmlChar *name);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlGetProp		(xmlNodePtr node,
+					 const xmlChar *name);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlHasProp		(xmlNodePtr node,
+					 const xmlChar *name);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlHasNsProp		(xmlNodePtr node,
+					 const xmlChar *name,
+					 const xmlChar *nameSpace);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlGetNsProp		(xmlNodePtr node,
+					 const xmlChar *name,
+					 const xmlChar *nameSpace);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlStringGetNodeList	(xmlDocPtr doc,
+					 const xmlChar *value);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		xmlStringLenGetNodeList	(xmlDocPtr doc,
+					 const xmlChar *value,
+					 int len);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlNodeListGetString	(xmlDocPtr doc,
+					 xmlNodePtr list,
+					 int inLine);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlNodeListGetRawString	(xmlDocPtr doc,
+					 xmlNodePtr list,
+					 int inLine);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN void XMLCALL		
+		xmlNodeSetContent	(xmlNodePtr cur,
+					 const xmlChar *content);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlNodeSetContentLen	(xmlNodePtr cur,
+					 const xmlChar *content,
+					 int len);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN void XMLCALL		
+		xmlNodeAddContent	(xmlNodePtr cur,
+					 const xmlChar *content);
+XMLPUBFUN void XMLCALL		
+		xmlNodeAddContentLen	(xmlNodePtr cur,
+					 const xmlChar *content,
+					 int len);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlNodeGetContent	(xmlNodePtr cur);
+XMLPUBFUN int XMLCALL
+		xmlNodeBufGetContent	(xmlBufferPtr buffer,
+					 xmlNodePtr cur);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlNodeGetLang		(xmlNodePtr cur);
+XMLPUBFUN int XMLCALL		
+		xmlNodeGetSpacePreserve	(xmlNodePtr cur);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlNodeSetLang		(xmlNodePtr cur,
+					 const xmlChar *lang);
+XMLPUBFUN void XMLCALL		
+		xmlNodeSetSpacePreserve (xmlNodePtr cur,
+					 int val);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlNodeGetBase		(xmlDocPtr doc,
+					 xmlNodePtr cur);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)
+XMLPUBFUN void XMLCALL		
+		xmlNodeSetBase		(xmlNodePtr cur,
+					 const xmlChar *uri);
+#endif
+
+/*
+ * Removing content.
+ */
+XMLPUBFUN int XMLCALL		
+		xmlRemoveProp		(xmlAttrPtr cur);
+#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN int XMLCALL		
+		xmlUnsetNsProp		(xmlNodePtr node,
+					 xmlNsPtr ns,
+					 const xmlChar *name);
+XMLPUBFUN int XMLCALL		
+		xmlUnsetProp		(xmlNodePtr node,
+					 const xmlChar *name);
+#endif /* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) */
+
+/*
+ * Internal, don't use.
+ */
+XMLPUBFUN void XMLCALL		
+		xmlBufferWriteCHAR	(xmlBufferPtr buf,
+					 const xmlChar *string);
+XMLPUBFUN void XMLCALL		
+		xmlBufferWriteChar	(xmlBufferPtr buf,
+					 const char *string);
+XMLPUBFUN void XMLCALL		
+		xmlBufferWriteQuotedString(xmlBufferPtr buf,
+					 const xmlChar *string);
+
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void xmlAttrSerializeTxtContent(xmlBufferPtr buf,
+					 xmlDocPtr doc,
+					 xmlAttrPtr attr,
+					 const xmlChar *string);
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+#ifdef LIBXML_TREE_ENABLED
+/*
+ * Namespace handling.
+ */
+XMLPUBFUN int XMLCALL		
+		xmlReconciliateNs	(xmlDocPtr doc,
+					 xmlNodePtr tree);
+#endif
+
+#ifdef LIBXML_OUTPUT_ENABLED
+/*
+ * Saving.
+ */
+XMLPUBFUN void XMLCALL		
+		xmlDocDumpFormatMemory	(xmlDocPtr cur,
+					 xmlChar **mem,
+					 int *size,
+					 int format);
+XMLPUBFUN void XMLCALL		
+		xmlDocDumpMemory	(xmlDocPtr cur,
+					 xmlChar **mem,
+					 int *size);
+XMLPUBFUN void XMLCALL		
+		xmlDocDumpMemoryEnc	(xmlDocPtr out_doc,
+					 xmlChar **doc_txt_ptr,
+					 int * doc_txt_len,
+					 const char *txt_encoding);
+XMLPUBFUN void XMLCALL		
+		xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,
+					 xmlChar **doc_txt_ptr,
+					 int * doc_txt_len,
+					 const char *txt_encoding,
+					 int format);
+XMLPUBFUN int XMLCALL		
+		xmlDocFormatDump	(FILE *f,
+					 xmlDocPtr cur,
+					 int format);
+XMLPUBFUN int XMLCALL	
+		xmlDocDump		(FILE *f,
+					 xmlDocPtr cur);
+XMLPUBFUN void XMLCALL		
+		xmlElemDump		(FILE *f,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur);
+XMLPUBFUN int XMLCALL		
+		xmlSaveFile		(const char *filename,
+					 xmlDocPtr cur);
+XMLPUBFUN int XMLCALL		
+		xmlSaveFormatFile	(const char *filename,
+					 xmlDocPtr cur,
+					 int format);
+XMLPUBFUN int XMLCALL		
+		xmlNodeDump		(xmlBufferPtr buf,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur,
+					 int level,
+					 int format);
+
+XMLPUBFUN int XMLCALL		
+		xmlSaveFileTo		(xmlOutputBufferPtr buf,
+					 xmlDocPtr cur,
+					 const char *encoding);
+XMLPUBFUN int XMLCALL             
+		xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,
+					 xmlDocPtr cur,
+				         const char *encoding,
+				         int format);
+XMLPUBFUN void XMLCALL		
+		xmlNodeDumpOutput	(xmlOutputBufferPtr buf,
+					 xmlDocPtr doc,
+					 xmlNodePtr cur,
+					 int level,
+					 int format,
+					 const char *encoding);
+
+XMLPUBFUN int XMLCALL		
+		xmlSaveFormatFileEnc    (const char *filename,
+					 xmlDocPtr cur,
+					 const char *encoding,
+					 int format);
+
+XMLPUBFUN int XMLCALL		
+		xmlSaveFileEnc		(const char *filename,
+					 xmlDocPtr cur,
+					 const char *encoding);
+
+#endif /* LIBXML_OUTPUT_ENABLED */
+/*
+ * XHTML
+ */
+XMLPUBFUN int XMLCALL		
+		xmlIsXHTML		(const xmlChar *systemID,
+					 const xmlChar *publicID);
+
+/*
+ * Compression.
+ */
+XMLPUBFUN int XMLCALL		
+		xmlGetDocCompressMode	(xmlDocPtr doc);
+XMLPUBFUN void XMLCALL		
+		xmlSetDocCompressMode	(xmlDocPtr doc,
+					 int mode);
+XMLPUBFUN int XMLCALL		
+		xmlGetCompressMode	(void);
+XMLPUBFUN void XMLCALL		
+		xmlSetCompressMode	(int mode);
+
+/*
+* DOM-wrapper helper functions.
+*/
+XMLPUBFUN xmlDOMWrapCtxtPtr XMLCALL
+		xmlDOMWrapNewCtxt	(void);
+XMLPUBFUN void XMLCALL
+		xmlDOMWrapFreeCtxt	(xmlDOMWrapCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+	    xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,
+					 xmlNodePtr elem,
+					 int options);
+XMLPUBFUN int XMLCALL
+	    xmlDOMWrapAdoptNode		(xmlDOMWrapCtxtPtr ctxt,
+					 xmlDocPtr sourceDoc,
+					 xmlNodePtr node,
+					 xmlDocPtr destDoc,		    
+					 xmlNodePtr destParent,
+					 int options);
+XMLPUBFUN int XMLCALL
+	    xmlDOMWrapRemoveNode	(xmlDOMWrapCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr node,
+					 int options);
+XMLPUBFUN int XMLCALL
+	    xmlDOMWrapCloneNode		(xmlDOMWrapCtxtPtr ctxt,
+					 xmlDocPtr sourceDoc,
+					 xmlNodePtr node,
+					 xmlNodePtr *clonedNode,
+					 xmlDocPtr destDoc,
+					 xmlNodePtr destParent,
+					 int deep,
+					 int options);
+
+#ifdef __cplusplus
+}
+#endif
+#ifndef __XML_PARSER_H__
+#include <libxml/xmlmemory.h>
+#endif
+
+#endif /* __XML_TREE_H__ */
+
diff -Naur orig.ns-2.33/libxml/uri.h ns-2.33/libxml/uri.h
--- orig.ns-2.33/libxml/uri.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/uri.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,94 @@
+/**
+ * Summary: library of generic URI related routines
+ * Description: library of generic URI related routines
+ *              Implements RFC 2396
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_URI_H__
+#define __XML_URI_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlURI:
+ *
+ * A parsed URI reference. This is a struct containing the various fields
+ * as described in RFC 2396 but separated for further processing.
+ *
+ * Note: query is a deprecated field which is incorrectly unescaped.
+ * query_raw takes precedence over query if the former is set.
+ * See: http://mail.gnome.org/archives/xml/2007-April/thread.html#00127
+ */
+typedef struct _xmlURI xmlURI;
+typedef xmlURI *xmlURIPtr;
+struct _xmlURI {
+    char *scheme;	/* the URI scheme */
+    char *opaque;	/* opaque part */
+    char *authority;	/* the authority part */
+    char *server;	/* the server part */
+    char *user;		/* the user part */
+    int port;		/* the port number */
+    char *path;		/* the path string */
+    char *query;	/* the query string (deprecated - use with caution) */
+    char *fragment;	/* the fragment identifier */
+    int  cleanup;	/* parsing potentially unclean URI */
+    char *query_raw;	/* the query string (as it appears in the URI) */
+};
+
+/*
+ * This function is in tree.h:
+ * xmlChar *	xmlNodeGetBase	(xmlDocPtr doc,
+ *                               xmlNodePtr cur);
+ */
+XMLPUBFUN xmlURIPtr XMLCALL	
+		xmlCreateURI		(void);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlBuildURI		(const xmlChar *URI,
+	                         	 const xmlChar *base);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlBuildRelativeURI	(const xmlChar *URI,
+	                         	 const xmlChar *base);
+XMLPUBFUN xmlURIPtr XMLCALL	
+		xmlParseURI		(const char *str);
+XMLPUBFUN xmlURIPtr XMLCALL	
+		xmlParseURIRaw		(const char *str,
+					 int raw);
+XMLPUBFUN int XMLCALL		
+		xmlParseURIReference	(xmlURIPtr uri,
+					 const char *str);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlSaveUri		(xmlURIPtr uri);
+XMLPUBFUN void XMLCALL		
+		xmlPrintURI		(FILE *stream,
+					 xmlURIPtr uri);
+XMLPUBFUN xmlChar * XMLCALL       
+		xmlURIEscapeStr         (const xmlChar *str,
+ 					 const xmlChar *list);
+XMLPUBFUN char * XMLCALL		
+		xmlURIUnescapeString	(const char *str,
+					 int len,
+					 char *target);
+XMLPUBFUN int XMLCALL		
+		xmlNormalizeURIPath	(char *path);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlURIEscape		(const xmlChar *str);
+XMLPUBFUN void XMLCALL		
+		xmlFreeURI		(xmlURIPtr uri);
+XMLPUBFUN xmlChar* XMLCALL	
+		xmlCanonicPath		(const xmlChar *path);
+XMLPUBFUN xmlChar* XMLCALL	
+		xmlPathToURI		(const xmlChar *path);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_URI_H__ */
diff -Naur orig.ns-2.33/libxml/valid.h ns-2.33/libxml/valid.h
--- orig.ns-2.33/libxml/valid.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/valid.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,458 @@
+/*
+ * Summary: The DTD validation
+ * Description: API for the DTD handling and the validity checking
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_VALID_H__
+#define __XML_VALID_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/xmlerror.h>
+#include <libxml/tree.h>
+#include <libxml/list.h>
+#include <libxml/xmlautomata.h>
+#include <libxml/xmlregexp.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Validation state added for non-determinist content model.
+ */
+typedef struct _xmlValidState xmlValidState;
+typedef xmlValidState *xmlValidStatePtr;
+
+/**
+ * xmlValidityErrorFunc:
+ * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
+ *        but comes from ctxt->userData (which normally contains such
+ *        a pointer); ctxt->userData can be changed by the user.
+ * @msg:  the string to format *printf like vararg
+ * @...:  remaining arguments to the format
+ *
+ * Callback called when a validity error is found. This is a message
+ * oriented function similar to an *printf function.
+ */
+typedef void (XMLCDECL *xmlValidityErrorFunc) (void *ctx,
+			     const char *msg,
+			     ...);
+
+/**
+ * xmlValidityWarningFunc:
+ * @ctx:  usually an xmlValidCtxtPtr to a validity error context,
+ *        but comes from ctxt->userData (which normally contains such
+ *        a pointer); ctxt->userData can be changed by the user.
+ * @msg:  the string to format *printf like vararg
+ * @...:  remaining arguments to the format
+ *
+ * Callback called when a validity warning is found. This is a message
+ * oriented function similar to an *printf function.
+ */
+typedef void (XMLCDECL *xmlValidityWarningFunc) (void *ctx,
+			       const char *msg,
+			       ...);
+
+#ifdef IN_LIBXML
+/**
+ * XML_CTXT_FINISH_DTD_0:
+ *
+ * Special value for finishDtd field when embedded in an xmlParserCtxt
+ */
+#define XML_CTXT_FINISH_DTD_0 0xabcd1234
+/**
+ * XML_CTXT_FINISH_DTD_1:
+ *
+ * Special value for finishDtd field when embedded in an xmlParserCtxt
+ */
+#define XML_CTXT_FINISH_DTD_1 0xabcd1235
+#endif
+
+/*
+ * xmlValidCtxt:
+ * An xmlValidCtxt is used for error reporting when validating.
+ */
+typedef struct _xmlValidCtxt xmlValidCtxt;
+typedef xmlValidCtxt *xmlValidCtxtPtr;
+struct _xmlValidCtxt {
+    void *userData;			/* user specific data block */
+    xmlValidityErrorFunc error;		/* the callback in case of errors */
+    xmlValidityWarningFunc warning;	/* the callback in case of warning */
+
+    /* Node analysis stack used when validating within entities */
+    xmlNodePtr         node;          /* Current parsed Node */
+    int                nodeNr;        /* Depth of the parsing stack */
+    int                nodeMax;       /* Max depth of the parsing stack */
+    xmlNodePtr        *nodeTab;       /* array of nodes */
+
+    unsigned int     finishDtd;       /* finished validating the Dtd ? */
+    xmlDocPtr              doc;       /* the document */
+    int                  valid;       /* temporary validity check result */
+
+    /* state state used for non-determinist content validation */
+    xmlValidState     *vstate;        /* current state */
+    int                vstateNr;      /* Depth of the validation stack */
+    int                vstateMax;     /* Max depth of the validation stack */
+    xmlValidState     *vstateTab;     /* array of validation states */
+
+#ifdef LIBXML_REGEXP_ENABLED
+    xmlAutomataPtr            am;     /* the automata */
+    xmlAutomataStatePtr    state;     /* used to build the automata */
+#else
+    void                     *am;
+    void                  *state;
+#endif
+};
+
+/*
+ * ALL notation declarations are stored in a table.
+ * There is one table per DTD.
+ */
+
+typedef struct _xmlHashTable xmlNotationTable;
+typedef xmlNotationTable *xmlNotationTablePtr;
+
+/*
+ * ALL element declarations are stored in a table.
+ * There is one table per DTD.
+ */
+
+typedef struct _xmlHashTable xmlElementTable;
+typedef xmlElementTable *xmlElementTablePtr;
+
+/*
+ * ALL attribute declarations are stored in a table.
+ * There is one table per DTD.
+ */
+
+typedef struct _xmlHashTable xmlAttributeTable;
+typedef xmlAttributeTable *xmlAttributeTablePtr;
+
+/*
+ * ALL IDs attributes are stored in a table.
+ * There is one table per document.
+ */
+
+typedef struct _xmlHashTable xmlIDTable;
+typedef xmlIDTable *xmlIDTablePtr;
+
+/*
+ * ALL Refs attributes are stored in a table.
+ * There is one table per document.
+ */
+
+typedef struct _xmlHashTable xmlRefTable;
+typedef xmlRefTable *xmlRefTablePtr;
+
+/* Notation */
+XMLPUBFUN xmlNotationPtr XMLCALL	    
+		xmlAddNotationDecl	(xmlValidCtxtPtr ctxt,
+					 xmlDtdPtr dtd,
+					 const xmlChar *name,
+					 const xmlChar *PublicID,
+					 const xmlChar *SystemID);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlNotationTablePtr XMLCALL 
+		xmlCopyNotationTable	(xmlNotationTablePtr table);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN void XMLCALL		    
+		xmlFreeNotationTable	(xmlNotationTablePtr table);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		    
+		xmlDumpNotationDecl	(xmlBufferPtr buf,
+					 xmlNotationPtr nota);
+XMLPUBFUN void XMLCALL		    
+		xmlDumpNotationTable	(xmlBufferPtr buf,
+					 xmlNotationTablePtr table);
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+/* Element Content */
+/* the non Doc version are being deprecated */
+XMLPUBFUN xmlElementContentPtr XMLCALL 
+		xmlNewElementContent	(const xmlChar *name,
+					 xmlElementContentType type);
+XMLPUBFUN xmlElementContentPtr XMLCALL 
+		xmlCopyElementContent	(xmlElementContentPtr content);
+XMLPUBFUN void XMLCALL		     
+		xmlFreeElementContent	(xmlElementContentPtr cur);
+/* the new versions with doc argument */
+XMLPUBFUN xmlElementContentPtr XMLCALL 
+		xmlNewDocElementContent	(xmlDocPtr doc,
+					 const xmlChar *name,
+					 xmlElementContentType type);
+XMLPUBFUN xmlElementContentPtr XMLCALL 
+		xmlCopyDocElementContent(xmlDocPtr doc,
+					 xmlElementContentPtr content);
+XMLPUBFUN void XMLCALL		     
+		xmlFreeDocElementContent(xmlDocPtr doc,
+					 xmlElementContentPtr cur);
+XMLPUBFUN void XMLCALL		     
+		xmlSnprintfElementContent(char *buf,
+					 int size,
+	                                 xmlElementContentPtr content,
+					 int englob);
+#ifdef LIBXML_OUTPUT_ENABLED
+/* DEPRECATED */
+XMLPUBFUN void XMLCALL		     
+		xmlSprintfElementContent(char *buf,
+	                                 xmlElementContentPtr content,
+					 int englob);
+#endif /* LIBXML_OUTPUT_ENABLED */
+/* DEPRECATED */
+
+/* Element */
+XMLPUBFUN xmlElementPtr XMLCALL	   
+		xmlAddElementDecl	(xmlValidCtxtPtr ctxt,
+					 xmlDtdPtr dtd,
+					 const xmlChar *name,
+					 xmlElementTypeVal type,
+					 xmlElementContentPtr content);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlElementTablePtr XMLCALL 
+		xmlCopyElementTable	(xmlElementTablePtr table);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN void XMLCALL		   
+		xmlFreeElementTable	(xmlElementTablePtr table);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		   
+		xmlDumpElementTable	(xmlBufferPtr buf,
+					 xmlElementTablePtr table);
+XMLPUBFUN void XMLCALL		   
+		xmlDumpElementDecl	(xmlBufferPtr buf,
+					 xmlElementPtr elem);
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+/* Enumeration */
+XMLPUBFUN xmlEnumerationPtr XMLCALL 
+		xmlCreateEnumeration	(const xmlChar *name);
+XMLPUBFUN void XMLCALL		   
+		xmlFreeEnumeration	(xmlEnumerationPtr cur);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlEnumerationPtr XMLCALL  
+		xmlCopyEnumeration	(xmlEnumerationPtr cur);
+#endif /* LIBXML_TREE_ENABLED */
+
+/* Attribute */
+XMLPUBFUN xmlAttributePtr XMLCALL	    
+		xmlAddAttributeDecl	(xmlValidCtxtPtr ctxt,
+					 xmlDtdPtr dtd,
+					 const xmlChar *elem,
+					 const xmlChar *name,
+					 const xmlChar *ns,
+					 xmlAttributeType type,
+					 xmlAttributeDefault def,
+					 const xmlChar *defaultValue,
+					 xmlEnumerationPtr tree);
+#ifdef LIBXML_TREE_ENABLED
+XMLPUBFUN xmlAttributeTablePtr XMLCALL 
+		xmlCopyAttributeTable  (xmlAttributeTablePtr table);
+#endif /* LIBXML_TREE_ENABLED */
+XMLPUBFUN void XMLCALL		     
+		xmlFreeAttributeTable  (xmlAttributeTablePtr table);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		     
+		xmlDumpAttributeTable  (xmlBufferPtr buf,
+					xmlAttributeTablePtr table);
+XMLPUBFUN void XMLCALL		     
+		xmlDumpAttributeDecl   (xmlBufferPtr buf,
+					xmlAttributePtr attr);
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+/* IDs */
+XMLPUBFUN xmlIDPtr XMLCALL	
+		xmlAddID	       (xmlValidCtxtPtr ctxt,
+					xmlDocPtr doc,
+					const xmlChar *value,
+					xmlAttrPtr attr);
+XMLPUBFUN void XMLCALL		
+		xmlFreeIDTable	       (xmlIDTablePtr table);
+XMLPUBFUN xmlAttrPtr XMLCALL	
+		xmlGetID	       (xmlDocPtr doc,
+					const xmlChar *ID);
+XMLPUBFUN int XMLCALL		
+		xmlIsID		       (xmlDocPtr doc,
+					xmlNodePtr elem,
+					xmlAttrPtr attr);
+XMLPUBFUN int XMLCALL		
+		xmlRemoveID	       (xmlDocPtr doc, 
+					xmlAttrPtr attr);
+
+/* IDREFs */
+XMLPUBFUN xmlRefPtr XMLCALL	
+		xmlAddRef	       (xmlValidCtxtPtr ctxt,
+					xmlDocPtr doc,
+					const xmlChar *value,
+					xmlAttrPtr attr);
+XMLPUBFUN void XMLCALL		
+		xmlFreeRefTable	       (xmlRefTablePtr table);
+XMLPUBFUN int XMLCALL		
+		xmlIsRef	       (xmlDocPtr doc,
+					xmlNodePtr elem,
+					xmlAttrPtr attr);
+XMLPUBFUN int XMLCALL		
+		xmlRemoveRef	       (xmlDocPtr doc, 
+					xmlAttrPtr attr);
+XMLPUBFUN xmlListPtr XMLCALL	
+		xmlGetRefs	       (xmlDocPtr doc,
+					const xmlChar *ID);
+
+/**
+ * The public function calls related to validity checking.
+ */
+#ifdef LIBXML_VALID_ENABLED
+/* Allocate/Release Validation Contexts */
+XMLPUBFUN xmlValidCtxtPtr XMLCALL	    
+		xmlNewValidCtxt(void);
+XMLPUBFUN void XMLCALL		    
+		xmlFreeValidCtxt(xmlValidCtxtPtr);
+
+XMLPUBFUN int XMLCALL		
+		xmlValidateRoot		(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc);
+XMLPUBFUN int XMLCALL		
+		xmlValidateElementDecl	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+		                         xmlElementPtr elem);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlValidNormalizeAttributeValue(xmlDocPtr doc,
+					 xmlNodePtr elem,
+					 const xmlChar *name,
+					 const xmlChar *value);
+XMLPUBFUN xmlChar * XMLCALL	
+		xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem,
+					 const xmlChar *name,
+					 const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+		                         xmlAttributePtr attr);
+XMLPUBFUN int XMLCALL		
+		xmlValidateAttributeValue(xmlAttributeType type,
+					 const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateNotationDecl	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+		                         xmlNotationPtr nota);
+XMLPUBFUN int XMLCALL		
+		xmlValidateDtd		(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlDtdPtr dtd);
+XMLPUBFUN int XMLCALL		
+		xmlValidateDtdFinal	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc);
+XMLPUBFUN int XMLCALL		
+		xmlValidateDocument	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc);
+XMLPUBFUN int XMLCALL		
+		xmlValidateElement	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem);
+XMLPUBFUN int XMLCALL		
+		xmlValidateOneElement	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+		                         xmlNodePtr elem);
+XMLPUBFUN int XMLCALL	
+		xmlValidateOneAttribute	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr	elem,
+					 xmlAttrPtr attr,
+					 const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateOneNamespace	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem,
+					 const xmlChar *prefix,
+					 xmlNsPtr ns,
+					 const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc);
+#endif /* LIBXML_VALID_ENABLED */
+
+#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN int XMLCALL		
+		xmlValidateNotationUse	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 const xmlChar *notationName);
+#endif /* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED */
+
+XMLPUBFUN int XMLCALL		
+		xmlIsMixedElement	(xmlDocPtr doc,
+					 const xmlChar *name);
+XMLPUBFUN xmlAttributePtr XMLCALL	
+		xmlGetDtdAttrDesc	(xmlDtdPtr dtd,
+					 const xmlChar *elem,
+					 const xmlChar *name);
+XMLPUBFUN xmlAttributePtr XMLCALL	
+		xmlGetDtdQAttrDesc	(xmlDtdPtr dtd,
+					 const xmlChar *elem,
+					 const xmlChar *name,
+					 const xmlChar *prefix);
+XMLPUBFUN xmlNotationPtr XMLCALL	
+		xmlGetDtdNotationDesc	(xmlDtdPtr dtd,
+					 const xmlChar *name);
+XMLPUBFUN xmlElementPtr XMLCALL	
+		xmlGetDtdQElementDesc	(xmlDtdPtr dtd,
+					 const xmlChar *name,
+					 const xmlChar *prefix);
+XMLPUBFUN xmlElementPtr XMLCALL	
+		xmlGetDtdElementDesc	(xmlDtdPtr dtd,
+					 const xmlChar *name);
+
+#ifdef LIBXML_VALID_ENABLED
+
+XMLPUBFUN int XMLCALL		
+		xmlValidGetPotentialChildren(xmlElementContent *ctree,
+					 const xmlChar **names,
+					 int *len,
+					 int max);
+
+XMLPUBFUN int XMLCALL		
+		xmlValidGetValidElements(xmlNode *prev,
+					 xmlNode *next,
+					 const xmlChar **names,
+					 int max);
+XMLPUBFUN int XMLCALL		
+		xmlValidateNameValue	(const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateNamesValue	(const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateNmtokenValue	(const xmlChar *value);
+XMLPUBFUN int XMLCALL		
+		xmlValidateNmtokensValue(const xmlChar *value);
+
+#ifdef LIBXML_REGEXP_ENABLED
+/*
+ * Validation based on the regexp support
+ */
+XMLPUBFUN int XMLCALL		
+		xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,
+					 xmlElementPtr elem);
+
+XMLPUBFUN int XMLCALL		
+		xmlValidatePushElement	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem,
+					 const xmlChar *qname);
+XMLPUBFUN int XMLCALL		
+		xmlValidatePushCData	(xmlValidCtxtPtr ctxt,
+					 const xmlChar *data,
+					 int len);
+XMLPUBFUN int XMLCALL		
+		xmlValidatePopElement	(xmlValidCtxtPtr ctxt,
+					 xmlDocPtr doc,
+					 xmlNodePtr elem,
+					 const xmlChar *qname);
+#endif /* LIBXML_REGEXP_ENABLED */
+#endif /* LIBXML_VALID_ENABLED */
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_VALID_H__ */
diff -Naur orig.ns-2.33/libxml/xinclude.h ns-2.33/libxml/xinclude.h
--- orig.ns-2.33/libxml/xinclude.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xinclude.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,125 @@
+/*
+ * Summary: implementation of XInclude
+ * Description: API to handle XInclude processing,
+ * implements the
+ * World Wide Web Consortium Last Call Working Draft 10 November 2003
+ * http://www.w3.org/TR/2003/WD-xinclude-20031110
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XINCLUDE_H__
+#define __XML_XINCLUDE_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef LIBXML_XINCLUDE_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * XINCLUDE_NS:
+ *
+ * Macro defining the Xinclude namespace: http://www.w3.org/2003/XInclude
+ */
+#define XINCLUDE_NS (const xmlChar *) "http://www.w3.org/2003/XInclude"
+/**
+ * XINCLUDE_OLD_NS:
+ *
+ * Macro defining the draft Xinclude namespace: http://www.w3.org/2001/XInclude
+ */
+#define XINCLUDE_OLD_NS (const xmlChar *) "http://www.w3.org/2001/XInclude"
+/**
+ * XINCLUDE_NODE:
+ *
+ * Macro defining "include"
+ */
+#define XINCLUDE_NODE (const xmlChar *) "include"
+/**
+ * XINCLUDE_FALLBACK:
+ *
+ * Macro defining "fallback"
+ */
+#define XINCLUDE_FALLBACK (const xmlChar *) "fallback"
+/**
+ * XINCLUDE_HREF:
+ *
+ * Macro defining "href"
+ */
+#define XINCLUDE_HREF (const xmlChar *) "href"
+/**
+ * XINCLUDE_PARSE:
+ *
+ * Macro defining "parse"
+ */
+#define XINCLUDE_PARSE (const xmlChar *) "parse"
+/**
+ * XINCLUDE_PARSE_XML:
+ *
+ * Macro defining "xml"
+ */
+#define XINCLUDE_PARSE_XML (const xmlChar *) "xml"
+/**
+ * XINCLUDE_PARSE_TEXT:
+ *
+ * Macro defining "text"
+ */
+#define XINCLUDE_PARSE_TEXT (const xmlChar *) "text"
+/**
+ * XINCLUDE_PARSE_ENCODING:
+ *
+ * Macro defining "encoding"
+ */
+#define XINCLUDE_PARSE_ENCODING (const xmlChar *) "encoding"
+/**
+ * XINCLUDE_PARSE_XPOINTER:
+ *
+ * Macro defining "xpointer"
+ */
+#define XINCLUDE_PARSE_XPOINTER (const xmlChar *) "xpointer"
+
+typedef struct _xmlXIncludeCtxt xmlXIncludeCtxt;
+typedef xmlXIncludeCtxt *xmlXIncludeCtxtPtr;
+
+/*
+ * standalone processing
+ */
+XMLPUBFUN int XMLCALL	
+		xmlXIncludeProcess	(xmlDocPtr doc);
+XMLPUBFUN int XMLCALL	
+		xmlXIncludeProcessFlags	(xmlDocPtr doc,
+					 int flags);
+XMLPUBFUN int XMLCALL	
+		xmlXIncludeProcessFlagsData(xmlDocPtr doc,
+					 int flags,
+					 void *data);
+XMLPUBFUN int XMLCALL	
+		xmlXIncludeProcessTree	(xmlNodePtr tree);
+XMLPUBFUN int XMLCALL	
+		xmlXIncludeProcessTreeFlags(xmlNodePtr tree,
+					 int flags);
+/*
+ * contextual processing
+ */
+XMLPUBFUN xmlXIncludeCtxtPtr XMLCALL
+		xmlXIncludeNewContext	(xmlDocPtr doc);
+XMLPUBFUN int XMLCALL
+		xmlXIncludeSetFlags	(xmlXIncludeCtxtPtr ctxt,
+					 int flags);
+XMLPUBFUN void XMLCALL
+		xmlXIncludeFreeContext	(xmlXIncludeCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+		xmlXIncludeProcessNode	(xmlXIncludeCtxtPtr ctxt,
+					 xmlNodePtr tree);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_XINCLUDE_ENABLED */
+
+#endif /* __XML_XINCLUDE_H__ */
diff -Naur orig.ns-2.33/libxml/xlink.h ns-2.33/libxml/xlink.h
--- orig.ns-2.33/libxml/xlink.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xlink.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,189 @@
+/*
+ * Summary: unfinished XLink detection module
+ * Description: unfinished XLink detection module
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XLINK_H__
+#define __XML_XLINK_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef LIBXML_XPTR_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Various defines for the various Link properties.
+ *
+ * NOTE: the link detection layer will try to resolve QName expansion
+ *       of namespaces. If "foo" is the prefix for "http://foo.com/"
+ *       then the link detection layer will expand role="foo:myrole"
+ *       to "http://foo.com/:myrole".
+ * NOTE: the link detection layer will expand URI-Refences found on
+ *       href attributes by using the base mechanism if found.
+ */
+typedef xmlChar *xlinkHRef;
+typedef xmlChar *xlinkRole;
+typedef xmlChar *xlinkTitle;
+
+typedef enum {
+    XLINK_TYPE_NONE = 0,
+    XLINK_TYPE_SIMPLE,
+    XLINK_TYPE_EXTENDED,
+    XLINK_TYPE_EXTENDED_SET
+} xlinkType;
+
+typedef enum {
+    XLINK_SHOW_NONE = 0,
+    XLINK_SHOW_NEW,
+    XLINK_SHOW_EMBED,
+    XLINK_SHOW_REPLACE
+} xlinkShow;
+
+typedef enum {
+    XLINK_ACTUATE_NONE = 0,
+    XLINK_ACTUATE_AUTO,
+    XLINK_ACTUATE_ONREQUEST
+} xlinkActuate;
+
+/**
+ * xlinkNodeDetectFunc:
+ * @ctx:  user data pointer
+ * @node:  the node to check
+ * 
+ * This is the prototype for the link detection routine.
+ * It calls the default link detection callbacks upon link detection.
+ */
+typedef void (*xlinkNodeDetectFunc) (void *ctx, xmlNodePtr node);
+
+/*
+ * The link detection module interact with the upper layers using
+ * a set of callback registered at parsing time.
+ */
+
+/**
+ * xlinkSimpleLinkFunk:
+ * @ctx:  user data pointer
+ * @node:  the node carrying the link
+ * @href:  the target of the link
+ * @role:  the role string
+ * @title:  the link title
+ *
+ * This is the prototype for a simple link detection callback.
+ */
+typedef void
+(*xlinkSimpleLinkFunk)	(void *ctx,
+			 xmlNodePtr node,
+			 const xlinkHRef href,
+			 const xlinkRole role,
+			 const xlinkTitle title);
+
+/**
+ * xlinkExtendedLinkFunk:
+ * @ctx:  user data pointer
+ * @node:  the node carrying the link
+ * @nbLocators: the number of locators detected on the link
+ * @hrefs:  pointer to the array of locator hrefs
+ * @roles:  pointer to the array of locator roles
+ * @nbArcs: the number of arcs detected on the link
+ * @from:  pointer to the array of source roles found on the arcs
+ * @to:  pointer to the array of target roles found on the arcs
+ * @show:  array of values for the show attributes found on the arcs
+ * @actuate:  array of values for the actuate attributes found on the arcs
+ * @nbTitles: the number of titles detected on the link
+ * @title:  array of titles detected on the link
+ * @langs:  array of xml:lang values for the titles
+ *
+ * This is the prototype for a extended link detection callback.
+ */
+typedef void
+(*xlinkExtendedLinkFunk)(void *ctx,
+			 xmlNodePtr node,
+			 int nbLocators,
+			 const xlinkHRef *hrefs,
+			 const xlinkRole *roles,
+			 int nbArcs,
+			 const xlinkRole *from,
+			 const xlinkRole *to,
+			 xlinkShow *show,
+			 xlinkActuate *actuate,
+			 int nbTitles,
+			 const xlinkTitle *titles,
+			 const xmlChar **langs);
+
+/**
+ * xlinkExtendedLinkSetFunk:
+ * @ctx:  user data pointer
+ * @node:  the node carrying the link
+ * @nbLocators: the number of locators detected on the link
+ * @hrefs:  pointer to the array of locator hrefs
+ * @roles:  pointer to the array of locator roles
+ * @nbTitles: the number of titles detected on the link
+ * @title:  array of titles detected on the link
+ * @langs:  array of xml:lang values for the titles
+ *
+ * This is the prototype for a extended link set detection callback.
+ */
+typedef void
+(*xlinkExtendedLinkSetFunk)	(void *ctx,
+				 xmlNodePtr node,
+				 int nbLocators,
+				 const xlinkHRef *hrefs,
+				 const xlinkRole *roles,
+				 int nbTitles,
+				 const xlinkTitle *titles,
+				 const xmlChar **langs);
+
+/**
+ * This is the structure containing a set of Links detection callbacks.
+ *
+ * There is no default xlink callbacks, if one want to get link
+ * recognition activated, those call backs must be provided before parsing.
+ */
+typedef struct _xlinkHandler xlinkHandler;
+typedef xlinkHandler *xlinkHandlerPtr;
+struct _xlinkHandler {
+    xlinkSimpleLinkFunk simple;
+    xlinkExtendedLinkFunk extended;
+    xlinkExtendedLinkSetFunk set;
+};
+
+/*
+ * The default detection routine, can be overridden, they call the default
+ * detection callbacks. 
+ */
+
+XMLPUBFUN xlinkNodeDetectFunc XMLCALL	
+		xlinkGetDefaultDetect	(void);
+XMLPUBFUN void XMLCALL			
+		xlinkSetDefaultDetect	(xlinkNodeDetectFunc func);
+
+/*
+ * Routines to set/get the default handlers.
+ */
+XMLPUBFUN xlinkHandlerPtr XMLCALL	
+		xlinkGetDefaultHandler	(void);
+XMLPUBFUN void XMLCALL		
+		xlinkSetDefaultHandler	(xlinkHandlerPtr handler);
+
+/*
+ * Link detection module itself.
+ */
+XMLPUBFUN xlinkType XMLCALL	 
+		xlinkIsLink		(xmlDocPtr doc,
+					 xmlNodePtr node);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_XPTR_ENABLED */
+
+#endif /* __XML_XLINK_H__ */
diff -Naur orig.ns-2.33/libxml/xmlIO.h ns-2.33/libxml/xmlIO.h
--- orig.ns-2.33/libxml/xmlIO.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlIO.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,360 @@
+/*
+ * Summary: interface for the I/O interfaces used by the parser
+ * Description: interface for the I/O interfaces used by the parser
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_IO_H__
+#define __XML_IO_H__
+
+#include <stdio.h>
+#include <libxml/xmlversion.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Those are the functions and datatypes for the parser input
+ * I/O structures.
+ */
+
+/**
+ * xmlInputMatchCallback:
+ * @filename: the filename or URI
+ *
+ * Callback used in the I/O Input API to detect if the current handler 
+ * can provide input fonctionnalities for this resource.
+ *
+ * Returns 1 if yes and 0 if another Input module should be used
+ */
+typedef int (XMLCALL *xmlInputMatchCallback) (char const *filename);
+/**
+ * xmlInputOpenCallback:
+ * @filename: the filename or URI
+ *
+ * Callback used in the I/O Input API to open the resource
+ *
+ * Returns an Input context or NULL in case or error
+ */
+typedef void * (XMLCALL *xmlInputOpenCallback) (char const *filename);
+/**
+ * xmlInputReadCallback:
+ * @context:  an Input context
+ * @buffer:  the buffer to store data read
+ * @len:  the length of the buffer in bytes
+ *
+ * Callback used in the I/O Input API to read the resource
+ *
+ * Returns the number of bytes read or -1 in case of error
+ */
+typedef int (XMLCALL *xmlInputReadCallback) (void * context, char * buffer, int len);
+/**
+ * xmlInputCloseCallback:
+ * @context:  an Input context
+ *
+ * Callback used in the I/O Input API to close the resource
+ *
+ * Returns 0 or -1 in case of error
+ */
+typedef int (XMLCALL *xmlInputCloseCallback) (void * context);
+
+#ifdef LIBXML_OUTPUT_ENABLED
+/*
+ * Those are the functions and datatypes for the library output
+ * I/O structures.
+ */
+
+/**
+ * xmlOutputMatchCallback:
+ * @filename: the filename or URI
+ *
+ * Callback used in the I/O Output API to detect if the current handler 
+ * can provide output fonctionnalities for this resource.
+ *
+ * Returns 1 if yes and 0 if another Output module should be used
+ */
+typedef int (XMLCALL *xmlOutputMatchCallback) (char const *filename);
+/**
+ * xmlOutputOpenCallback:
+ * @filename: the filename or URI
+ *
+ * Callback used in the I/O Output API to open the resource
+ *
+ * Returns an Output context or NULL in case or error
+ */
+typedef void * (XMLCALL *xmlOutputOpenCallback) (char const *filename);
+/**
+ * xmlOutputWriteCallback:
+ * @context:  an Output context
+ * @buffer:  the buffer of data to write
+ * @len:  the length of the buffer in bytes
+ *
+ * Callback used in the I/O Output API to write to the resource
+ *
+ * Returns the number of bytes written or -1 in case of error
+ */
+typedef int (XMLCALL *xmlOutputWriteCallback) (void * context, const char * buffer,
+                                       int len);
+/**
+ * xmlOutputCloseCallback:
+ * @context:  an Output context
+ *
+ * Callback used in the I/O Output API to close the resource
+ *
+ * Returns 0 or -1 in case of error
+ */
+typedef int (XMLCALL *xmlOutputCloseCallback) (void * context);
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <libxml/globals.h>
+#include <libxml/tree.h>
+#include <libxml/parser.h>
+#include <libxml/encoding.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+struct _xmlParserInputBuffer {
+    void*                  context;
+    xmlInputReadCallback   readcallback;
+    xmlInputCloseCallback  closecallback;
+    
+    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */
+    
+    xmlBufferPtr buffer;    /* Local buffer encoded in UTF-8 */
+    xmlBufferPtr raw;       /* if encoder != NULL buffer for raw input */
+    int	compressed;	    /* -1=unknown, 0=not compressed, 1=compressed */
+    int error;
+    unsigned long rawconsumed;/* amount consumed from raw */
+};
+
+
+#ifdef LIBXML_OUTPUT_ENABLED
+struct _xmlOutputBuffer {
+    void*                   context;
+    xmlOutputWriteCallback  writecallback;
+    xmlOutputCloseCallback  closecallback;
+    
+    xmlCharEncodingHandlerPtr encoder; /* I18N conversions to UTF-8 */
+    
+    xmlBufferPtr buffer;    /* Local buffer encoded in UTF-8 or ISOLatin */
+    xmlBufferPtr conv;      /* if encoder != NULL buffer for output */
+    int written;            /* total number of byte written */
+    int error;
+};
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+/*
+ * Interfaces for input
+ */
+XMLPUBFUN void XMLCALL	
+	xmlCleanupInputCallbacks		(void);
+
+XMLPUBFUN int XMLCALL
+	xmlPopInputCallbacks			(void);
+
+XMLPUBFUN void XMLCALL	
+	xmlRegisterDefaultInputCallbacks	(void);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlAllocParserInputBuffer		(xmlCharEncoding enc);
+
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlParserInputBufferCreateFilename	(const char *URI,
+                                                 xmlCharEncoding enc);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlParserInputBufferCreateFile		(FILE *file,
+                                                 xmlCharEncoding enc);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlParserInputBufferCreateFd		(int fd,
+	                                         xmlCharEncoding enc);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlParserInputBufferCreateMem		(const char *mem, int size,
+	                                         xmlCharEncoding enc);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlParserInputBufferCreateStatic	(const char *mem, int size,
+	                                         xmlCharEncoding enc);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL
+	xmlParserInputBufferCreateIO		(xmlInputReadCallback   ioread,
+						 xmlInputCloseCallback  ioclose,
+						 void *ioctx,
+	                                         xmlCharEncoding enc);
+XMLPUBFUN int XMLCALL	
+	xmlParserInputBufferRead		(xmlParserInputBufferPtr in,
+						 int len);
+XMLPUBFUN int XMLCALL	
+	xmlParserInputBufferGrow		(xmlParserInputBufferPtr in,
+						 int len);
+XMLPUBFUN int XMLCALL	
+	xmlParserInputBufferPush		(xmlParserInputBufferPtr in,
+						 int len,
+						 const char *buf);
+XMLPUBFUN void XMLCALL	
+	xmlFreeParserInputBuffer		(xmlParserInputBufferPtr in);
+XMLPUBFUN char * XMLCALL	
+	xmlParserGetDirectory			(const char *filename);
+
+XMLPUBFUN int XMLCALL     
+	xmlRegisterInputCallbacks		(xmlInputMatchCallback matchFunc,
+						 xmlInputOpenCallback openFunc,
+						 xmlInputReadCallback readFunc,
+						 xmlInputCloseCallback closeFunc);
+
+xmlParserInputBufferPtr
+	__xmlParserInputBufferCreateFilename(const char *URI,
+										xmlCharEncoding enc);
+
+#ifdef LIBXML_OUTPUT_ENABLED
+/*
+ * Interfaces for output
+ */
+XMLPUBFUN void XMLCALL	
+	xmlCleanupOutputCallbacks		(void);
+XMLPUBFUN void XMLCALL	
+	xmlRegisterDefaultOutputCallbacks(void);
+XMLPUBFUN xmlOutputBufferPtr XMLCALL
+	xmlAllocOutputBuffer		(xmlCharEncodingHandlerPtr encoder);
+
+XMLPUBFUN xmlOutputBufferPtr XMLCALL
+	xmlOutputBufferCreateFilename	(const char *URI,
+					 xmlCharEncodingHandlerPtr encoder,
+					 int compression);
+
+XMLPUBFUN xmlOutputBufferPtr XMLCALL
+	xmlOutputBufferCreateFile	(FILE *file,
+					 xmlCharEncodingHandlerPtr encoder);
+
+XMLPUBFUN xmlOutputBufferPtr XMLCALL
+	xmlOutputBufferCreateBuffer	(xmlBufferPtr buffer,
+					 xmlCharEncodingHandlerPtr encoder);
+
+XMLPUBFUN xmlOutputBufferPtr XMLCALL
+	xmlOutputBufferCreateFd		(int fd,
+					 xmlCharEncodingHandlerPtr encoder);
+
+XMLPUBFUN xmlOutputBufferPtr XMLCALL
+	xmlOutputBufferCreateIO		(xmlOutputWriteCallback   iowrite,
+					 xmlOutputCloseCallback  ioclose,
+					 void *ioctx,
+					 xmlCharEncodingHandlerPtr encoder);
+
+XMLPUBFUN int XMLCALL	
+	xmlOutputBufferWrite		(xmlOutputBufferPtr out,
+					 int len,
+					 const char *buf);
+XMLPUBFUN int XMLCALL	
+	xmlOutputBufferWriteString	(xmlOutputBufferPtr out,
+					 const char *str);
+XMLPUBFUN int XMLCALL	
+	xmlOutputBufferWriteEscape	(xmlOutputBufferPtr out,
+					 const xmlChar *str,
+					 xmlCharEncodingOutputFunc escaping);
+
+XMLPUBFUN int XMLCALL	
+	xmlOutputBufferFlush		(xmlOutputBufferPtr out);
+XMLPUBFUN int XMLCALL	
+	xmlOutputBufferClose		(xmlOutputBufferPtr out);
+
+XMLPUBFUN int XMLCALL     
+	xmlRegisterOutputCallbacks	(xmlOutputMatchCallback matchFunc,
+					 xmlOutputOpenCallback openFunc,
+					 xmlOutputWriteCallback writeFunc,
+					 xmlOutputCloseCallback closeFunc);
+
+xmlOutputBufferPtr
+	__xmlOutputBufferCreateFilename(const char *URI,
+                              xmlCharEncodingHandlerPtr encoder,
+                              int compression);
+
+#ifdef LIBXML_HTTP_ENABLED
+/*  This function only exists if HTTP support built into the library  */
+XMLPUBFUN void XMLCALL	
+	xmlRegisterHTTPPostCallbacks	(void );
+#endif /* LIBXML_HTTP_ENABLED */
+	
+#endif /* LIBXML_OUTPUT_ENABLED */
+
+XMLPUBFUN xmlParserInputPtr XMLCALL
+	xmlCheckHTTPInput		(xmlParserCtxtPtr ctxt,
+					 xmlParserInputPtr ret);
+
+/*
+ * A predefined entity loader disabling network accesses
+ */
+XMLPUBFUN xmlParserInputPtr XMLCALL 
+	xmlNoNetExternalEntityLoader	(const char *URL,
+					 const char *ID,
+					 xmlParserCtxtPtr ctxt);
+
+/* 
+ * xmlNormalizeWindowsPath is obsolete, don't use it. 
+ * Check xmlCanonicPath in uri.h for a better alternative.
+ */
+XMLPUBFUN xmlChar * XMLCALL 
+	xmlNormalizeWindowsPath		(const xmlChar *path);
+
+XMLPUBFUN int XMLCALL	
+	xmlCheckFilename		(const char *path);
+/**
+ * Default 'file://' protocol callbacks 
+ */
+XMLPUBFUN int XMLCALL	
+	xmlFileMatch 			(const char *filename);
+XMLPUBFUN void * XMLCALL	
+	xmlFileOpen 			(const char *filename);
+XMLPUBFUN int XMLCALL	
+	xmlFileRead 			(void * context, 
+					 char * buffer, 
+					 int len);
+XMLPUBFUN int XMLCALL	
+	xmlFileClose 			(void * context);
+
+/**
+ * Default 'http://' protocol callbacks 
+ */
+#ifdef LIBXML_HTTP_ENABLED
+XMLPUBFUN int XMLCALL	
+	xmlIOHTTPMatch 			(const char *filename);
+XMLPUBFUN void * XMLCALL	
+	xmlIOHTTPOpen 			(const char *filename);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void * XMLCALL	
+	xmlIOHTTPOpenW			(const char * post_uri,
+					 int   compression );
+#endif /* LIBXML_OUTPUT_ENABLED */
+XMLPUBFUN int XMLCALL 	
+	xmlIOHTTPRead			(void * context, 
+					 char * buffer, 
+					 int len);
+XMLPUBFUN int XMLCALL	
+	xmlIOHTTPClose 			(void * context);
+#endif /* LIBXML_HTTP_ENABLED */
+
+/**
+ * Default 'ftp://' protocol callbacks 
+ */
+#ifdef LIBXML_FTP_ENABLED 
+XMLPUBFUN int XMLCALL	
+	xmlIOFTPMatch 			(const char *filename);
+XMLPUBFUN void * XMLCALL	
+	xmlIOFTPOpen 			(const char *filename);
+XMLPUBFUN int XMLCALL 	
+	xmlIOFTPRead			(void * context, 
+					 char * buffer, 
+					 int len);
+XMLPUBFUN int XMLCALL 	
+	xmlIOFTPClose 			(void * context);
+#endif /* LIBXML_FTP_ENABLED */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __XML_IO_H__ */
diff -Naur orig.ns-2.33/libxml/xmlautomata.h ns-2.33/libxml/xmlautomata.h
--- orig.ns-2.33/libxml/xmlautomata.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlautomata.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,146 @@
+/*
+ * Summary: API to build regexp automata
+ * Description: the API to build regexp automata
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_AUTOMATA_H__
+#define __XML_AUTOMATA_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+
+#ifdef LIBXML_REGEXP_ENABLED
+#ifdef LIBXML_AUTOMATA_ENABLED
+#include <libxml/xmlregexp.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlAutomataPtr:
+ *
+ * A libxml automata description, It can be compiled into a regexp
+ */
+typedef struct _xmlAutomata xmlAutomata;
+typedef xmlAutomata *xmlAutomataPtr;
+
+/**
+ * xmlAutomataStatePtr:
+ *
+ * A state int the automata description,
+ */
+typedef struct _xmlAutomataState xmlAutomataState;
+typedef xmlAutomataState *xmlAutomataStatePtr;
+
+/*
+ * Building API
+ */
+XMLPUBFUN xmlAutomataPtr XMLCALL		
+		    xmlNewAutomata		(void);
+XMLPUBFUN void XMLCALL			
+		    xmlFreeAutomata		(xmlAutomataPtr am);
+
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataGetInitState	(xmlAutomataPtr am);
+XMLPUBFUN int XMLCALL			
+		    xmlAutomataSetFinalState	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr state);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewState		(xmlAutomataPtr am);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewTransition	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 const xmlChar *token,
+						 void *data);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewTransition2	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 const xmlChar *token,
+						 const xmlChar *token2,
+						 void *data);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL
+                    xmlAutomataNewNegTrans	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 const xmlChar *token,
+						 const xmlChar *token2,
+						 void *data);
+
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewCountTrans	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 const xmlChar *token,
+						 int min,
+						 int max,
+						 void *data);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewCountTrans2	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 const xmlChar *token,
+						 const xmlChar *token2,
+						 int min,
+						 int max,
+						 void *data);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewOnceTrans	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 const xmlChar *token,
+						 int min,
+						 int max,
+						 void *data);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL
+		    xmlAutomataNewOnceTrans2	(xmlAutomataPtr am, 
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to, 
+						 const xmlChar *token,
+						 const xmlChar *token2,
+						 int min, 
+						 int max, 
+						 void *data);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewAllTrans	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 int lax);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewEpsilon	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewCountedTrans	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 int counter);
+XMLPUBFUN xmlAutomataStatePtr XMLCALL	
+		    xmlAutomataNewCounterTrans	(xmlAutomataPtr am,
+						 xmlAutomataStatePtr from,
+						 xmlAutomataStatePtr to,
+						 int counter);
+XMLPUBFUN int XMLCALL			
+		    xmlAutomataNewCounter	(xmlAutomataPtr am,
+						 int min,
+						 int max);
+
+XMLPUBFUN xmlRegexpPtr XMLCALL		
+		    xmlAutomataCompile		(xmlAutomataPtr am);
+XMLPUBFUN int XMLCALL	    		
+		    xmlAutomataIsDeterminist	(xmlAutomataPtr am);
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif /* LIBXML_AUTOMATA_ENABLED */
+#endif /* LIBXML_REGEXP_ENABLED */
+
+#endif /* __XML_AUTOMATA_H__ */
diff -Naur orig.ns-2.33/libxml/xmlerror.h ns-2.33/libxml/xmlerror.h
--- orig.ns-2.33/libxml/xmlerror.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlerror.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,936 @@
+/*
+ * Summary: error handling
+ * Description: the API used to report errors
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#include <libxml/parser.h>
+
+#ifndef __XML_ERROR_H__
+#define __XML_ERROR_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlErrorLevel:
+ *
+ * Indicates the level of an error
+ */
+typedef enum {
+    XML_ERR_NONE = 0,
+    XML_ERR_WARNING = 1,	/* A simple warning */
+    XML_ERR_ERROR = 2,		/* A recoverable error */
+    XML_ERR_FATAL = 3		/* A fatal error */
+} xmlErrorLevel;
+
+/**
+ * xmlErrorDomain:
+ *
+ * Indicates where an error may have come from
+ */
+typedef enum {
+    XML_FROM_NONE = 0,
+    XML_FROM_PARSER,	/* The XML parser */
+    XML_FROM_TREE,	/* The tree module */
+    XML_FROM_NAMESPACE,	/* The XML Namespace module */
+    XML_FROM_DTD,	/* The XML DTD validation with parser context*/
+    XML_FROM_HTML,	/* The HTML parser */
+    XML_FROM_MEMORY,	/* The memory allocator */
+    XML_FROM_OUTPUT,	/* The serialization code */
+    XML_FROM_IO,	/* The Input/Output stack */
+    XML_FROM_FTP,	/* The FTP module */
+    XML_FROM_HTTP,	/* The HTTP module */
+    XML_FROM_XINCLUDE,	/* The XInclude processing */
+    XML_FROM_XPATH,	/* The XPath module */
+    XML_FROM_XPOINTER,	/* The XPointer module */
+    XML_FROM_REGEXP,	/* The regular expressions module */
+    XML_FROM_DATATYPE,	/* The W3C XML Schemas Datatype module */
+    XML_FROM_SCHEMASP,	/* The W3C XML Schemas parser module */
+    XML_FROM_SCHEMASV,	/* The W3C XML Schemas validation module */
+    XML_FROM_RELAXNGP,	/* The Relax-NG parser module */
+    XML_FROM_RELAXNGV,	/* The Relax-NG validator module */
+    XML_FROM_CATALOG,	/* The Catalog module */
+    XML_FROM_C14N,	/* The Canonicalization module */
+    XML_FROM_XSLT,	/* The XSLT engine from libxslt */
+    XML_FROM_VALID,	/* The XML DTD validation with valid context */
+    XML_FROM_CHECK,	/* The error checking module */
+    XML_FROM_WRITER,	/* The xmlwriter module */
+    XML_FROM_MODULE,	/* The dynamically loaded module module*/
+    XML_FROM_I18N 	/* The module handling character conversion */
+} xmlErrorDomain;
+
+/**
+ * xmlError:
+ *
+ * An XML Error instance.
+ */
+
+typedef struct _xmlError xmlError;
+typedef xmlError *xmlErrorPtr;
+struct _xmlError {
+    int		domain;	/* What part of the library raised this error */
+    int		code;	/* The error code, e.g. an xmlParserError */
+    char       *message;/* human-readable informative error message */
+    xmlErrorLevel level;/* how consequent is the error */
+    char       *file;	/* the filename */
+    int		line;	/* the line number if available */
+    char       *str1;	/* extra string information */
+    char       *str2;	/* extra string information */
+    char       *str3;	/* extra string information */
+    int		int1;	/* extra number information */
+    int		int2;	/* column number of the error or 0 if N/A (todo: rename this field when we would break ABI) */
+    void       *ctxt;   /* the parser context if available */
+    void       *node;   /* the node in the tree */
+};
+
+/**
+ * xmlParserError:
+ *
+ * This is an error that the XML (or HTML) parser can generate
+ */
+typedef enum {
+    XML_ERR_OK = 0,
+    XML_ERR_INTERNAL_ERROR, /* 1 */
+    XML_ERR_NO_MEMORY, /* 2 */
+    XML_ERR_DOCUMENT_START, /* 3 */
+    XML_ERR_DOCUMENT_EMPTY, /* 4 */
+    XML_ERR_DOCUMENT_END, /* 5 */
+    XML_ERR_INVALID_HEX_CHARREF, /* 6 */
+    XML_ERR_INVALID_DEC_CHARREF, /* 7 */
+    XML_ERR_INVALID_CHARREF, /* 8 */
+    XML_ERR_INVALID_CHAR, /* 9 */
+    XML_ERR_CHARREF_AT_EOF, /* 10 */
+    XML_ERR_CHARREF_IN_PROLOG, /* 11 */
+    XML_ERR_CHARREF_IN_EPILOG, /* 12 */
+    XML_ERR_CHARREF_IN_DTD, /* 13 */
+    XML_ERR_ENTITYREF_AT_EOF, /* 14 */
+    XML_ERR_ENTITYREF_IN_PROLOG, /* 15 */
+    XML_ERR_ENTITYREF_IN_EPILOG, /* 16 */
+    XML_ERR_ENTITYREF_IN_DTD, /* 17 */
+    XML_ERR_PEREF_AT_EOF, /* 18 */
+    XML_ERR_PEREF_IN_PROLOG, /* 19 */
+    XML_ERR_PEREF_IN_EPILOG, /* 20 */
+    XML_ERR_PEREF_IN_INT_SUBSET, /* 21 */
+    XML_ERR_ENTITYREF_NO_NAME, /* 22 */
+    XML_ERR_ENTITYREF_SEMICOL_MISSING, /* 23 */
+    XML_ERR_PEREF_NO_NAME, /* 24 */
+    XML_ERR_PEREF_SEMICOL_MISSING, /* 25 */
+    XML_ERR_UNDECLARED_ENTITY, /* 26 */
+    XML_WAR_UNDECLARED_ENTITY, /* 27 */
+    XML_ERR_UNPARSED_ENTITY, /* 28 */
+    XML_ERR_ENTITY_IS_EXTERNAL, /* 29 */
+    XML_ERR_ENTITY_IS_PARAMETER, /* 30 */
+    XML_ERR_UNKNOWN_ENCODING, /* 31 */
+    XML_ERR_UNSUPPORTED_ENCODING, /* 32 */
+    XML_ERR_STRING_NOT_STARTED, /* 33 */
+    XML_ERR_STRING_NOT_CLOSED, /* 34 */
+    XML_ERR_NS_DECL_ERROR, /* 35 */
+    XML_ERR_ENTITY_NOT_STARTED, /* 36 */
+    XML_ERR_ENTITY_NOT_FINISHED, /* 37 */
+    XML_ERR_LT_IN_ATTRIBUTE, /* 38 */
+    XML_ERR_ATTRIBUTE_NOT_STARTED, /* 39 */
+    XML_ERR_ATTRIBUTE_NOT_FINISHED, /* 40 */
+    XML_ERR_ATTRIBUTE_WITHOUT_VALUE, /* 41 */
+    XML_ERR_ATTRIBUTE_REDEFINED, /* 42 */
+    XML_ERR_LITERAL_NOT_STARTED, /* 43 */
+    XML_ERR_LITERAL_NOT_FINISHED, /* 44 */
+    XML_ERR_COMMENT_NOT_FINISHED, /* 45 */
+    XML_ERR_PI_NOT_STARTED, /* 46 */
+    XML_ERR_PI_NOT_FINISHED, /* 47 */
+    XML_ERR_NOTATION_NOT_STARTED, /* 48 */
+    XML_ERR_NOTATION_NOT_FINISHED, /* 49 */
+    XML_ERR_ATTLIST_NOT_STARTED, /* 50 */
+    XML_ERR_ATTLIST_NOT_FINISHED, /* 51 */
+    XML_ERR_MIXED_NOT_STARTED, /* 52 */
+    XML_ERR_MIXED_NOT_FINISHED, /* 53 */
+    XML_ERR_ELEMCONTENT_NOT_STARTED, /* 54 */
+    XML_ERR_ELEMCONTENT_NOT_FINISHED, /* 55 */
+    XML_ERR_XMLDECL_NOT_STARTED, /* 56 */
+    XML_ERR_XMLDECL_NOT_FINISHED, /* 57 */
+    XML_ERR_CONDSEC_NOT_STARTED, /* 58 */
+    XML_ERR_CONDSEC_NOT_FINISHED, /* 59 */
+    XML_ERR_EXT_SUBSET_NOT_FINISHED, /* 60 */
+    XML_ERR_DOCTYPE_NOT_FINISHED, /* 61 */
+    XML_ERR_MISPLACED_CDATA_END, /* 62 */
+    XML_ERR_CDATA_NOT_FINISHED, /* 63 */
+    XML_ERR_RESERVED_XML_NAME, /* 64 */
+    XML_ERR_SPACE_REQUIRED, /* 65 */
+    XML_ERR_SEPARATOR_REQUIRED, /* 66 */
+    XML_ERR_NMTOKEN_REQUIRED, /* 67 */
+    XML_ERR_NAME_REQUIRED, /* 68 */
+    XML_ERR_PCDATA_REQUIRED, /* 69 */
+    XML_ERR_URI_REQUIRED, /* 70 */
+    XML_ERR_PUBID_REQUIRED, /* 71 */
+    XML_ERR_LT_REQUIRED, /* 72 */
+    XML_ERR_GT_REQUIRED, /* 73 */
+    XML_ERR_LTSLASH_REQUIRED, /* 74 */
+    XML_ERR_EQUAL_REQUIRED, /* 75 */
+    XML_ERR_TAG_NAME_MISMATCH, /* 76 */
+    XML_ERR_TAG_NOT_FINISHED, /* 77 */
+    XML_ERR_STANDALONE_VALUE, /* 78 */
+    XML_ERR_ENCODING_NAME, /* 79 */
+    XML_ERR_HYPHEN_IN_COMMENT, /* 80 */
+    XML_ERR_INVALID_ENCODING, /* 81 */
+    XML_ERR_EXT_ENTITY_STANDALONE, /* 82 */
+    XML_ERR_CONDSEC_INVALID, /* 83 */
+    XML_ERR_VALUE_REQUIRED, /* 84 */
+    XML_ERR_NOT_WELL_BALANCED, /* 85 */
+    XML_ERR_EXTRA_CONTENT, /* 86 */
+    XML_ERR_ENTITY_CHAR_ERROR, /* 87 */
+    XML_ERR_ENTITY_PE_INTERNAL, /* 88 */
+    XML_ERR_ENTITY_LOOP, /* 89 */
+    XML_ERR_ENTITY_BOUNDARY, /* 90 */
+    XML_ERR_INVALID_URI, /* 91 */
+    XML_ERR_URI_FRAGMENT, /* 92 */
+    XML_WAR_CATALOG_PI, /* 93 */
+    XML_ERR_NO_DTD, /* 94 */
+    XML_ERR_CONDSEC_INVALID_KEYWORD, /* 95 */
+    XML_ERR_VERSION_MISSING, /* 96 */
+    XML_WAR_UNKNOWN_VERSION, /* 97 */
+    XML_WAR_LANG_VALUE, /* 98 */
+    XML_WAR_NS_URI, /* 99 */
+    XML_WAR_NS_URI_RELATIVE, /* 100 */
+    XML_ERR_MISSING_ENCODING, /* 101 */
+    XML_WAR_SPACE_VALUE, /* 102 */
+    XML_ERR_NOT_STANDALONE, /* 103 */
+    XML_ERR_ENTITY_PROCESSING, /* 104 */
+    XML_ERR_NOTATION_PROCESSING, /* 105 */
+    XML_WAR_NS_COLUMN, /* 106 */
+    XML_WAR_ENTITY_REDEFINED, /* 107 */
+    XML_NS_ERR_XML_NAMESPACE = 200,
+    XML_NS_ERR_UNDEFINED_NAMESPACE, /* 201 */
+    XML_NS_ERR_QNAME, /* 202 */
+    XML_NS_ERR_ATTRIBUTE_REDEFINED, /* 203 */
+    XML_NS_ERR_EMPTY, /* 204 */
+    XML_DTD_ATTRIBUTE_DEFAULT = 500,
+    XML_DTD_ATTRIBUTE_REDEFINED, /* 501 */
+    XML_DTD_ATTRIBUTE_VALUE, /* 502 */
+    XML_DTD_CONTENT_ERROR, /* 503 */
+    XML_DTD_CONTENT_MODEL, /* 504 */
+    XML_DTD_CONTENT_NOT_DETERMINIST, /* 505 */
+    XML_DTD_DIFFERENT_PREFIX, /* 506 */
+    XML_DTD_ELEM_DEFAULT_NAMESPACE, /* 507 */
+    XML_DTD_ELEM_NAMESPACE, /* 508 */
+    XML_DTD_ELEM_REDEFINED, /* 509 */
+    XML_DTD_EMPTY_NOTATION, /* 510 */
+    XML_DTD_ENTITY_TYPE, /* 511 */
+    XML_DTD_ID_FIXED, /* 512 */
+    XML_DTD_ID_REDEFINED, /* 513 */
+    XML_DTD_ID_SUBSET, /* 514 */
+    XML_DTD_INVALID_CHILD, /* 515 */
+    XML_DTD_INVALID_DEFAULT, /* 516 */
+    XML_DTD_LOAD_ERROR, /* 517 */
+    XML_DTD_MISSING_ATTRIBUTE, /* 518 */
+    XML_DTD_MIXED_CORRUPT, /* 519 */
+    XML_DTD_MULTIPLE_ID, /* 520 */
+    XML_DTD_NO_DOC, /* 521 */
+    XML_DTD_NO_DTD, /* 522 */
+    XML_DTD_NO_ELEM_NAME, /* 523 */
+    XML_DTD_NO_PREFIX, /* 524 */
+    XML_DTD_NO_ROOT, /* 525 */
+    XML_DTD_NOTATION_REDEFINED, /* 526 */
+    XML_DTD_NOTATION_VALUE, /* 527 */
+    XML_DTD_NOT_EMPTY, /* 528 */
+    XML_DTD_NOT_PCDATA, /* 529 */
+    XML_DTD_NOT_STANDALONE, /* 530 */
+    XML_DTD_ROOT_NAME, /* 531 */
+    XML_DTD_STANDALONE_WHITE_SPACE, /* 532 */
+    XML_DTD_UNKNOWN_ATTRIBUTE, /* 533 */
+    XML_DTD_UNKNOWN_ELEM, /* 534 */
+    XML_DTD_UNKNOWN_ENTITY, /* 535 */
+    XML_DTD_UNKNOWN_ID, /* 536 */
+    XML_DTD_UNKNOWN_NOTATION, /* 537 */
+    XML_DTD_STANDALONE_DEFAULTED, /* 538 */
+    XML_DTD_XMLID_VALUE, /* 539 */
+    XML_DTD_XMLID_TYPE, /* 540 */
+    XML_HTML_STRUCURE_ERROR = 800,
+    XML_HTML_UNKNOWN_TAG, /* 801 */
+    XML_RNGP_ANYNAME_ATTR_ANCESTOR = 1000,
+    XML_RNGP_ATTR_CONFLICT, /* 1001 */
+    XML_RNGP_ATTRIBUTE_CHILDREN, /* 1002 */
+    XML_RNGP_ATTRIBUTE_CONTENT, /* 1003 */
+    XML_RNGP_ATTRIBUTE_EMPTY, /* 1004 */
+    XML_RNGP_ATTRIBUTE_NOOP, /* 1005 */
+    XML_RNGP_CHOICE_CONTENT, /* 1006 */
+    XML_RNGP_CHOICE_EMPTY, /* 1007 */
+    XML_RNGP_CREATE_FAILURE, /* 1008 */
+    XML_RNGP_DATA_CONTENT, /* 1009 */
+    XML_RNGP_DEF_CHOICE_AND_INTERLEAVE, /* 1010 */
+    XML_RNGP_DEFINE_CREATE_FAILED, /* 1011 */
+    XML_RNGP_DEFINE_EMPTY, /* 1012 */
+    XML_RNGP_DEFINE_MISSING, /* 1013 */
+    XML_RNGP_DEFINE_NAME_MISSING, /* 1014 */
+    XML_RNGP_ELEM_CONTENT_EMPTY, /* 1015 */
+    XML_RNGP_ELEM_CONTENT_ERROR, /* 1016 */
+    XML_RNGP_ELEMENT_EMPTY, /* 1017 */
+    XML_RNGP_ELEMENT_CONTENT, /* 1018 */
+    XML_RNGP_ELEMENT_NAME, /* 1019 */
+    XML_RNGP_ELEMENT_NO_CONTENT, /* 1020 */
+    XML_RNGP_ELEM_TEXT_CONFLICT, /* 1021 */
+    XML_RNGP_EMPTY, /* 1022 */
+    XML_RNGP_EMPTY_CONSTRUCT, /* 1023 */
+    XML_RNGP_EMPTY_CONTENT, /* 1024 */
+    XML_RNGP_EMPTY_NOT_EMPTY, /* 1025 */
+    XML_RNGP_ERROR_TYPE_LIB, /* 1026 */
+    XML_RNGP_EXCEPT_EMPTY, /* 1027 */
+    XML_RNGP_EXCEPT_MISSING, /* 1028 */
+    XML_RNGP_EXCEPT_MULTIPLE, /* 1029 */
+    XML_RNGP_EXCEPT_NO_CONTENT, /* 1030 */
+    XML_RNGP_EXTERNALREF_EMTPY, /* 1031 */
+    XML_RNGP_EXTERNAL_REF_FAILURE, /* 1032 */
+    XML_RNGP_EXTERNALREF_RECURSE, /* 1033 */
+    XML_RNGP_FORBIDDEN_ATTRIBUTE, /* 1034 */
+    XML_RNGP_FOREIGN_ELEMENT, /* 1035 */
+    XML_RNGP_GRAMMAR_CONTENT, /* 1036 */
+    XML_RNGP_GRAMMAR_EMPTY, /* 1037 */
+    XML_RNGP_GRAMMAR_MISSING, /* 1038 */
+    XML_RNGP_GRAMMAR_NO_START, /* 1039 */
+    XML_RNGP_GROUP_ATTR_CONFLICT, /* 1040 */
+    XML_RNGP_HREF_ERROR, /* 1041 */
+    XML_RNGP_INCLUDE_EMPTY, /* 1042 */
+    XML_RNGP_INCLUDE_FAILURE, /* 1043 */
+    XML_RNGP_INCLUDE_RECURSE, /* 1044 */
+    XML_RNGP_INTERLEAVE_ADD, /* 1045 */
+    XML_RNGP_INTERLEAVE_CREATE_FAILED, /* 1046 */
+    XML_RNGP_INTERLEAVE_EMPTY, /* 1047 */
+    XML_RNGP_INTERLEAVE_NO_CONTENT, /* 1048 */
+    XML_RNGP_INVALID_DEFINE_NAME, /* 1049 */
+    XML_RNGP_INVALID_URI, /* 1050 */
+    XML_RNGP_INVALID_VALUE, /* 1051 */
+    XML_RNGP_MISSING_HREF, /* 1052 */
+    XML_RNGP_NAME_MISSING, /* 1053 */
+    XML_RNGP_NEED_COMBINE, /* 1054 */
+    XML_RNGP_NOTALLOWED_NOT_EMPTY, /* 1055 */
+    XML_RNGP_NSNAME_ATTR_ANCESTOR, /* 1056 */
+    XML_RNGP_NSNAME_NO_NS, /* 1057 */
+    XML_RNGP_PARAM_FORBIDDEN, /* 1058 */
+    XML_RNGP_PARAM_NAME_MISSING, /* 1059 */
+    XML_RNGP_PARENTREF_CREATE_FAILED, /* 1060 */
+    XML_RNGP_PARENTREF_NAME_INVALID, /* 1061 */
+    XML_RNGP_PARENTREF_NO_NAME, /* 1062 */
+    XML_RNGP_PARENTREF_NO_PARENT, /* 1063 */
+    XML_RNGP_PARENTREF_NOT_EMPTY, /* 1064 */
+    XML_RNGP_PARSE_ERROR, /* 1065 */
+    XML_RNGP_PAT_ANYNAME_EXCEPT_ANYNAME, /* 1066 */
+    XML_RNGP_PAT_ATTR_ATTR, /* 1067 */
+    XML_RNGP_PAT_ATTR_ELEM, /* 1068 */
+    XML_RNGP_PAT_DATA_EXCEPT_ATTR, /* 1069 */
+    XML_RNGP_PAT_DATA_EXCEPT_ELEM, /* 1070 */
+    XML_RNGP_PAT_DATA_EXCEPT_EMPTY, /* 1071 */
+    XML_RNGP_PAT_DATA_EXCEPT_GROUP, /* 1072 */
+    XML_RNGP_PAT_DATA_EXCEPT_INTERLEAVE, /* 1073 */
+    XML_RNGP_PAT_DATA_EXCEPT_LIST, /* 1074 */
+    XML_RNGP_PAT_DATA_EXCEPT_ONEMORE, /* 1075 */
+    XML_RNGP_PAT_DATA_EXCEPT_REF, /* 1076 */
+    XML_RNGP_PAT_DATA_EXCEPT_TEXT, /* 1077 */
+    XML_RNGP_PAT_LIST_ATTR, /* 1078 */
+    XML_RNGP_PAT_LIST_ELEM, /* 1079 */
+    XML_RNGP_PAT_LIST_INTERLEAVE, /* 1080 */
+    XML_RNGP_PAT_LIST_LIST, /* 1081 */
+    XML_RNGP_PAT_LIST_REF, /* 1082 */
+    XML_RNGP_PAT_LIST_TEXT, /* 1083 */
+    XML_RNGP_PAT_NSNAME_EXCEPT_ANYNAME, /* 1084 */
+    XML_RNGP_PAT_NSNAME_EXCEPT_NSNAME, /* 1085 */
+    XML_RNGP_PAT_ONEMORE_GROUP_ATTR, /* 1086 */
+    XML_RNGP_PAT_ONEMORE_INTERLEAVE_ATTR, /* 1087 */
+    XML_RNGP_PAT_START_ATTR, /* 1088 */
+    XML_RNGP_PAT_START_DATA, /* 1089 */
+    XML_RNGP_PAT_START_EMPTY, /* 1090 */
+    XML_RNGP_PAT_START_GROUP, /* 1091 */
+    XML_RNGP_PAT_START_INTERLEAVE, /* 1092 */
+    XML_RNGP_PAT_START_LIST, /* 1093 */
+    XML_RNGP_PAT_START_ONEMORE, /* 1094 */
+    XML_RNGP_PAT_START_TEXT, /* 1095 */
+    XML_RNGP_PAT_START_VALUE, /* 1096 */
+    XML_RNGP_PREFIX_UNDEFINED, /* 1097 */
+    XML_RNGP_REF_CREATE_FAILED, /* 1098 */
+    XML_RNGP_REF_CYCLE, /* 1099 */
+    XML_RNGP_REF_NAME_INVALID, /* 1100 */
+    XML_RNGP_REF_NO_DEF, /* 1101 */
+    XML_RNGP_REF_NO_NAME, /* 1102 */
+    XML_RNGP_REF_NOT_EMPTY, /* 1103 */
+    XML_RNGP_START_CHOICE_AND_INTERLEAVE, /* 1104 */
+    XML_RNGP_START_CONTENT, /* 1105 */
+    XML_RNGP_START_EMPTY, /* 1106 */
+    XML_RNGP_START_MISSING, /* 1107 */
+    XML_RNGP_TEXT_EXPECTED, /* 1108 */
+    XML_RNGP_TEXT_HAS_CHILD, /* 1109 */
+    XML_RNGP_TYPE_MISSING, /* 1110 */
+    XML_RNGP_TYPE_NOT_FOUND, /* 1111 */
+    XML_RNGP_TYPE_VALUE, /* 1112 */
+    XML_RNGP_UNKNOWN_ATTRIBUTE, /* 1113 */
+    XML_RNGP_UNKNOWN_COMBINE, /* 1114 */
+    XML_RNGP_UNKNOWN_CONSTRUCT, /* 1115 */
+    XML_RNGP_UNKNOWN_TYPE_LIB, /* 1116 */
+    XML_RNGP_URI_FRAGMENT, /* 1117 */
+    XML_RNGP_URI_NOT_ABSOLUTE, /* 1118 */
+    XML_RNGP_VALUE_EMPTY, /* 1119 */
+    XML_RNGP_VALUE_NO_CONTENT, /* 1120 */
+    XML_RNGP_XMLNS_NAME, /* 1121 */
+    XML_RNGP_XML_NS, /* 1122 */
+    XML_XPATH_EXPRESSION_OK = 1200,
+    XML_XPATH_NUMBER_ERROR, /* 1201 */
+    XML_XPATH_UNFINISHED_LITERAL_ERROR, /* 1202 */
+    XML_XPATH_START_LITERAL_ERROR, /* 1203 */
+    XML_XPATH_VARIABLE_REF_ERROR, /* 1204 */
+    XML_XPATH_UNDEF_VARIABLE_ERROR, /* 1205 */
+    XML_XPATH_INVALID_PREDICATE_ERROR, /* 1206 */
+    XML_XPATH_EXPR_ERROR, /* 1207 */
+    XML_XPATH_UNCLOSED_ERROR, /* 1208 */
+    XML_XPATH_UNKNOWN_FUNC_ERROR, /* 1209 */
+    XML_XPATH_INVALID_OPERAND, /* 1210 */
+    XML_XPATH_INVALID_TYPE, /* 1211 */
+    XML_XPATH_INVALID_ARITY, /* 1212 */
+    XML_XPATH_INVALID_CTXT_SIZE, /* 1213 */
+    XML_XPATH_INVALID_CTXT_POSITION, /* 1214 */
+    XML_XPATH_MEMORY_ERROR, /* 1215 */
+    XML_XPTR_SYNTAX_ERROR, /* 1216 */
+    XML_XPTR_RESOURCE_ERROR, /* 1217 */
+    XML_XPTR_SUB_RESOURCE_ERROR, /* 1218 */
+    XML_XPATH_UNDEF_PREFIX_ERROR, /* 1219 */
+    XML_XPATH_ENCODING_ERROR, /* 1220 */
+    XML_XPATH_INVALID_CHAR_ERROR, /* 1221 */
+    XML_TREE_INVALID_HEX = 1300,
+    XML_TREE_INVALID_DEC, /* 1301 */
+    XML_TREE_UNTERMINATED_ENTITY, /* 1302 */
+    XML_SAVE_NOT_UTF8 = 1400,
+    XML_SAVE_CHAR_INVALID, /* 1401 */
+    XML_SAVE_NO_DOCTYPE, /* 1402 */
+    XML_SAVE_UNKNOWN_ENCODING, /* 1403 */
+    XML_REGEXP_COMPILE_ERROR = 1450,
+    XML_IO_UNKNOWN = 1500,
+    XML_IO_EACCES, /* 1501 */
+    XML_IO_EAGAIN, /* 1502 */
+    XML_IO_EBADF, /* 1503 */
+    XML_IO_EBADMSG, /* 1504 */
+    XML_IO_EBUSY, /* 1505 */
+    XML_IO_ECANCELED, /* 1506 */
+    XML_IO_ECHILD, /* 1507 */
+    XML_IO_EDEADLK, /* 1508 */
+    XML_IO_EDOM, /* 1509 */
+    XML_IO_EEXIST, /* 1510 */
+    XML_IO_EFAULT, /* 1511 */
+    XML_IO_EFBIG, /* 1512 */
+    XML_IO_EINPROGRESS, /* 1513 */
+    XML_IO_EINTR, /* 1514 */
+    XML_IO_EINVAL, /* 1515 */
+    XML_IO_EIO, /* 1516 */
+    XML_IO_EISDIR, /* 1517 */
+    XML_IO_EMFILE, /* 1518 */
+    XML_IO_EMLINK, /* 1519 */
+    XML_IO_EMSGSIZE, /* 1520 */
+    XML_IO_ENAMETOOLONG, /* 1521 */
+    XML_IO_ENFILE, /* 1522 */
+    XML_IO_ENODEV, /* 1523 */
+    XML_IO_ENOENT, /* 1524 */
+    XML_IO_ENOEXEC, /* 1525 */
+    XML_IO_ENOLCK, /* 1526 */
+    XML_IO_ENOMEM, /* 1527 */
+    XML_IO_ENOSPC, /* 1528 */
+    XML_IO_ENOSYS, /* 1529 */
+    XML_IO_ENOTDIR, /* 1530 */
+    XML_IO_ENOTEMPTY, /* 1531 */
+    XML_IO_ENOTSUP, /* 1532 */
+    XML_IO_ENOTTY, /* 1533 */
+    XML_IO_ENXIO, /* 1534 */
+    XML_IO_EPERM, /* 1535 */
+    XML_IO_EPIPE, /* 1536 */
+    XML_IO_ERANGE, /* 1537 */
+    XML_IO_EROFS, /* 1538 */
+    XML_IO_ESPIPE, /* 1539 */
+    XML_IO_ESRCH, /* 1540 */
+    XML_IO_ETIMEDOUT, /* 1541 */
+    XML_IO_EXDEV, /* 1542 */
+    XML_IO_NETWORK_ATTEMPT, /* 1543 */
+    XML_IO_ENCODER, /* 1544 */
+    XML_IO_FLUSH, /* 1545 */
+    XML_IO_WRITE, /* 1546 */
+    XML_IO_NO_INPUT, /* 1547 */
+    XML_IO_BUFFER_FULL, /* 1548 */
+    XML_IO_LOAD_ERROR, /* 1549 */
+    XML_IO_ENOTSOCK, /* 1550 */
+    XML_IO_EISCONN, /* 1551 */
+    XML_IO_ECONNREFUSED, /* 1552 */
+    XML_IO_ENETUNREACH, /* 1553 */
+    XML_IO_EADDRINUSE, /* 1554 */
+    XML_IO_EALREADY, /* 1555 */
+    XML_IO_EAFNOSUPPORT, /* 1556 */
+    XML_XINCLUDE_RECURSION=1600,
+    XML_XINCLUDE_PARSE_VALUE, /* 1601 */
+    XML_XINCLUDE_ENTITY_DEF_MISMATCH, /* 1602 */
+    XML_XINCLUDE_NO_HREF, /* 1603 */
+    XML_XINCLUDE_NO_FALLBACK, /* 1604 */
+    XML_XINCLUDE_HREF_URI, /* 1605 */
+    XML_XINCLUDE_TEXT_FRAGMENT, /* 1606 */
+    XML_XINCLUDE_TEXT_DOCUMENT, /* 1607 */
+    XML_XINCLUDE_INVALID_CHAR, /* 1608 */
+    XML_XINCLUDE_BUILD_FAILED, /* 1609 */
+    XML_XINCLUDE_UNKNOWN_ENCODING, /* 1610 */
+    XML_XINCLUDE_MULTIPLE_ROOT, /* 1611 */
+    XML_XINCLUDE_XPTR_FAILED, /* 1612 */
+    XML_XINCLUDE_XPTR_RESULT, /* 1613 */
+    XML_XINCLUDE_INCLUDE_IN_INCLUDE, /* 1614 */
+    XML_XINCLUDE_FALLBACKS_IN_INCLUDE, /* 1615 */
+    XML_XINCLUDE_FALLBACK_NOT_IN_INCLUDE, /* 1616 */
+    XML_XINCLUDE_DEPRECATED_NS, /* 1617 */
+    XML_XINCLUDE_FRAGMENT_ID, /* 1618 */
+    XML_CATALOG_MISSING_ATTR = 1650,
+    XML_CATALOG_ENTRY_BROKEN, /* 1651 */
+    XML_CATALOG_PREFER_VALUE, /* 1652 */
+    XML_CATALOG_NOT_CATALOG, /* 1653 */
+    XML_CATALOG_RECURSION, /* 1654 */
+    XML_SCHEMAP_PREFIX_UNDEFINED = 1700,
+    XML_SCHEMAP_ATTRFORMDEFAULT_VALUE, /* 1701 */
+    XML_SCHEMAP_ATTRGRP_NONAME_NOREF, /* 1702 */
+    XML_SCHEMAP_ATTR_NONAME_NOREF, /* 1703 */
+    XML_SCHEMAP_COMPLEXTYPE_NONAME_NOREF, /* 1704 */
+    XML_SCHEMAP_ELEMFORMDEFAULT_VALUE, /* 1705 */
+    XML_SCHEMAP_ELEM_NONAME_NOREF, /* 1706 */
+    XML_SCHEMAP_EXTENSION_NO_BASE, /* 1707 */
+    XML_SCHEMAP_FACET_NO_VALUE, /* 1708 */
+    XML_SCHEMAP_FAILED_BUILD_IMPORT, /* 1709 */
+    XML_SCHEMAP_GROUP_NONAME_NOREF, /* 1710 */
+    XML_SCHEMAP_IMPORT_NAMESPACE_NOT_URI, /* 1711 */
+    XML_SCHEMAP_IMPORT_REDEFINE_NSNAME, /* 1712 */
+    XML_SCHEMAP_IMPORT_SCHEMA_NOT_URI, /* 1713 */
+    XML_SCHEMAP_INVALID_BOOLEAN, /* 1714 */
+    XML_SCHEMAP_INVALID_ENUM, /* 1715 */
+    XML_SCHEMAP_INVALID_FACET, /* 1716 */
+    XML_SCHEMAP_INVALID_FACET_VALUE, /* 1717 */
+    XML_SCHEMAP_INVALID_MAXOCCURS, /* 1718 */
+    XML_SCHEMAP_INVALID_MINOCCURS, /* 1719 */
+    XML_SCHEMAP_INVALID_REF_AND_SUBTYPE, /* 1720 */
+    XML_SCHEMAP_INVALID_WHITE_SPACE, /* 1721 */
+    XML_SCHEMAP_NOATTR_NOREF, /* 1722 */
+    XML_SCHEMAP_NOTATION_NO_NAME, /* 1723 */
+    XML_SCHEMAP_NOTYPE_NOREF, /* 1724 */
+    XML_SCHEMAP_REF_AND_SUBTYPE, /* 1725 */
+    XML_SCHEMAP_RESTRICTION_NONAME_NOREF, /* 1726 */
+    XML_SCHEMAP_SIMPLETYPE_NONAME, /* 1727 */
+    XML_SCHEMAP_TYPE_AND_SUBTYPE, /* 1728 */
+    XML_SCHEMAP_UNKNOWN_ALL_CHILD, /* 1729 */
+    XML_SCHEMAP_UNKNOWN_ANYATTRIBUTE_CHILD, /* 1730 */
+    XML_SCHEMAP_UNKNOWN_ATTR_CHILD, /* 1731 */
+    XML_SCHEMAP_UNKNOWN_ATTRGRP_CHILD, /* 1732 */
+    XML_SCHEMAP_UNKNOWN_ATTRIBUTE_GROUP, /* 1733 */
+    XML_SCHEMAP_UNKNOWN_BASE_TYPE, /* 1734 */
+    XML_SCHEMAP_UNKNOWN_CHOICE_CHILD, /* 1735 */
+    XML_SCHEMAP_UNKNOWN_COMPLEXCONTENT_CHILD, /* 1736 */
+    XML_SCHEMAP_UNKNOWN_COMPLEXTYPE_CHILD, /* 1737 */
+    XML_SCHEMAP_UNKNOWN_ELEM_CHILD, /* 1738 */
+    XML_SCHEMAP_UNKNOWN_EXTENSION_CHILD, /* 1739 */
+    XML_SCHEMAP_UNKNOWN_FACET_CHILD, /* 1740 */
+    XML_SCHEMAP_UNKNOWN_FACET_TYPE, /* 1741 */
+    XML_SCHEMAP_UNKNOWN_GROUP_CHILD, /* 1742 */
+    XML_SCHEMAP_UNKNOWN_IMPORT_CHILD, /* 1743 */
+    XML_SCHEMAP_UNKNOWN_LIST_CHILD, /* 1744 */
+    XML_SCHEMAP_UNKNOWN_NOTATION_CHILD, /* 1745 */
+    XML_SCHEMAP_UNKNOWN_PROCESSCONTENT_CHILD, /* 1746 */
+    XML_SCHEMAP_UNKNOWN_REF, /* 1747 */
+    XML_SCHEMAP_UNKNOWN_RESTRICTION_CHILD, /* 1748 */
+    XML_SCHEMAP_UNKNOWN_SCHEMAS_CHILD, /* 1749 */
+    XML_SCHEMAP_UNKNOWN_SEQUENCE_CHILD, /* 1750 */
+    XML_SCHEMAP_UNKNOWN_SIMPLECONTENT_CHILD, /* 1751 */
+    XML_SCHEMAP_UNKNOWN_SIMPLETYPE_CHILD, /* 1752 */
+    XML_SCHEMAP_UNKNOWN_TYPE, /* 1753 */
+    XML_SCHEMAP_UNKNOWN_UNION_CHILD, /* 1754 */
+    XML_SCHEMAP_ELEM_DEFAULT_FIXED, /* 1755 */
+    XML_SCHEMAP_REGEXP_INVALID, /* 1756 */
+    XML_SCHEMAP_FAILED_LOAD, /* 1757 */
+    XML_SCHEMAP_NOTHING_TO_PARSE, /* 1758 */
+    XML_SCHEMAP_NOROOT, /* 1759 */
+    XML_SCHEMAP_REDEFINED_GROUP, /* 1760 */
+    XML_SCHEMAP_REDEFINED_TYPE, /* 1761 */
+    XML_SCHEMAP_REDEFINED_ELEMENT, /* 1762 */
+    XML_SCHEMAP_REDEFINED_ATTRGROUP, /* 1763 */
+    XML_SCHEMAP_REDEFINED_ATTR, /* 1764 */
+    XML_SCHEMAP_REDEFINED_NOTATION, /* 1765 */
+    XML_SCHEMAP_FAILED_PARSE, /* 1766 */
+    XML_SCHEMAP_UNKNOWN_PREFIX, /* 1767 */
+    XML_SCHEMAP_DEF_AND_PREFIX, /* 1768 */
+    XML_SCHEMAP_UNKNOWN_INCLUDE_CHILD, /* 1769 */
+    XML_SCHEMAP_INCLUDE_SCHEMA_NOT_URI, /* 1770 */
+    XML_SCHEMAP_INCLUDE_SCHEMA_NO_URI, /* 1771 */
+    XML_SCHEMAP_NOT_SCHEMA, /* 1772 */
+    XML_SCHEMAP_UNKNOWN_MEMBER_TYPE, /* 1773 */
+    XML_SCHEMAP_INVALID_ATTR_USE, /* 1774 */
+    XML_SCHEMAP_RECURSIVE, /* 1775 */
+    XML_SCHEMAP_SUPERNUMEROUS_LIST_ITEM_TYPE, /* 1776 */
+    XML_SCHEMAP_INVALID_ATTR_COMBINATION, /* 1777 */
+    XML_SCHEMAP_INVALID_ATTR_INLINE_COMBINATION, /* 1778 */
+    XML_SCHEMAP_MISSING_SIMPLETYPE_CHILD, /* 1779 */
+    XML_SCHEMAP_INVALID_ATTR_NAME, /* 1780 */
+    XML_SCHEMAP_REF_AND_CONTENT, /* 1781 */
+    XML_SCHEMAP_CT_PROPS_CORRECT_1, /* 1782 */
+    XML_SCHEMAP_CT_PROPS_CORRECT_2, /* 1783 */
+    XML_SCHEMAP_CT_PROPS_CORRECT_3, /* 1784 */
+    XML_SCHEMAP_CT_PROPS_CORRECT_4, /* 1785 */
+    XML_SCHEMAP_CT_PROPS_CORRECT_5, /* 1786 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_1, /* 1787 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_1, /* 1788 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_2, /* 1789 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_2, /* 1790 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_3, /* 1791 */
+    XML_SCHEMAP_WILDCARD_INVALID_NS_MEMBER, /* 1792 */
+    XML_SCHEMAP_INTERSECTION_NOT_EXPRESSIBLE, /* 1793 */
+    XML_SCHEMAP_UNION_NOT_EXPRESSIBLE, /* 1794 */
+    XML_SCHEMAP_SRC_IMPORT_3_1, /* 1795 */
+    XML_SCHEMAP_SRC_IMPORT_3_2, /* 1796 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_1, /* 1797 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_2, /* 1798 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_4_3, /* 1799 */
+    XML_SCHEMAP_COS_CT_EXTENDS_1_3, /* 1800 */
+    XML_SCHEMAV_NOROOT = 1801,
+    XML_SCHEMAV_UNDECLAREDELEM, /* 1802 */
+    XML_SCHEMAV_NOTTOPLEVEL, /* 1803 */
+    XML_SCHEMAV_MISSING, /* 1804 */
+    XML_SCHEMAV_WRONGELEM, /* 1805 */
+    XML_SCHEMAV_NOTYPE, /* 1806 */
+    XML_SCHEMAV_NOROLLBACK, /* 1807 */
+    XML_SCHEMAV_ISABSTRACT, /* 1808 */
+    XML_SCHEMAV_NOTEMPTY, /* 1809 */
+    XML_SCHEMAV_ELEMCONT, /* 1810 */
+    XML_SCHEMAV_HAVEDEFAULT, /* 1811 */
+    XML_SCHEMAV_NOTNILLABLE, /* 1812 */
+    XML_SCHEMAV_EXTRACONTENT, /* 1813 */
+    XML_SCHEMAV_INVALIDATTR, /* 1814 */
+    XML_SCHEMAV_INVALIDELEM, /* 1815 */
+    XML_SCHEMAV_NOTDETERMINIST, /* 1816 */
+    XML_SCHEMAV_CONSTRUCT, /* 1817 */
+    XML_SCHEMAV_INTERNAL, /* 1818 */
+    XML_SCHEMAV_NOTSIMPLE, /* 1819 */
+    XML_SCHEMAV_ATTRUNKNOWN, /* 1820 */
+    XML_SCHEMAV_ATTRINVALID, /* 1821 */
+    XML_SCHEMAV_VALUE, /* 1822 */
+    XML_SCHEMAV_FACET, /* 1823 */
+    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_1, /* 1824 */
+    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_2, /* 1825 */
+    XML_SCHEMAV_CVC_DATATYPE_VALID_1_2_3, /* 1826 */
+    XML_SCHEMAV_CVC_TYPE_3_1_1, /* 1827 */
+    XML_SCHEMAV_CVC_TYPE_3_1_2, /* 1828 */
+    XML_SCHEMAV_CVC_FACET_VALID, /* 1829 */
+    XML_SCHEMAV_CVC_LENGTH_VALID, /* 1830 */
+    XML_SCHEMAV_CVC_MINLENGTH_VALID, /* 1831 */
+    XML_SCHEMAV_CVC_MAXLENGTH_VALID, /* 1832 */
+    XML_SCHEMAV_CVC_MININCLUSIVE_VALID, /* 1833 */
+    XML_SCHEMAV_CVC_MAXINCLUSIVE_VALID, /* 1834 */
+    XML_SCHEMAV_CVC_MINEXCLUSIVE_VALID, /* 1835 */
+    XML_SCHEMAV_CVC_MAXEXCLUSIVE_VALID, /* 1836 */
+    XML_SCHEMAV_CVC_TOTALDIGITS_VALID, /* 1837 */
+    XML_SCHEMAV_CVC_FRACTIONDIGITS_VALID, /* 1838 */
+    XML_SCHEMAV_CVC_PATTERN_VALID, /* 1839 */
+    XML_SCHEMAV_CVC_ENUMERATION_VALID, /* 1840 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_1, /* 1841 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_2, /* 1842 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_3, /* 1843 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_2_4, /* 1844 */
+    XML_SCHEMAV_CVC_ELT_1, /* 1845 */
+    XML_SCHEMAV_CVC_ELT_2, /* 1846 */
+    XML_SCHEMAV_CVC_ELT_3_1, /* 1847 */
+    XML_SCHEMAV_CVC_ELT_3_2_1, /* 1848 */
+    XML_SCHEMAV_CVC_ELT_3_2_2, /* 1849 */
+    XML_SCHEMAV_CVC_ELT_4_1, /* 1850 */
+    XML_SCHEMAV_CVC_ELT_4_2, /* 1851 */
+    XML_SCHEMAV_CVC_ELT_4_3, /* 1852 */
+    XML_SCHEMAV_CVC_ELT_5_1_1, /* 1853 */
+    XML_SCHEMAV_CVC_ELT_5_1_2, /* 1854 */
+    XML_SCHEMAV_CVC_ELT_5_2_1, /* 1855 */  
+    XML_SCHEMAV_CVC_ELT_5_2_2_1, /* 1856 */
+    XML_SCHEMAV_CVC_ELT_5_2_2_2_1, /* 1857 */
+    XML_SCHEMAV_CVC_ELT_5_2_2_2_2, /* 1858 */
+    XML_SCHEMAV_CVC_ELT_6, /* 1859 */
+    XML_SCHEMAV_CVC_ELT_7, /* 1860 */
+    XML_SCHEMAV_CVC_ATTRIBUTE_1, /* 1861 */
+    XML_SCHEMAV_CVC_ATTRIBUTE_2, /* 1862 */
+    XML_SCHEMAV_CVC_ATTRIBUTE_3, /* 1863 */
+    XML_SCHEMAV_CVC_ATTRIBUTE_4, /* 1864 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_1, /* 1865 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_1, /* 1866 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_3_2_2, /* 1867 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_4, /* 1868 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_1, /* 1869 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_5_2, /* 1870 */
+    XML_SCHEMAV_ELEMENT_CONTENT, /* 1871 */
+    XML_SCHEMAV_DOCUMENT_ELEMENT_MISSING, /* 1872 */
+    XML_SCHEMAV_CVC_COMPLEX_TYPE_1, /* 1873 */
+    XML_SCHEMAV_CVC_AU, /* 1874 */
+    XML_SCHEMAV_CVC_TYPE_1, /* 1875 */
+    XML_SCHEMAV_CVC_TYPE_2, /* 1876 */
+    XML_SCHEMAV_CVC_IDC, /* 1877 */
+    XML_SCHEMAV_CVC_WILDCARD, /* 1878 */
+    XML_SCHEMAV_MISC, /* 1879 */
+    XML_XPTR_UNKNOWN_SCHEME = 1900, 
+    XML_XPTR_CHILDSEQ_START, /* 1901 */
+    XML_XPTR_EVAL_FAILED, /* 1902 */
+    XML_XPTR_EXTRA_OBJECTS, /* 1903 */
+    XML_C14N_CREATE_CTXT = 1950,
+    XML_C14N_REQUIRES_UTF8, /* 1951 */
+    XML_C14N_CREATE_STACK, /* 1952 */
+    XML_C14N_INVALID_NODE, /* 1953 */
+    XML_C14N_UNKNOW_NODE, /* 1954 */
+    XML_C14N_RELATIVE_NAMESPACE, /* 1955 */
+    XML_FTP_PASV_ANSWER = 2000,
+    XML_FTP_EPSV_ANSWER, /* 2001 */
+    XML_FTP_ACCNT, /* 2002 */
+    XML_FTP_URL_SYNTAX, /* 2003 */
+    XML_HTTP_URL_SYNTAX = 2020,
+    XML_HTTP_USE_IP, /* 2021 */
+    XML_HTTP_UNKNOWN_HOST, /* 2022 */
+    XML_SCHEMAP_SRC_SIMPLE_TYPE_1 = 3000,
+    XML_SCHEMAP_SRC_SIMPLE_TYPE_2, /* 3001 */
+    XML_SCHEMAP_SRC_SIMPLE_TYPE_3, /* 3002 */
+    XML_SCHEMAP_SRC_SIMPLE_TYPE_4, /* 3003 */
+    XML_SCHEMAP_SRC_RESOLVE, /* 3004 */ 
+    XML_SCHEMAP_SRC_RESTRICTION_BASE_OR_SIMPLETYPE, /* 3005 */
+    XML_SCHEMAP_SRC_LIST_ITEMTYPE_OR_SIMPLETYPE, /* 3006 */
+    XML_SCHEMAP_SRC_UNION_MEMBERTYPES_OR_SIMPLETYPES, /* 3007 */
+    XML_SCHEMAP_ST_PROPS_CORRECT_1, /* 3008 */
+    XML_SCHEMAP_ST_PROPS_CORRECT_2, /* 3009 */
+    XML_SCHEMAP_ST_PROPS_CORRECT_3, /* 3010 */     
+    XML_SCHEMAP_COS_ST_RESTRICTS_1_1, /* 3011 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_1_2, /* 3012 */    
+    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_1, /* 3013 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_1_3_2, /* 3014 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_1, /* 3015 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_1, /* 3016 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_1_2, /* 3017 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_1, /* 3018 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_2, /* 3019 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_3, /* 3020 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_4, /* 3021 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_2_3_2_5, /* 3022 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_1, /* 3023 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1, /* 3024 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_1_2, /* 3025 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_2, /* 3026 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_1, /* 3027 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_3, /* 3028 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_4, /* 3029 */
+    XML_SCHEMAP_COS_ST_RESTRICTS_3_3_2_5, /* 3030 */
+    XML_SCHEMAP_COS_ST_DERIVED_OK_2_1, /* 3031 */ 
+    XML_SCHEMAP_COS_ST_DERIVED_OK_2_2, /* 3032 */
+    XML_SCHEMAP_S4S_ELEM_NOT_ALLOWED, /* 3033 */
+    XML_SCHEMAP_S4S_ELEM_MISSING, /* 3034 */
+    XML_SCHEMAP_S4S_ATTR_NOT_ALLOWED, /* 3035 */
+    XML_SCHEMAP_S4S_ATTR_MISSING, /* 3036 */
+    XML_SCHEMAP_S4S_ATTR_INVALID_VALUE, /* 3037 */
+    XML_SCHEMAP_SRC_ELEMENT_1, /* 3038 */
+    XML_SCHEMAP_SRC_ELEMENT_2_1, /* 3039 */
+    XML_SCHEMAP_SRC_ELEMENT_2_2, /* 3040 */
+    XML_SCHEMAP_SRC_ELEMENT_3, /* 3041 */
+    XML_SCHEMAP_P_PROPS_CORRECT_1, /* 3042 */
+    XML_SCHEMAP_P_PROPS_CORRECT_2_1, /* 3043 */
+    XML_SCHEMAP_P_PROPS_CORRECT_2_2, /* 3044 */
+    XML_SCHEMAP_E_PROPS_CORRECT_2, /* 3045 */
+    XML_SCHEMAP_E_PROPS_CORRECT_3, /* 3046 */
+    XML_SCHEMAP_E_PROPS_CORRECT_4, /* 3047 */
+    XML_SCHEMAP_E_PROPS_CORRECT_5, /* 3048 */
+    XML_SCHEMAP_E_PROPS_CORRECT_6, /* 3049 */
+    XML_SCHEMAP_SRC_INCLUDE, /* 3050 */    
+    XML_SCHEMAP_SRC_ATTRIBUTE_1, /* 3051 */
+    XML_SCHEMAP_SRC_ATTRIBUTE_2, /* 3052 */
+    XML_SCHEMAP_SRC_ATTRIBUTE_3_1, /* 3053 */
+    XML_SCHEMAP_SRC_ATTRIBUTE_3_2, /* 3054 */
+    XML_SCHEMAP_SRC_ATTRIBUTE_4, /* 3055 */
+    XML_SCHEMAP_NO_XMLNS, /* 3056 */
+    XML_SCHEMAP_NO_XSI, /* 3057 */      
+    XML_SCHEMAP_COS_VALID_DEFAULT_1, /* 3058 */
+    XML_SCHEMAP_COS_VALID_DEFAULT_2_1, /* 3059 */
+    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_1, /* 3060 */
+    XML_SCHEMAP_COS_VALID_DEFAULT_2_2_2, /* 3061 */
+    XML_SCHEMAP_CVC_SIMPLE_TYPE, /* 3062 */
+    XML_SCHEMAP_COS_CT_EXTENDS_1_1, /* 3063 */
+    XML_SCHEMAP_SRC_IMPORT_1_1, /* 3064 */
+    XML_SCHEMAP_SRC_IMPORT_1_2, /* 3065 */
+    XML_SCHEMAP_SRC_IMPORT_2, /* 3066 */
+    XML_SCHEMAP_SRC_IMPORT_2_1, /* 3067 */
+    XML_SCHEMAP_SRC_IMPORT_2_2, /* 3068 */
+    XML_SCHEMAP_INTERNAL, /* 3069 non-W3C */
+    XML_SCHEMAP_NOT_DETERMINISTIC, /* 3070 non-W3C */
+    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_1, /* 3071 */
+    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_2, /* 3072 */
+    XML_SCHEMAP_SRC_ATTRIBUTE_GROUP_3, /* 3073 */
+    XML_SCHEMAP_MG_PROPS_CORRECT_1, /* 3074 */
+    XML_SCHEMAP_MG_PROPS_CORRECT_2, /* 3075 */
+    XML_SCHEMAP_SRC_CT_1, /* 3076 */
+    XML_SCHEMAP_DERIVATION_OK_RESTRICTION_2_1_3, /* 3077 */
+    XML_SCHEMAP_AU_PROPS_CORRECT_2, /* 3078 */
+    XML_SCHEMAP_A_PROPS_CORRECT_2, /* 3079 */
+    XML_SCHEMAP_C_PROPS_CORRECT, /* 3080 */
+    XML_SCHEMAP_SRC_REDEFINE, /* 3081 */
+    XML_SCHEMAP_SRC_IMPORT, /* 3082 */
+    XML_SCHEMAP_WARN_SKIP_SCHEMA, /* 3083 */
+    XML_SCHEMAP_WARN_UNLOCATED_SCHEMA, /* 3084 */
+    XML_SCHEMAP_WARN_ATTR_REDECL_PROH, /* 3085 */
+    XML_SCHEMAP_WARN_ATTR_POINTLESS_PROH, /* 3085 */
+    XML_SCHEMAP_AG_PROPS_CORRECT, /* 3086 */
+    XML_SCHEMAP_COS_CT_EXTENDS_1_2, /* 3087 */
+    XML_SCHEMAP_AU_PROPS_CORRECT, /* 3088 */
+    XML_SCHEMAP_A_PROPS_CORRECT_3, /* 3089 */
+    XML_SCHEMAP_COS_ALL_LIMITED, /* 3090 */
+    XML_MODULE_OPEN = 4900, /* 4900 */
+    XML_MODULE_CLOSE, /* 4901 */
+    XML_CHECK_FOUND_ELEMENT = 5000,
+    XML_CHECK_FOUND_ATTRIBUTE, /* 5001 */
+    XML_CHECK_FOUND_TEXT, /* 5002 */
+    XML_CHECK_FOUND_CDATA, /* 5003 */
+    XML_CHECK_FOUND_ENTITYREF, /* 5004 */
+    XML_CHECK_FOUND_ENTITY, /* 5005 */
+    XML_CHECK_FOUND_PI, /* 5006 */
+    XML_CHECK_FOUND_COMMENT, /* 5007 */
+    XML_CHECK_FOUND_DOCTYPE, /* 5008 */
+    XML_CHECK_FOUND_FRAGMENT, /* 5009 */
+    XML_CHECK_FOUND_NOTATION, /* 5010 */
+    XML_CHECK_UNKNOWN_NODE, /* 5011 */
+    XML_CHECK_ENTITY_TYPE, /* 5012 */
+    XML_CHECK_NO_PARENT, /* 5013 */
+    XML_CHECK_NO_DOC, /* 5014 */
+    XML_CHECK_NO_NAME, /* 5015 */
+    XML_CHECK_NO_ELEM, /* 5016 */
+    XML_CHECK_WRONG_DOC, /* 5017 */
+    XML_CHECK_NO_PREV, /* 5018 */
+    XML_CHECK_WRONG_PREV, /* 5019 */
+    XML_CHECK_NO_NEXT, /* 5020 */
+    XML_CHECK_WRONG_NEXT, /* 5021 */
+    XML_CHECK_NOT_DTD, /* 5022 */
+    XML_CHECK_NOT_ATTR, /* 5023 */
+    XML_CHECK_NOT_ATTR_DECL, /* 5024 */
+    XML_CHECK_NOT_ELEM_DECL, /* 5025 */
+    XML_CHECK_NOT_ENTITY_DECL, /* 5026 */
+    XML_CHECK_NOT_NS_DECL, /* 5027 */
+    XML_CHECK_NO_HREF, /* 5028 */
+    XML_CHECK_WRONG_PARENT,/* 5029 */
+    XML_CHECK_NS_SCOPE, /* 5030 */
+    XML_CHECK_NS_ANCESTOR, /* 5031 */
+    XML_CHECK_NOT_UTF8, /* 5032 */
+    XML_CHECK_NO_DICT, /* 5033 */
+    XML_CHECK_NOT_NCNAME, /* 5034 */
+    XML_CHECK_OUTSIDE_DICT, /* 5035 */
+    XML_CHECK_WRONG_NAME, /* 5036 */
+    XML_CHECK_NAME_NOT_NULL, /* 5037 */
+    XML_I18N_NO_NAME = 6000,
+    XML_I18N_NO_HANDLER, /* 6001 */
+    XML_I18N_EXCESS_HANDLER, /* 6002 */
+    XML_I18N_CONV_FAILED, /* 6003 */
+    XML_I18N_NO_OUTPUT /* 6004 */
+#if 0
+    XML_CHECK_, /* 5033 */
+    XML_CHECK_X /* 503 */
+#endif
+} xmlParserErrors;
+
+/**
+ * xmlGenericErrorFunc:
+ * @ctx:  a parsing context
+ * @msg:  the message
+ * @...:  the extra arguments of the varags to format the message
+ *
+ * Signature of the function to use when there is an error and
+ * no parsing or validity context available .
+ */
+typedef void (XMLCDECL *xmlGenericErrorFunc) (void *ctx,
+				 const char *msg,
+	 			 ...);
+/**
+ * xmlStructuredErrorFunc:
+ * @userData:  user provided data for the error callback
+ * @error:  the error being raised.
+ *
+ * Signature of the function to use when there is an error and
+ * the module handles the new error reporting mechanism.
+ */
+typedef void (XMLCALL *xmlStructuredErrorFunc) (void *userData, xmlErrorPtr error);
+
+/*
+ * Use the following function to reset the two global variables
+ * xmlGenericError and xmlGenericErrorContext.
+ */
+XMLPUBFUN void XMLCALL	
+    xmlSetGenericErrorFunc	(void *ctx,
+				 xmlGenericErrorFunc handler);
+XMLPUBFUN void XMLCALL	
+    initGenericErrorDefaultFunc	(xmlGenericErrorFunc *handler);
+
+XMLPUBFUN void XMLCALL	
+    xmlSetStructuredErrorFunc	(void *ctx,
+				 xmlStructuredErrorFunc handler);
+/*
+ * Default message routines used by SAX and Valid context for error
+ * and warning reporting.
+ */
+XMLPUBFUN void XMLCDECL	
+    xmlParserError		(void *ctx,
+				 const char *msg,
+				 ...);
+XMLPUBFUN void XMLCDECL	
+    xmlParserWarning		(void *ctx,
+				 const char *msg,
+				 ...);
+XMLPUBFUN void XMLCDECL	
+    xmlParserValidityError	(void *ctx,
+				 const char *msg,
+				 ...);
+XMLPUBFUN void XMLCDECL	
+    xmlParserValidityWarning	(void *ctx,
+				 const char *msg,
+				 ...);
+XMLPUBFUN void XMLCALL	
+    xmlParserPrintFileInfo	(xmlParserInputPtr input);
+XMLPUBFUN void XMLCALL	
+    xmlParserPrintFileContext	(xmlParserInputPtr input);
+
+/*
+ * Extended error information routines
+ */
+XMLPUBFUN xmlErrorPtr XMLCALL
+    xmlGetLastError		(void);
+XMLPUBFUN void XMLCALL
+    xmlResetLastError		(void);
+XMLPUBFUN xmlErrorPtr XMLCALL
+    xmlCtxtGetLastError		(void *ctx);
+XMLPUBFUN void XMLCALL
+    xmlCtxtResetLastError	(void *ctx);
+XMLPUBFUN void XMLCALL
+    xmlResetError		(xmlErrorPtr err);
+XMLPUBFUN int XMLCALL
+    xmlCopyError		(xmlErrorPtr from,
+    				 xmlErrorPtr to);
+
+#ifdef IN_LIBXML
+/*
+ * Internal callback reporting routine
+ */
+XMLPUBFUN void XMLCALL 
+    __xmlRaiseError		(xmlStructuredErrorFunc schannel,
+    				 xmlGenericErrorFunc channel,
+    				 void *data,
+                                 void *ctx,
+    				 void *node,
+    				 int domain,
+				 int code,
+				 xmlErrorLevel level,
+				 const char *file,
+				 int line,
+				 const char *str1,
+				 const char *str2,
+				 const char *str3,
+				 int int1,
+				 int col,
+				 const char *msg,
+				 ...);
+XMLPUBFUN void XMLCALL 
+    __xmlSimpleError		(int domain,
+    				 int code,
+				 xmlNodePtr node,
+				 const char *msg,
+				 const char *extra);
+#endif
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_ERROR_H__ */
diff -Naur orig.ns-2.33/libxml/xmlexports.h ns-2.33/libxml/xmlexports.h
--- orig.ns-2.33/libxml/xmlexports.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlexports.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,157 @@
+/*
+ * Summary: macros for marking symbols as exportable/importable.
+ * Description: macros for marking symbols as exportable/importable.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Igor Zlatovic <igor@zlatkovic.com>
+ */
+
+#ifndef __XML_EXPORTS_H__
+#define __XML_EXPORTS_H__
+
+/**
+ * XMLPUBFUN, XMLPUBVAR, XMLCALL
+ *
+ * Macros which declare an exportable function, an exportable variable and
+ * the calling convention used for functions.
+ *
+ * Please use an extra block for every platform/compiler combination when
+ * modifying this, rather than overlong #ifdef lines. This helps
+ * readability as well as the fact that different compilers on the same
+ * platform might need different definitions.
+ */
+
+/**
+ * XMLPUBFUN:
+ *
+ * Macros which declare an exportable function
+ */
+#define XMLPUBFUN
+/**
+ * XMLPUBVAR:
+ *
+ * Macros which declare an exportable variable
+ */
+#define XMLPUBVAR extern
+/**
+ * XMLCALL:
+ *
+ * Macros which declare the called convention for exported functions
+ */
+#define XMLCALL
+/**
+ * XMLCDECL:
+ *
+ * Macro which declares the calling convention for exported functions that 
+ * use '...'.
+ */
+#define XMLCDECL
+
+/** DOC_DISABLE */
+
+/* Windows platform with MS compiler */
+#if defined(_WIN32) && defined(_MSC_VER)
+  #undef XMLPUBFUN
+  #undef XMLPUBVAR
+  #undef XMLCALL
+  #undef XMLCDECL
+  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
+    #define XMLPUBFUN __declspec(dllexport)
+    #define XMLPUBVAR __declspec(dllexport)
+  #else
+    #define XMLPUBFUN
+    #if !defined(LIBXML_STATIC)
+      #define XMLPUBVAR __declspec(dllimport) extern
+    #else
+      #define XMLPUBVAR extern
+    #endif
+  #endif
+  #if defined(LIBXML_FASTCALL)
+    #define XMLCALL __fastcall
+  #else
+    #define XMLCALL __cdecl
+  #endif
+  #define XMLCDECL __cdecl
+  #if !defined _REENTRANT
+    #define _REENTRANT
+  #endif
+#endif
+
+/* Windows platform with Borland compiler */
+#if defined(_WIN32) && defined(__BORLANDC__)
+  #undef XMLPUBFUN
+  #undef XMLPUBVAR
+  #undef XMLCALL
+  #undef XMLCDECL
+  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
+    #define XMLPUBFUN __declspec(dllexport)
+    #define XMLPUBVAR __declspec(dllexport) extern
+  #else
+    #define XMLPUBFUN
+    #if !defined(LIBXML_STATIC)
+      #define XMLPUBVAR __declspec(dllimport) extern
+    #else
+      #define XMLPUBVAR extern
+    #endif
+  #endif
+  #define XMLCALL __cdecl
+  #define XMLCDECL __cdecl
+  #if !defined _REENTRANT
+    #define _REENTRANT
+  #endif
+#endif
+
+/* Windows platform with GNU compiler (Mingw) */
+#if defined(_WIN32) && defined(__MINGW32__)
+  #undef XMLPUBFUN
+  #undef XMLPUBVAR
+  #undef XMLCALL
+  #undef XMLCDECL
+  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
+    #define XMLPUBFUN __declspec(dllexport)
+    #define XMLPUBVAR __declspec(dllexport)
+  #else
+    #define XMLPUBFUN
+    #if !defined(LIBXML_STATIC)
+      #define XMLPUBVAR __declspec(dllimport) extern
+    #else
+      #define XMLPUBVAR extern
+    #endif
+  #endif
+  #define XMLCALL __cdecl
+  #define XMLCDECL __cdecl
+  #if !defined _REENTRANT
+    #define _REENTRANT
+  #endif
+#endif
+
+/* Cygwin platform, GNU compiler */
+#if defined(_WIN32) && defined(__CYGWIN__)
+  #undef XMLPUBFUN
+  #undef XMLPUBVAR
+  #undef XMLCALL
+  #undef XMLCDECL
+  #if defined(IN_LIBXML) && !defined(LIBXML_STATIC)
+    #define XMLPUBFUN __declspec(dllexport)
+    #define XMLPUBVAR __declspec(dllexport)
+  #else
+    #define XMLPUBFUN
+    #if !defined(LIBXML_STATIC)
+      #define XMLPUBVAR __declspec(dllimport) extern
+    #else
+      #define XMLPUBVAR
+    #endif
+  #endif
+  #define XMLCALL __cdecl
+  #define XMLCDECL __cdecl
+#endif
+
+/* Compatibility */
+#if !defined(LIBXML_DLL_IMPORT)
+#define LIBXML_DLL_IMPORT XMLPUBVAR
+#endif
+
+#endif /* __XML_EXPORTS_H__ */
+
+
diff -Naur orig.ns-2.33/libxml/xmlmemory.h ns-2.33/libxml/xmlmemory.h
--- orig.ns-2.33/libxml/xmlmemory.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlmemory.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,222 @@
+/*
+ * Summary: interface for the memory allocator
+ * Description: provides interfaces for the memory allocator,
+ *              including debugging capabilities.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __DEBUG_MEMORY_ALLOC__
+#define __DEBUG_MEMORY_ALLOC__
+
+#include <stdio.h>
+#include <libxml/xmlversion.h>
+
+/**
+ * DEBUG_MEMORY:
+ *
+ * DEBUG_MEMORY replaces the allocator with a collect and debug
+ * shell to the libc allocator.
+ * DEBUG_MEMORY should only be activated when debugging 
+ * libxml i.e. if libxml has been configured with --with-debug-mem too.
+ */
+/* #define DEBUG_MEMORY_FREED */
+/* #define DEBUG_MEMORY_LOCATION */
+
+#ifdef DEBUG
+#ifndef DEBUG_MEMORY
+#define DEBUG_MEMORY
+#endif
+#endif
+
+/**
+ * DEBUG_MEMORY_LOCATION:
+ *
+ * DEBUG_MEMORY_LOCATION should be activated only when debugging 
+ * libxml i.e. if libxml has been configured with --with-debug-mem too.
+ */
+#ifdef DEBUG_MEMORY_LOCATION
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The XML memory wrapper support 4 basic overloadable functions.
+ */
+/**
+ * xmlFreeFunc:
+ * @mem: an already allocated block of memory
+ *
+ * Signature for a free() implementation.
+ */
+typedef void (XMLCALL *xmlFreeFunc)(void *mem);
+/**
+ * xmlMallocFunc:
+ * @size:  the size requested in bytes
+ *
+ * Signature for a malloc() implementation.
+ *
+ * Returns a pointer to the newly allocated block or NULL in case of error.
+ */
+typedef void *(XMLCALL *xmlMallocFunc)(size_t size);
+
+/**
+ * xmlReallocFunc:
+ * @mem: an already allocated block of memory
+ * @size:  the new size requested in bytes
+ *
+ * Signature for a realloc() implementation.
+ *
+ * Returns a pointer to the newly reallocated block or NULL in case of error.
+ */
+typedef void *(XMLCALL *xmlReallocFunc)(void *mem, size_t size);
+
+/**
+ * xmlStrdupFunc:
+ * @str: a zero terminated string
+ *
+ * Signature for an strdup() implementation.
+ *
+ * Returns the copy of the string or NULL in case of error.
+ */
+typedef char *(XMLCALL *xmlStrdupFunc)(const char *str);
+
+/*
+ * The 4 interfaces used for all memory handling within libxml.
+LIBXML_DLL_IMPORT extern xmlFreeFunc xmlFree;
+LIBXML_DLL_IMPORT extern xmlMallocFunc xmlMalloc;
+LIBXML_DLL_IMPORT extern xmlMallocFunc xmlMallocAtomic;
+LIBXML_DLL_IMPORT extern xmlReallocFunc xmlRealloc;
+LIBXML_DLL_IMPORT extern xmlStrdupFunc xmlMemStrdup;
+ */
+
+/*
+ * The way to overload the existing functions.
+ * The xmlGc function have an extra entry for atomic block
+ * allocations useful for garbage collected memory allocators
+ */
+XMLPUBFUN int XMLCALL
+	xmlMemSetup	(xmlFreeFunc freeFunc,
+			 xmlMallocFunc mallocFunc,
+			 xmlReallocFunc reallocFunc,
+			 xmlStrdupFunc strdupFunc);
+XMLPUBFUN int XMLCALL     
+	xmlMemGet	(xmlFreeFunc *freeFunc,
+			 xmlMallocFunc *mallocFunc,
+			 xmlReallocFunc *reallocFunc,
+			 xmlStrdupFunc *strdupFunc);
+XMLPUBFUN int XMLCALL     
+	xmlGcMemSetup	(xmlFreeFunc freeFunc,
+			 xmlMallocFunc mallocFunc,
+			 xmlMallocFunc mallocAtomicFunc,
+			 xmlReallocFunc reallocFunc,
+			 xmlStrdupFunc strdupFunc);
+XMLPUBFUN int XMLCALL     
+	xmlGcMemGet	(xmlFreeFunc *freeFunc,
+			 xmlMallocFunc *mallocFunc,
+			 xmlMallocFunc *mallocAtomicFunc,
+			 xmlReallocFunc *reallocFunc,
+			 xmlStrdupFunc *strdupFunc);
+
+/*
+ * Initialization of the memory layer.
+ */
+XMLPUBFUN int XMLCALL	
+	xmlInitMemory	(void);
+
+/* 
+ * Cleanup of the memory layer.
+ */
+XMLPUBFUN void XMLCALL                
+                xmlCleanupMemory        (void);
+/*
+ * These are specific to the XML debug memory wrapper.
+ */
+XMLPUBFUN int XMLCALL	
+	xmlMemUsed	(void);
+XMLPUBFUN int XMLCALL	
+	xmlMemBlocks	(void);
+XMLPUBFUN void XMLCALL	
+	xmlMemDisplay	(FILE *fp);
+XMLPUBFUN void XMLCALL	
+	xmlMemShow	(FILE *fp, int nr);
+XMLPUBFUN void XMLCALL	
+	xmlMemoryDump	(void);
+XMLPUBFUN void * XMLCALL	
+	xmlMemMalloc	(size_t size);
+XMLPUBFUN void * XMLCALL	
+	xmlMemRealloc	(void *ptr,size_t size);
+XMLPUBFUN void XMLCALL	
+	xmlMemFree	(void *ptr);
+XMLPUBFUN char * XMLCALL	
+	xmlMemoryStrdup	(const char *str);
+XMLPUBFUN void * XMLCALL  
+	xmlMallocLoc	(size_t size, const char *file, int line);
+XMLPUBFUN void * XMLCALL	
+	xmlReallocLoc	(void *ptr, size_t size, const char *file, int line);
+XMLPUBFUN void * XMLCALL	
+	xmlMallocAtomicLoc (size_t size, const char *file, int line);
+XMLPUBFUN char * XMLCALL	
+	xmlMemStrdupLoc	(const char *str, const char *file, int line);
+
+
+#ifdef DEBUG_MEMORY_LOCATION
+/**
+ * xmlMalloc:
+ * @size:  number of bytes to allocate
+ *
+ * Wrapper for the malloc() function used in the XML library.
+ *
+ * Returns the pointer to the allocated area or NULL in case of error.
+ */
+#define xmlMalloc(size) xmlMallocLoc((size), __FILE__, __LINE__)
+/**
+ * xmlMallocAtomic:
+ * @size:  number of bytes to allocate
+ *
+ * Wrapper for the malloc() function used in the XML library for allocation
+ * of block not containing pointers to other areas.
+ *
+ * Returns the pointer to the allocated area or NULL in case of error.
+ */
+#define xmlMallocAtomic(size) xmlMallocAtomicLoc((size), __FILE__, __LINE__)
+/**
+ * xmlRealloc:
+ * @ptr:  pointer to the existing allocated area
+ * @size:  number of bytes to allocate
+ *
+ * Wrapper for the realloc() function used in the XML library.
+ *
+ * Returns the pointer to the allocated area or NULL in case of error.
+ */
+#define xmlRealloc(ptr, size) xmlReallocLoc((ptr), (size), __FILE__, __LINE__)
+/**
+ * xmlMemStrdup:
+ * @str:  pointer to the existing string
+ *
+ * Wrapper for the strdup() function, xmlStrdup() is usually preferred.
+ *
+ * Returns the pointer to the allocated area or NULL in case of error.
+ */
+#define xmlMemStrdup(str) xmlMemStrdupLoc((str), __FILE__, __LINE__)
+
+#endif /* DEBUG_MEMORY_LOCATION */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#ifndef __XML_GLOBALS_H
+#ifndef __XML_THREADS_H__
+#include <libxml/threads.h>
+#include <libxml/globals.h>
+#endif
+#endif
+
+#endif  /* __DEBUG_MEMORY_ALLOC__ */
+
diff -Naur orig.ns-2.33/libxml/xmlmodule.h ns-2.33/libxml/xmlmodule.h
--- orig.ns-2.33/libxml/xmlmodule.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlmodule.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,57 @@
+/*
+ * Summary: dynamic module loading
+ * Description: basic API for dynamic module loading, used by
+ *              libexslt added in 2.6.17
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Joel W. Reed
+ */
+
+#ifndef __XML_MODULE_H__
+#define __XML_MODULE_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_MODULES_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlModulePtr:
+ *
+ * A handle to a dynamically loaded module
+ */
+typedef struct _xmlModule xmlModule;
+typedef xmlModule *xmlModulePtr;
+
+/**
+ * xmlModuleOption:
+ *
+ * enumeration of options that can be passed down to xmlModuleOpen()
+ */
+typedef enum {
+    XML_MODULE_LAZY = 1,	/* lazy binding */
+    XML_MODULE_LOCAL= 2		/* local binding */
+} xmlModuleOption;
+
+XMLPUBFUN xmlModulePtr XMLCALL xmlModuleOpen	(const char *filename,
+						 int options);
+
+XMLPUBFUN int XMLCALL xmlModuleSymbol		(xmlModulePtr module,
+						 const char* name,
+						 void **result);
+
+XMLPUBFUN int XMLCALL xmlModuleClose		(xmlModulePtr module);
+
+XMLPUBFUN int XMLCALL xmlModuleFree		(xmlModulePtr module);
+
+#ifdef __cplusplus
+}
+#endif 
+
+#endif /* LIBXML_MODULES_ENABLED */
+
+#endif /*__XML_MODULE_H__ */
diff -Naur orig.ns-2.33/libxml/xmlreader.h ns-2.33/libxml/xmlreader.h
--- orig.ns-2.33/libxml/xmlreader.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlreader.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,414 @@
+/*
+ * Summary: the XMLReader implementation
+ * Description: API of the XML streaming API based on C# interfaces.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XMLREADER_H__
+#define __XML_XMLREADER_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+#include <libxml/xmlIO.h>
+#ifdef LIBXML_SCHEMAS_ENABLED
+#include <libxml/relaxng.h>
+#include <libxml/xmlschemas.h>
+#endif
+
+#ifdef LIBXML_READER_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlTextReaderMode:
+ *
+ * Internal state values for the reader.
+ */
+typedef enum {
+    XML_TEXTREADER_MODE_INITIAL = 0,
+    XML_TEXTREADER_MODE_INTERACTIVE = 1,
+    XML_TEXTREADER_MODE_ERROR = 2,
+    XML_TEXTREADER_MODE_EOF =3,
+    XML_TEXTREADER_MODE_CLOSED = 4,
+    XML_TEXTREADER_MODE_READING = 5
+} xmlTextReaderMode;
+
+/**
+ * xmlParserProperties:
+ *
+ * Some common options to use with xmlTextReaderSetParserProp, but it
+ * is better to use xmlParserOption and the xmlReaderNewxxx and 
+ * xmlReaderForxxx APIs now.
+ */
+typedef enum {
+    XML_PARSER_LOADDTD = 1,
+    XML_PARSER_DEFAULTATTRS = 2,
+    XML_PARSER_VALIDATE = 3,
+    XML_PARSER_SUBST_ENTITIES = 4
+} xmlParserProperties;
+
+/**
+ * xmlParserSeverities:
+ *
+ * How severe an error callback is when the per-reader error callback API
+ * is used.
+ */
+typedef enum {
+    XML_PARSER_SEVERITY_VALIDITY_WARNING = 1,
+    XML_PARSER_SEVERITY_VALIDITY_ERROR = 2,
+    XML_PARSER_SEVERITY_WARNING = 3,
+    XML_PARSER_SEVERITY_ERROR = 4
+} xmlParserSeverities;
+
+/**
+ * xmlReaderTypes:
+ *
+ * Predefined constants for the different types of nodes.
+ */
+typedef enum {
+    XML_READER_TYPE_NONE = 0,
+    XML_READER_TYPE_ELEMENT = 1,
+    XML_READER_TYPE_ATTRIBUTE = 2,
+    XML_READER_TYPE_TEXT = 3,
+    XML_READER_TYPE_CDATA = 4,
+    XML_READER_TYPE_ENTITY_REFERENCE = 5,
+    XML_READER_TYPE_ENTITY = 6,
+    XML_READER_TYPE_PROCESSING_INSTRUCTION = 7,
+    XML_READER_TYPE_COMMENT = 8,
+    XML_READER_TYPE_DOCUMENT = 9,
+    XML_READER_TYPE_DOCUMENT_TYPE = 10,
+    XML_READER_TYPE_DOCUMENT_FRAGMENT = 11,
+    XML_READER_TYPE_NOTATION = 12,
+    XML_READER_TYPE_WHITESPACE = 13,
+    XML_READER_TYPE_SIGNIFICANT_WHITESPACE = 14,
+    XML_READER_TYPE_END_ELEMENT = 15,
+    XML_READER_TYPE_END_ENTITY = 16,
+    XML_READER_TYPE_XML_DECLARATION = 17
+} xmlReaderTypes;
+
+/**
+ * xmlTextReader:
+ *
+ * Structure for an xmlReader context.
+ */
+typedef struct _xmlTextReader xmlTextReader;
+
+/**
+ * xmlTextReaderPtr:
+ *
+ * Pointer to an xmlReader context.
+ */
+typedef xmlTextReader *xmlTextReaderPtr;
+
+/*
+ * Constructors & Destructor
+ */
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+			xmlNewTextReader	(xmlParserInputBufferPtr input,
+	                                         const char *URI);
+XMLPUBFUN xmlTextReaderPtr XMLCALL	
+			xmlNewTextReaderFilename(const char *URI);
+
+XMLPUBFUN void XMLCALL			
+			xmlFreeTextReader	(xmlTextReaderPtr reader);
+
+XMLPUBFUN int XMLCALL			
+            xmlTextReaderSetup(xmlTextReaderPtr reader,
+                   xmlParserInputBufferPtr input, const char *URL,
+                   const char *encoding, int options);
+
+/*
+ * Iterators
+ */
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderRead	(xmlTextReaderPtr reader);
+
+#ifdef LIBXML_WRITER_ENABLED
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderReadInnerXml	(xmlTextReaderPtr reader);
+			
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderReadOuterXml	(xmlTextReaderPtr reader);
+#endif
+
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderReadString		(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderReadAttributeValue	(xmlTextReaderPtr reader);
+
+/*
+ * Attributes of the node
+ */
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderAttributeCount(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderDepth	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderHasAttributes(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderHasValue(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderIsDefault	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderNodeType	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderQuoteChar	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+			xmlTextReaderReadState	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL
+                        xmlTextReaderIsNamespaceDecl(xmlTextReaderPtr reader);
+
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstBaseUri	(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstLocalName	(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstName	(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstPrefix	(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstXmlLang	(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstString	(xmlTextReaderPtr reader,
+		    				 const xmlChar *str);
+XMLPUBFUN const xmlChar * XMLCALL	
+		    xmlTextReaderConstValue	(xmlTextReaderPtr reader);
+
+/*
+ * use the Const version of the routine for
+ * better performance and simpler code
+ */
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderBaseUri	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderLocalName	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderName	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderPrefix	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderXmlLang	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+			xmlTextReaderValue	(xmlTextReaderPtr reader);
+
+/*
+ * Methods of the XmlTextReader
+ */
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderClose		(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+		    xmlTextReaderGetAttributeNo	(xmlTextReaderPtr reader,
+						 int no);
+XMLPUBFUN xmlChar * XMLCALL	
+		    xmlTextReaderGetAttribute	(xmlTextReaderPtr reader,
+						 const xmlChar *name);
+XMLPUBFUN xmlChar * XMLCALL	
+		    xmlTextReaderGetAttributeNs	(xmlTextReaderPtr reader,
+						 const xmlChar *localName,
+						 const xmlChar *namespaceURI);
+XMLPUBFUN xmlParserInputBufferPtr XMLCALL 
+		    xmlTextReaderGetRemainder	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlChar * XMLCALL	
+		    xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,
+						 const xmlChar *prefix);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,
+						 int no);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,
+						 const xmlChar *name);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,
+						 const xmlChar *localName,
+						 const xmlChar *namespaceURI);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderMoveToElement	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderNormalization	(xmlTextReaderPtr reader);
+XMLPUBFUN const xmlChar * XMLCALL
+		    xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);
+
+/*
+ * Extensions
+ */
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderSetParserProp	(xmlTextReaderPtr reader,
+						 int prop,
+						 int value);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderGetParserProp	(xmlTextReaderPtr reader,
+						 int prop);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		    xmlTextReaderCurrentNode	(xmlTextReaderPtr reader);
+
+XMLPUBFUN int XMLCALL
+            xmlTextReaderGetParserLineNumber(xmlTextReaderPtr reader);
+
+XMLPUBFUN int XMLCALL
+            xmlTextReaderGetParserColumnNumber(xmlTextReaderPtr reader);
+
+XMLPUBFUN xmlNodePtr XMLCALL	
+		    xmlTextReaderPreserve	(xmlTextReaderPtr reader);
+#ifdef LIBXML_PATTERN_ENABLED
+XMLPUBFUN int XMLCALL	
+		    xmlTextReaderPreservePattern(xmlTextReaderPtr reader,
+		    				 const xmlChar *pattern,
+						 const xmlChar **namespaces);
+#endif /* LIBXML_PATTERN_ENABLED */
+XMLPUBFUN xmlDocPtr XMLCALL	
+		    xmlTextReaderCurrentDoc	(xmlTextReaderPtr reader);
+XMLPUBFUN xmlNodePtr XMLCALL	
+		    xmlTextReaderExpand		(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderNext		(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL
+		    xmlTextReaderNextSibling	(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderIsValid	(xmlTextReaderPtr reader);
+#ifdef LIBXML_SCHEMAS_ENABLED
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,
+						 const char *rng);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,
+						 xmlRelaxNGPtr schema);
+XMLPUBFUN int XMLCALL
+		    xmlTextReaderSchemaValidate	(xmlTextReaderPtr reader,
+		    				 const char *xsd);
+XMLPUBFUN int XMLCALL
+		    xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,
+						 xmlSchemaValidCtxtPtr ctxt,
+						 int options);
+XMLPUBFUN int XMLCALL		
+		    xmlTextReaderSetSchema	(xmlTextReaderPtr reader,
+		    				 xmlSchemaPtr schema);
+#endif
+XMLPUBFUN const xmlChar * XMLCALL
+		    xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);
+XMLPUBFUN int XMLCALL
+		    xmlTextReaderStandalone     (xmlTextReaderPtr reader);
+
+
+/*
+ * Index lookup
+ */
+XMLPUBFUN long XMLCALL
+		xmlTextReaderByteConsumed	(xmlTextReaderPtr reader);
+
+/*
+ * New more complete APIs for simpler creation and reuse of readers
+ */
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+		xmlReaderWalker		(xmlDocPtr doc);
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+		xmlReaderForDoc		(const xmlChar * cur,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+		xmlReaderForFile	(const char *filename,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+		xmlReaderForMemory	(const char *buffer,
+					 int size,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+		xmlReaderForFd		(int fd,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlTextReaderPtr XMLCALL
+		xmlReaderForIO		(xmlInputReadCallback ioread,
+					 xmlInputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+
+XMLPUBFUN int XMLCALL
+		xmlReaderNewWalker	(xmlTextReaderPtr reader,
+					 xmlDocPtr doc);
+XMLPUBFUN int XMLCALL
+		xmlReaderNewDoc		(xmlTextReaderPtr reader,
+					 const xmlChar * cur,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN int XMLCALL
+		xmlReaderNewFile	(xmlTextReaderPtr reader,
+					 const char *filename,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN int XMLCALL
+		xmlReaderNewMemory	(xmlTextReaderPtr reader,
+					 const char *buffer,
+					 int size,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN int XMLCALL
+		xmlReaderNewFd		(xmlTextReaderPtr reader,
+					 int fd,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN int XMLCALL
+		xmlReaderNewIO		(xmlTextReaderPtr reader,
+					 xmlInputReadCallback ioread,
+					 xmlInputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *URL,
+					 const char *encoding,
+					 int options);
+/*
+ * Error handling extensions
+ */
+typedef void *  xmlTextReaderLocatorPtr;
+typedef void   (XMLCALL *xmlTextReaderErrorFunc)        (void *arg, 
+						 const char *msg,
+						 xmlParserSeverities severity,
+						 xmlTextReaderLocatorPtr locator);
+XMLPUBFUN int XMLCALL             
+		    xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);
+/*int             xmlTextReaderLocatorLinePosition(xmlTextReaderLocatorPtr locator);*/
+XMLPUBFUN xmlChar * XMLCALL       
+		    xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);
+XMLPUBFUN void XMLCALL            
+		    xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader, 
+						 xmlTextReaderErrorFunc f, 
+						 void *arg);
+XMLPUBFUN void XMLCALL
+		    xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,
+							   xmlStructuredErrorFunc f,
+							   void *arg);
+XMLPUBFUN void XMLCALL            
+		    xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader, 
+						 xmlTextReaderErrorFunc *f, 
+						 void **arg);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_READER_ENABLED */
+
+#endif /* __XML_XMLREADER_H__ */
+
diff -Naur orig.ns-2.33/libxml/xmlregexp.h ns-2.33/libxml/xmlregexp.h
--- orig.ns-2.33/libxml/xmlregexp.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlregexp.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,216 @@
+/*
+ * Summary: regular expressions handling
+ * Description: basic API for libxml regular expressions handling used
+ *              for XML Schemas and validation.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_REGEXP_H__
+#define __XML_REGEXP_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_REGEXP_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlRegexpPtr:
+ *
+ * A libxml regular expression, they can actually be far more complex
+ * thank the POSIX regex expressions.
+ */
+typedef struct _xmlRegexp xmlRegexp;
+typedef xmlRegexp *xmlRegexpPtr;
+
+/**
+ * xmlRegExecCtxtPtr:
+ *
+ * A libxml progressive regular expression evaluation context
+ */
+typedef struct _xmlRegExecCtxt xmlRegExecCtxt;
+typedef xmlRegExecCtxt *xmlRegExecCtxtPtr;
+
+#ifdef __cplusplus
+}
+#endif 
+#include <libxml/tree.h>
+#include <libxml/dict.h>
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The POSIX like API
+ */
+XMLPUBFUN xmlRegexpPtr XMLCALL
+		    xmlRegexpCompile	(const xmlChar *regexp);
+XMLPUBFUN void XMLCALL			 xmlRegFreeRegexp(xmlRegexpPtr regexp);
+XMLPUBFUN int XMLCALL			
+		    xmlRegexpExec	(xmlRegexpPtr comp,
+					 const xmlChar *value);
+XMLPUBFUN void XMLCALL			
+    		    xmlRegexpPrint	(FILE *output,
+					 xmlRegexpPtr regexp);
+XMLPUBFUN int XMLCALL			
+		    xmlRegexpIsDeterminist(xmlRegexpPtr comp);
+
+/*
+ * Callback function when doing a transition in the automata
+ */
+typedef void (*xmlRegExecCallbacks) (xmlRegExecCtxtPtr exec,
+	                             const xmlChar *token,
+				     void *transdata,
+				     void *inputdata);
+
+/*
+ * The progressive API
+ */
+XMLPUBFUN xmlRegExecCtxtPtr XMLCALL	
+    		    xmlRegNewExecCtxt	(xmlRegexpPtr comp,
+					 xmlRegExecCallbacks callback,
+					 void *data);
+XMLPUBFUN void XMLCALL			
+		    xmlRegFreeExecCtxt	(xmlRegExecCtxtPtr exec);
+XMLPUBFUN int XMLCALL			
+    		    xmlRegExecPushString(xmlRegExecCtxtPtr exec,
+					 const xmlChar *value,
+					 void *data);
+XMLPUBFUN int XMLCALL			
+		    xmlRegExecPushString2(xmlRegExecCtxtPtr exec,
+					 const xmlChar *value,
+					 const xmlChar *value2,
+					 void *data);
+
+XMLPUBFUN int XMLCALL
+		    xmlRegExecNextValues(xmlRegExecCtxtPtr exec,
+		    			 int *nbval,
+		    			 int *nbneg,
+					 xmlChar **values,
+					 int *terminal);
+XMLPUBFUN int XMLCALL
+		    xmlRegExecErrInfo	(xmlRegExecCtxtPtr exec,
+		    			 const xmlChar **string,
+					 int *nbval,
+		    			 int *nbneg,
+					 xmlChar **values,
+					 int *terminal);
+#ifdef LIBXML_EXPR_ENABLED
+/*
+ * Formal regular expression handling
+ * Its goal is to do some formal work on content models
+ */
+
+/* expressions are used within a context */
+typedef struct _xmlExpCtxt xmlExpCtxt;
+typedef xmlExpCtxt *xmlExpCtxtPtr;
+
+XMLPUBFUN void XMLCALL
+			xmlExpFreeCtxt	(xmlExpCtxtPtr ctxt);
+XMLPUBFUN xmlExpCtxtPtr XMLCALL
+			xmlExpNewCtxt	(int maxNodes,
+					 xmlDictPtr dict);
+
+XMLPUBFUN int XMLCALL
+			xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+			xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);
+
+/* Expressions are trees but the tree is opaque */
+typedef struct _xmlExpNode xmlExpNode;
+typedef xmlExpNode *xmlExpNodePtr;
+
+typedef enum {
+    XML_EXP_EMPTY = 0,
+    XML_EXP_FORBID = 1,
+    XML_EXP_ATOM = 2,
+    XML_EXP_SEQ = 3,
+    XML_EXP_OR = 4,
+    XML_EXP_COUNT = 5
+} xmlExpNodeType;
+
+/*
+ * 2 core expressions shared by all for the empty language set 
+ * and for the set with just the empty token
+ */
+XMLPUBVAR xmlExpNodePtr forbiddenExp;
+XMLPUBVAR xmlExpNodePtr emptyExp;
+
+/*
+ * Expressions are reference counted internally
+ */
+XMLPUBFUN void XMLCALL
+			xmlExpFree	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr);
+XMLPUBFUN void XMLCALL
+			xmlExpRef	(xmlExpNodePtr expr);
+
+/*
+ * constructors can be either manual or from a string
+ */
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpParse	(xmlExpCtxtPtr ctxt,
+					 const char *expr);
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpNewAtom	(xmlExpCtxtPtr ctxt,
+					 const xmlChar *name,
+					 int len);
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpNewOr	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr left,
+					 xmlExpNodePtr right);
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpNewSeq	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr left,
+					 xmlExpNodePtr right);
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpNewRange	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr subset,
+					 int min,
+					 int max);
+/*
+ * The really interesting APIs
+ */
+XMLPUBFUN int XMLCALL
+			xmlExpIsNillable(xmlExpNodePtr expr);
+XMLPUBFUN int XMLCALL
+			xmlExpMaxToken	(xmlExpNodePtr expr);
+XMLPUBFUN int XMLCALL
+			xmlExpGetLanguage(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 const xmlChar**langList,
+					 int len);
+XMLPUBFUN int XMLCALL
+			xmlExpGetStart	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 const xmlChar**tokList,
+					 int len);
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpStringDerive(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 const xmlChar *str,
+					 int len);
+XMLPUBFUN xmlExpNodePtr XMLCALL
+			xmlExpExpDerive	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 xmlExpNodePtr sub);
+XMLPUBFUN int XMLCALL
+			xmlExpSubsume	(xmlExpCtxtPtr ctxt,
+					 xmlExpNodePtr expr,
+					 xmlExpNodePtr sub);
+XMLPUBFUN void XMLCALL
+			xmlExpDump	(xmlBufferPtr buf,
+					 xmlExpNodePtr expr);
+#endif /* LIBXML_EXPR_ENABLED */
+#ifdef __cplusplus
+}
+#endif 
+
+#endif /* LIBXML_REGEXP_ENABLED */
+
+#endif /*__XML_REGEXP_H__ */
diff -Naur orig.ns-2.33/libxml/xmlsave.h ns-2.33/libxml/xmlsave.h
--- orig.ns-2.33/libxml/xmlsave.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlsave.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,84 @@
+/*
+ * Summary: the XML document serializer
+ * Description: API to save document or subtree of document
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XMLSAVE_H__
+#define __XML_XMLSAVE_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/tree.h>
+#include <libxml/encoding.h>
+#include <libxml/xmlIO.h>
+
+#ifdef LIBXML_OUTPUT_ENABLED
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlSaveOption:
+ *
+ * This is the set of XML save options that can be passed down
+ * to the xmlSaveToFd() and similar calls.
+ */
+typedef enum {
+    XML_SAVE_FORMAT     = 1<<0,	/* format save output */
+    XML_SAVE_NO_DECL    = 1<<1,	/* drop the xml declaration */
+    XML_SAVE_NO_EMPTY	= 1<<2, /* no empty tags */
+    XML_SAVE_NO_XHTML	= 1<<3  /* disable XHTML1 specific rules */
+} xmlSaveOption;
+
+
+typedef struct _xmlSaveCtxt xmlSaveCtxt;
+typedef xmlSaveCtxt *xmlSaveCtxtPtr;
+
+XMLPUBFUN xmlSaveCtxtPtr XMLCALL
+		xmlSaveToFd		(int fd,
+					 const char *encoding,
+					 int options);
+XMLPUBFUN xmlSaveCtxtPtr XMLCALL
+		xmlSaveToFilename	(const char *filename,
+					 const char *encoding,
+					 int options);
+
+XMLPUBFUN xmlSaveCtxtPtr XMLCALL
+		xmlSaveToBuffer		(xmlBufferPtr buffer,
+					 const char *encoding,
+					 int options);
+
+XMLPUBFUN xmlSaveCtxtPtr XMLCALL
+		xmlSaveToIO		(xmlOutputWriteCallback iowrite,
+					 xmlOutputCloseCallback ioclose,
+					 void *ioctx,
+					 const char *encoding,
+					 int options);
+
+XMLPUBFUN long XMLCALL
+		xmlSaveDoc		(xmlSaveCtxtPtr ctxt,
+					 xmlDocPtr doc);
+XMLPUBFUN long XMLCALL
+		xmlSaveTree		(xmlSaveCtxtPtr ctxt,
+					 xmlNodePtr node);
+
+XMLPUBFUN int XMLCALL
+		xmlSaveFlush		(xmlSaveCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+		xmlSaveClose		(xmlSaveCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL
+		xmlSaveSetEscape	(xmlSaveCtxtPtr ctxt,
+					 xmlCharEncodingOutputFunc escape);
+XMLPUBFUN int XMLCALL
+		xmlSaveSetAttrEscape	(xmlSaveCtxtPtr ctxt,
+					 xmlCharEncodingOutputFunc escape);
+#ifdef __cplusplus
+}
+#endif
+#endif /* LIBXML_OUTPUT_ENABLED */
+#endif /* __XML_XMLSAVE_H__ */
+
+
diff -Naur orig.ns-2.33/libxml/xmlschemas.h ns-2.33/libxml/xmlschemas.h
--- orig.ns-2.33/libxml/xmlschemas.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlschemas.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,198 @@
+/*
+ * Summary: incomplete XML Schemas structure implementation
+ * Description: interface to the XML Schemas handling and schema validity
+ *              checking, it is incomplete right now.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_SCHEMA_H__
+#define __XML_SCHEMA_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#include <libxml/tree.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * This error codes are obsolete; not used any more.
+ */
+typedef enum {
+    XML_SCHEMAS_ERR_OK		= 0,
+    XML_SCHEMAS_ERR_NOROOT	= 1,
+    XML_SCHEMAS_ERR_UNDECLAREDELEM,
+    XML_SCHEMAS_ERR_NOTTOPLEVEL,
+    XML_SCHEMAS_ERR_MISSING,
+    XML_SCHEMAS_ERR_WRONGELEM,
+    XML_SCHEMAS_ERR_NOTYPE,
+    XML_SCHEMAS_ERR_NOROLLBACK,
+    XML_SCHEMAS_ERR_ISABSTRACT,
+    XML_SCHEMAS_ERR_NOTEMPTY,
+    XML_SCHEMAS_ERR_ELEMCONT,
+    XML_SCHEMAS_ERR_HAVEDEFAULT,
+    XML_SCHEMAS_ERR_NOTNILLABLE,
+    XML_SCHEMAS_ERR_EXTRACONTENT,
+    XML_SCHEMAS_ERR_INVALIDATTR,
+    XML_SCHEMAS_ERR_INVALIDELEM,
+    XML_SCHEMAS_ERR_NOTDETERMINIST,
+    XML_SCHEMAS_ERR_CONSTRUCT,
+    XML_SCHEMAS_ERR_INTERNAL,
+    XML_SCHEMAS_ERR_NOTSIMPLE,
+    XML_SCHEMAS_ERR_ATTRUNKNOWN,
+    XML_SCHEMAS_ERR_ATTRINVALID,
+    XML_SCHEMAS_ERR_VALUE,
+    XML_SCHEMAS_ERR_FACET,
+    XML_SCHEMAS_ERR_,
+    XML_SCHEMAS_ERR_XXX
+} xmlSchemaValidError;
+
+/*
+* ATTENTION: Change xmlSchemaSetValidOptions's check
+* for invalid values, if adding to the validation 
+* options below.
+*/
+/**
+ * xmlSchemaValidOption:
+ *
+ * This is the set of XML Schema validation options.
+ */
+typedef enum {
+    XML_SCHEMA_VAL_VC_I_CREATE			= 1<<0
+	/* Default/fixed: create an attribute node
+	* or an element's text node on the instance.
+	*/
+} xmlSchemaValidOption;
+
+/*
+    XML_SCHEMA_VAL_XSI_ASSEMBLE			= 1<<1,
+	* assemble schemata using
+	* xsi:schemaLocation and
+	* xsi:noNamespaceSchemaLocation
+*/
+
+/**
+ * The schemas related types are kept internal
+ */
+typedef struct _xmlSchema xmlSchema;
+typedef xmlSchema *xmlSchemaPtr;
+
+/**
+ * A schemas validation context
+ */
+typedef void (XMLCDECL *xmlSchemaValidityErrorFunc) (void *ctx, const char *msg, ...);
+typedef void (XMLCDECL *xmlSchemaValidityWarningFunc) (void *ctx, const char *msg, ...);
+
+typedef struct _xmlSchemaParserCtxt xmlSchemaParserCtxt;
+typedef xmlSchemaParserCtxt *xmlSchemaParserCtxtPtr;
+
+typedef struct _xmlSchemaValidCtxt xmlSchemaValidCtxt;
+typedef xmlSchemaValidCtxt *xmlSchemaValidCtxtPtr;
+
+/*
+ * Interfaces for parsing.
+ */
+XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL 
+	    xmlSchemaNewParserCtxt	(const char *URL);
+XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL 
+	    xmlSchemaNewMemParserCtxt	(const char *buffer,
+					 int size);
+XMLPUBFUN xmlSchemaParserCtxtPtr XMLCALL
+	    xmlSchemaNewDocParserCtxt	(xmlDocPtr doc);
+XMLPUBFUN void XMLCALL		
+	    xmlSchemaFreeParserCtxt	(xmlSchemaParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL		
+	    xmlSchemaSetParserErrors	(xmlSchemaParserCtxtPtr ctxt,
+					 xmlSchemaValidityErrorFunc err,
+					 xmlSchemaValidityWarningFunc warn,
+					 void *ctx);
+XMLPUBFUN void XMLCALL
+	    xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,
+					 xmlStructuredErrorFunc serror,
+					 void *ctx);
+XMLPUBFUN int XMLCALL
+		xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,
+					xmlSchemaValidityErrorFunc * err,
+					xmlSchemaValidityWarningFunc * warn,
+					void **ctx);
+XMLPUBFUN int XMLCALL
+		xmlSchemaIsValid	(xmlSchemaValidCtxtPtr ctxt);
+
+XMLPUBFUN xmlSchemaPtr XMLCALL	
+	    xmlSchemaParse		(xmlSchemaParserCtxtPtr ctxt);
+XMLPUBFUN void XMLCALL		
+	    xmlSchemaFree		(xmlSchemaPtr schema);
+#ifdef LIBXML_OUTPUT_ENABLED
+XMLPUBFUN void XMLCALL		
+	    xmlSchemaDump		(FILE *output,
+					 xmlSchemaPtr schema);
+#endif /* LIBXML_OUTPUT_ENABLED */
+/*
+ * Interfaces for validating
+ */
+XMLPUBFUN void XMLCALL		
+	    xmlSchemaSetValidErrors	(xmlSchemaValidCtxtPtr ctxt,
+					 xmlSchemaValidityErrorFunc err,
+					 xmlSchemaValidityWarningFunc warn,
+					 void *ctx);
+XMLPUBFUN void XMLCALL
+	    xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,
+					 xmlStructuredErrorFunc serror,
+					 void *ctx);
+XMLPUBFUN int XMLCALL
+	    xmlSchemaGetValidErrors	(xmlSchemaValidCtxtPtr ctxt,
+					 xmlSchemaValidityErrorFunc *err,
+					 xmlSchemaValidityWarningFunc *warn,
+					 void **ctx);
+XMLPUBFUN int XMLCALL
+	    xmlSchemaSetValidOptions	(xmlSchemaValidCtxtPtr ctxt,
+					 int options);
+XMLPUBFUN int XMLCALL
+	    xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);
+
+XMLPUBFUN xmlSchemaValidCtxtPtr XMLCALL	
+	    xmlSchemaNewValidCtxt	(xmlSchemaPtr schema);
+XMLPUBFUN void XMLCALL			
+	    xmlSchemaFreeValidCtxt	(xmlSchemaValidCtxtPtr ctxt);
+XMLPUBFUN int XMLCALL			
+	    xmlSchemaValidateDoc	(xmlSchemaValidCtxtPtr ctxt,
+					 xmlDocPtr instance);
+XMLPUBFUN int XMLCALL
+            xmlSchemaValidateOneElement (xmlSchemaValidCtxtPtr ctxt,
+			                 xmlNodePtr elem);
+XMLPUBFUN int XMLCALL
+	    xmlSchemaValidateStream	(xmlSchemaValidCtxtPtr ctxt,
+					 xmlParserInputBufferPtr input,
+					 xmlCharEncoding enc,
+					 xmlSAXHandlerPtr sax,
+					 void *user_data);
+XMLPUBFUN int XMLCALL
+	    xmlSchemaValidateFile	(xmlSchemaValidCtxtPtr ctxt,
+					 const char * filename,
+					 int options);
+
+/*
+ * Interface to insert Schemas SAX velidation in a SAX stream
+ */
+typedef struct _xmlSchemaSAXPlug xmlSchemaSAXPlugStruct;
+typedef xmlSchemaSAXPlugStruct *xmlSchemaSAXPlugPtr;
+
+XMLPUBFUN xmlSchemaSAXPlugPtr XMLCALL
+            xmlSchemaSAXPlug		(xmlSchemaValidCtxtPtr ctxt,
+					 xmlSAXHandlerPtr *sax,
+					 void **user_data);
+XMLPUBFUN int XMLCALL
+            xmlSchemaSAXUnplug		(xmlSchemaSAXPlugPtr plug);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_SCHEMAS_ENABLED */
+#endif /* __XML_SCHEMA_H__ */
diff -Naur orig.ns-2.33/libxml/xmlschemastypes.h ns-2.33/libxml/xmlschemastypes.h
--- orig.ns-2.33/libxml/xmlschemastypes.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlschemastypes.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,151 @@
+/*
+ * Summary: implementation of XML Schema Datatypes
+ * Description: module providing the XML Schema Datatypes implementation
+ *              both definition and validity checking
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+
+#ifndef __XML_SCHEMA_TYPES_H__
+#define __XML_SCHEMA_TYPES_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_SCHEMAS_ENABLED
+
+#include <libxml/schemasInternals.h>
+#include <libxml/xmlschemas.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef enum {
+    XML_SCHEMA_WHITESPACE_UNKNOWN = 0,
+    XML_SCHEMA_WHITESPACE_PRESERVE = 1,
+    XML_SCHEMA_WHITESPACE_REPLACE = 2,
+    XML_SCHEMA_WHITESPACE_COLLAPSE = 3
+} xmlSchemaWhitespaceValueType;
+
+XMLPUBFUN void XMLCALL		
+    		xmlSchemaInitTypes		(void);
+XMLPUBFUN void XMLCALL		
+		xmlSchemaCleanupTypes		(void);
+XMLPUBFUN xmlSchemaTypePtr XMLCALL 
+		xmlSchemaGetPredefinedType	(const xmlChar *name,
+						 const xmlChar *ns);
+XMLPUBFUN int XMLCALL		
+		xmlSchemaValidatePredefinedType	(xmlSchemaTypePtr type,
+						 const xmlChar *value,
+						 xmlSchemaValPtr *val);
+XMLPUBFUN int XMLCALL		
+		xmlSchemaValPredefTypeNode	(xmlSchemaTypePtr type,
+						 const xmlChar *value,
+						 xmlSchemaValPtr *val,
+						 xmlNodePtr node);
+XMLPUBFUN int XMLCALL		
+		xmlSchemaValidateFacet		(xmlSchemaTypePtr base,
+						 xmlSchemaFacetPtr facet,
+						 const xmlChar *value,
+						 xmlSchemaValPtr val);
+XMLPUBFUN int XMLCALL
+		xmlSchemaValidateFacetWhtsp	(xmlSchemaFacetPtr facet,
+						 xmlSchemaWhitespaceValueType fws,
+						 xmlSchemaValType valType,						 
+						 const xmlChar *value,
+						 xmlSchemaValPtr val,
+						 xmlSchemaWhitespaceValueType ws);
+XMLPUBFUN void XMLCALL		
+		xmlSchemaFreeValue		(xmlSchemaValPtr val);
+XMLPUBFUN xmlSchemaFacetPtr XMLCALL 
+		xmlSchemaNewFacet		(void);
+XMLPUBFUN int XMLCALL		
+		xmlSchemaCheckFacet		(xmlSchemaFacetPtr facet,
+						 xmlSchemaTypePtr typeDecl,
+						 xmlSchemaParserCtxtPtr ctxt,
+						 const xmlChar *name);
+XMLPUBFUN void XMLCALL		
+		xmlSchemaFreeFacet		(xmlSchemaFacetPtr facet);
+XMLPUBFUN int XMLCALL		
+		xmlSchemaCompareValues		(xmlSchemaValPtr x,
+						 xmlSchemaValPtr y);
+XMLPUBFUN xmlSchemaTypePtr XMLCALL		
+    xmlSchemaGetBuiltInListSimpleTypeItemType	(xmlSchemaTypePtr type);
+XMLPUBFUN int XMLCALL
+    xmlSchemaValidateListSimpleTypeFacet	(xmlSchemaFacetPtr facet,
+						 const xmlChar *value,
+						 unsigned long actualLen,
+						 unsigned long *expectedLen);
+XMLPUBFUN xmlSchemaTypePtr XMLCALL
+		xmlSchemaGetBuiltInType		(xmlSchemaValType type);
+XMLPUBFUN int XMLCALL
+		xmlSchemaIsBuiltInTypeFacet	(xmlSchemaTypePtr type, 
+						 int facetType);
+XMLPUBFUN xmlChar * XMLCALL
+		xmlSchemaCollapseString		(const xmlChar *value);
+XMLPUBFUN xmlChar * XMLCALL
+		xmlSchemaWhiteSpaceReplace	(const xmlChar *value);
+XMLPUBFUN unsigned long  XMLCALL
+		xmlSchemaGetFacetValueAsULong	(xmlSchemaFacetPtr facet);
+XMLPUBFUN int XMLCALL
+		xmlSchemaValidateLengthFacet	(xmlSchemaTypePtr type, 
+						 xmlSchemaFacetPtr facet,
+						 const xmlChar *value,
+						 xmlSchemaValPtr val,
+						 unsigned long *length);
+XMLPUBFUN int XMLCALL
+		xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,
+						  xmlSchemaValType valType,
+						  const xmlChar *value,
+						  xmlSchemaValPtr val,						  
+						  unsigned long *length,
+						  xmlSchemaWhitespaceValueType ws);
+XMLPUBFUN int XMLCALL
+		xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type, 
+						 const xmlChar *value,
+						 xmlSchemaValPtr *val, 
+						 xmlNodePtr node);
+XMLPUBFUN int XMLCALL
+		xmlSchemaGetCanonValue		(xmlSchemaValPtr val,
+						 const xmlChar **retValue);
+XMLPUBFUN int XMLCALL
+		xmlSchemaGetCanonValueWhtsp	(xmlSchemaValPtr val,						 
+						 const xmlChar **retValue,
+						 xmlSchemaWhitespaceValueType ws);
+XMLPUBFUN int XMLCALL
+		xmlSchemaValueAppend		(xmlSchemaValPtr prev,
+						 xmlSchemaValPtr cur);
+XMLPUBFUN xmlSchemaValPtr XMLCALL
+		xmlSchemaValueGetNext		(xmlSchemaValPtr cur);
+XMLPUBFUN const xmlChar * XMLCALL
+		xmlSchemaValueGetAsString	(xmlSchemaValPtr val);
+XMLPUBFUN int XMLCALL
+		xmlSchemaValueGetAsBoolean	(xmlSchemaValPtr val);
+XMLPUBFUN xmlSchemaValPtr XMLCALL
+		xmlSchemaNewStringValue		(xmlSchemaValType type,
+						 const xmlChar *value);
+XMLPUBFUN xmlSchemaValPtr XMLCALL
+		xmlSchemaNewNOTATIONValue	(const xmlChar *name,
+						 const xmlChar *ns);
+XMLPUBFUN xmlSchemaValPtr XMLCALL
+		xmlSchemaNewQNameValue		(const xmlChar *namespaceName,
+						 const xmlChar *localName);
+XMLPUBFUN int XMLCALL
+		xmlSchemaCompareValuesWhtsp	(xmlSchemaValPtr x,
+						 xmlSchemaWhitespaceValueType xws,
+						 xmlSchemaValPtr y,
+						 xmlSchemaWhitespaceValueType yws);
+XMLPUBFUN xmlSchemaValPtr XMLCALL
+		xmlSchemaCopyValue		(xmlSchemaValPtr val);
+XMLPUBFUN xmlSchemaValType XMLCALL
+		xmlSchemaGetValType		(xmlSchemaValPtr val);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_SCHEMAS_ENABLED */
+#endif /* __XML_SCHEMA_TYPES_H__ */
diff -Naur orig.ns-2.33/libxml/xmlstring.h ns-2.33/libxml/xmlstring.h
--- orig.ns-2.33/libxml/xmlstring.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlstring.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,140 @@
+/*
+ * Summary: set of routines to process strings
+ * Description: type and interfaces needed for the internal string handling
+ *              of the library, especially UTF8 processing.
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_STRING_H__
+#define __XML_STRING_H__
+
+#include <stdarg.h>
+#include <libxml/xmlversion.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * xmlChar:
+ *
+ * This is a basic byte in an UTF-8 encoded string.
+ * It's unsigned allowing to pinpoint case where char * are assigned
+ * to xmlChar * (possibly making serialization back impossible).
+ */
+typedef unsigned char xmlChar;
+
+/**
+ * BAD_CAST:
+ *
+ * Macro to cast a string to an xmlChar * when one know its safe.
+ */
+#define BAD_CAST (xmlChar *)
+
+/*
+ * xmlChar handling
+ */
+XMLPUBFUN xmlChar * XMLCALL
+                xmlStrdup                (const xmlChar *cur);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlStrndup               (const xmlChar *cur,
+                                         int len);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlCharStrndup           (const char *cur,
+                                         int len);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlCharStrdup            (const char *cur);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlStrsub                (const xmlChar *str,
+                                         int start,
+                                         int len);
+XMLPUBFUN const xmlChar * XMLCALL
+                xmlStrchr                (const xmlChar *str,
+                                         xmlChar val);
+XMLPUBFUN const xmlChar * XMLCALL
+                xmlStrstr                (const xmlChar *str,
+                                         const xmlChar *val);
+XMLPUBFUN const xmlChar * XMLCALL
+                xmlStrcasestr            (const xmlChar *str,
+                                         xmlChar *val);
+XMLPUBFUN int XMLCALL
+                xmlStrcmp                (const xmlChar *str1,
+                                         const xmlChar *str2);
+XMLPUBFUN int XMLCALL
+                xmlStrncmp               (const xmlChar *str1,
+                                         const xmlChar *str2,
+                                         int len);
+XMLPUBFUN int XMLCALL
+                xmlStrcasecmp            (const xmlChar *str1,
+                                         const xmlChar *str2);
+XMLPUBFUN int XMLCALL
+                xmlStrncasecmp           (const xmlChar *str1,
+                                         const xmlChar *str2,
+                                         int len);
+XMLPUBFUN int XMLCALL
+                xmlStrEqual              (const xmlChar *str1,
+                                         const xmlChar *str2);
+XMLPUBFUN int XMLCALL
+                xmlStrQEqual             (const xmlChar *pref,
+                                         const xmlChar *name,
+                                         const xmlChar *str);
+XMLPUBFUN int XMLCALL
+                xmlStrlen                (const xmlChar *str);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlStrcat                (xmlChar *cur,
+                                         const xmlChar *add);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlStrncat               (xmlChar *cur,
+                                         const xmlChar *add,
+                                         int len);
+XMLPUBFUN xmlChar * XMLCALL
+                xmlStrncatNew            (const xmlChar *str1,
+                                         const xmlChar *str2,
+                                         int len);
+XMLPUBFUN int XMLCALL
+                xmlStrPrintf             (xmlChar *buf,
+                                         int len,
+                                         const xmlChar *msg,
+                                         ...);
+XMLPUBFUN int XMLCALL
+                xmlStrVPrintf                (xmlChar *buf,
+                                         int len,
+                                         const xmlChar *msg,
+                                         va_list ap);
+
+XMLPUBFUN int XMLCALL
+        xmlGetUTF8Char                   (const unsigned char *utf,
+                                         int *len);
+XMLPUBFUN int XMLCALL
+        xmlCheckUTF8                     (const unsigned char *utf);
+XMLPUBFUN int XMLCALL
+        xmlUTF8Strsize                   (const xmlChar *utf,
+                                         int len);
+XMLPUBFUN xmlChar * XMLCALL 
+        xmlUTF8Strndup                   (const xmlChar *utf,
+                                         int len);
+XMLPUBFUN const xmlChar * XMLCALL 
+        xmlUTF8Strpos                    (const xmlChar *utf,
+                                         int pos);
+XMLPUBFUN int XMLCALL
+        xmlUTF8Strloc                    (const xmlChar *utf,
+                                         const xmlChar *utfchar);
+XMLPUBFUN xmlChar * XMLCALL 
+        xmlUTF8Strsub                    (const xmlChar *utf,
+                                         int start,
+                                         int len);
+XMLPUBFUN int XMLCALL
+        xmlUTF8Strlen                    (const xmlChar *utf);
+XMLPUBFUN int XMLCALL
+        xmlUTF8Size                      (const xmlChar *utf);
+XMLPUBFUN int XMLCALL
+        xmlUTF8Charcmp                   (const xmlChar *utf1,
+                                         const xmlChar *utf2);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __XML_STRING_H__ */
diff -Naur orig.ns-2.33/libxml/xmlunicode.h ns-2.33/libxml/xmlunicode.h
--- orig.ns-2.33/libxml/xmlunicode.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlunicode.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,202 @@
+/*
+ * Summary: Unicode character APIs
+ * Description: API for the Unicode character APIs
+ *
+ * This file is automatically generated from the
+ * UCS description files of the Unicode Character Database
+ * http://www.unicode.org/Public/4.0-Update1/UCD-4.0.1.html
+ * using the genUnicode.py Python script.
+ *
+ * Generation date: Mon Mar 27 11:09:52 2006
+ * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_UNICODE_H__
+#define __XML_UNICODE_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_UNICODE_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsArabic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsA	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsArabicPresentationFormsB	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsArmenian	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsArrows	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBengali	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBlockElements	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBopomofo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBopomofoExtended	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBraillePatterns	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsBuhid	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsByzantineMusicalSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibility	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKSymbolsandPunctuation	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionA	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographsExtensionB	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCherokee	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarks	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCombiningMarksforSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsControlPictures	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCurrencySymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCypriotSyllabary	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCyrillic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsDeseret	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsDevanagari	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsDingbats	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsEthiopic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGeometricShapes	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGeorgian	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGothic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGreek	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGreekandCoptic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGujarati	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsGurmukhi	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHangulCompatibilityJamo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHangulSyllables	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHanunoo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHebrew	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHighPrivateUseSurrogates	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHighSurrogates	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsHiragana	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsIdeographicDescriptionCharacters	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKanbun	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKangxiRadicals	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKannada	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKatakana	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKhmer	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLao	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLatin1Supplement	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedA	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedB	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLatinExtendedAdditional	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLetterlikeSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLimbu	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLinearBIdeograms	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLinearBSyllabary	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMalayalam	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMathematicalAlphanumericSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsA	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousMathematicalSymbolsB	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousTechnical	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMongolian	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMusicalSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsMyanmar	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsNumberForms	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsOgham	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsOldItalic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsOriya	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsOsmanya	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsPrivateUseArea	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsRunic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsShavian	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSinhala	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSmallFormVariants	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSpacingModifierLetters	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSpecials	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSuperscriptsandSubscripts	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSupplementalMathematicalOperators	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsSyriac	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTagalog	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTagbanwa	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTags	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTaiLe	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTamil	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTelugu	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsThaana	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsThai	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsTibetan	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsUgaritic	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols	(int code);
+
+XMLPUBFUN int XMLCALL xmlUCSIsBlock	(int code, const char *block);
+
+XMLPUBFUN int XMLCALL xmlUCSIsCatC	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatCc	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatCf	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatCo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatCs	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatL	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatLl	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatLm	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatLo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatLt	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatLu	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatM	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatMc	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatMe	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatMn	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatN	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatNd	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatNl	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatNo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatP	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPc	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPd	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPe	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPf	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPi	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatPs	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatS	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatSc	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatSk	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatSm	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatSo	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatZ	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatZl	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatZp	(int code);
+XMLPUBFUN int XMLCALL xmlUCSIsCatZs	(int code);
+
+XMLPUBFUN int XMLCALL xmlUCSIsCat	(int code, const char *cat);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_UNICODE_ENABLED */
+
+#endif /* __XML_UNICODE_H__ */
diff -Naur orig.ns-2.33/libxml/xmlversion.h ns-2.33/libxml/xmlversion.h
--- orig.ns-2.33/libxml/xmlversion.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlversion.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,406 @@
+/*
+ * Summary: compile-time version informations
+ * Description: compile-time version informations for the XML library
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_VERSION_H__
+#define __XML_VERSION_H__
+
+#include <libxml/xmlexports.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * use those to be sure nothing nasty will happen if
+ * your library and includes mismatch
+ */
+#ifndef LIBXML2_COMPILING_MSCCDEF
+XMLPUBFUN void XMLCALL xmlCheckVersion(int version);
+#endif /* LIBXML2_COMPILING_MSCCDEF */
+
+/**
+ * LIBXML_DOTTED_VERSION:
+ *
+ * the version string like "1.2.3"
+ */
+#define LIBXML_DOTTED_VERSION "2.6.30"
+
+/**
+ * LIBXML_VERSION:
+ *
+ * the version number: 1.2.3 value is 10203
+ */
+#define LIBXML_VERSION 20630
+
+/**
+ * LIBXML_VERSION_STRING:
+ *
+ * the version number string, 1.2.3 value is "10203"
+ */
+#define LIBXML_VERSION_STRING "20630"
+
+/**
+ * LIBXML_VERSION_EXTRA:
+ *
+ * extra version information, used to show a CVS compilation
+ */
+#define LIBXML_VERSION_EXTRA "-CVS2831"
+
+/**
+ * LIBXML_TEST_VERSION:
+ *
+ * Macro to check that the libxml version in use is compatible with
+ * the version the software has been compiled against
+ */
+#define LIBXML_TEST_VERSION xmlCheckVersion(20630);
+
+#ifndef VMS
+#if 0
+/**
+ * WITH_TRIO:
+ *
+ * defined if the trio support need to be configured in
+ */
+#define WITH_TRIO
+#else
+/**
+ * WITHOUT_TRIO:
+ *
+ * defined if the trio support should not be configured in
+ */
+#define WITHOUT_TRIO
+#endif
+#else /* VMS */
+/**
+ * WITH_TRIO:
+ *
+ * defined if the trio support need to be configured in
+ */
+#define WITH_TRIO 1
+#endif /* VMS */
+
+/**
+ * LIBXML_THREAD_ENABLED:
+ *
+ * Whether the thread support is configured in
+ */
+#if 1
+#if defined(_REENTRANT) || defined(__MT__) || \
+    (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE - 0 >= 199506L))
+#define LIBXML_THREAD_ENABLED
+#endif
+#endif
+
+/**
+ * LIBXML_TREE_ENABLED:
+ *
+ * Whether the DOM like tree manipulation API support is configured in
+ */
+#if 1
+#define LIBXML_TREE_ENABLED
+#endif
+
+/**
+ * LIBXML_OUTPUT_ENABLED:
+ *
+ * Whether the serialization/saving support is configured in
+ */
+#if 1
+#define LIBXML_OUTPUT_ENABLED
+#endif
+
+/**
+ * LIBXML_PUSH_ENABLED:
+ *
+ * Whether the push parsing interfaces are configured in
+ */
+#if 1
+#define LIBXML_PUSH_ENABLED
+#endif
+
+/**
+ * LIBXML_READER_ENABLED:
+ *
+ * Whether the xmlReader parsing interface is configured in
+ */
+#if 1
+#define LIBXML_READER_ENABLED
+#endif
+
+/**
+ * LIBXML_PATTERN_ENABLED:
+ *
+ * Whether the xmlPattern node selection interface is configured in
+ */
+#if 1
+#define LIBXML_PATTERN_ENABLED
+#endif
+
+/**
+ * LIBXML_WRITER_ENABLED:
+ *
+ * Whether the xmlWriter saving interface is configured in
+ */
+#if 1
+#define LIBXML_WRITER_ENABLED
+#endif
+
+/**
+ * LIBXML_SAX1_ENABLED:
+ *
+ * Whether the older SAX1 interface is configured in
+ */
+#if 1
+#define LIBXML_SAX1_ENABLED
+#endif
+
+/**
+ * LIBXML_FTP_ENABLED:
+ *
+ * Whether the FTP support is configured in
+ */
+#if 1
+#define LIBXML_FTP_ENABLED
+#endif
+
+/**
+ * LIBXML_HTTP_ENABLED:
+ *
+ * Whether the HTTP support is configured in
+ */
+#if 1
+#define LIBXML_HTTP_ENABLED
+#endif
+
+/**
+ * LIBXML_VALID_ENABLED:
+ *
+ * Whether the DTD validation support is configured in
+ */
+#if 1
+#define LIBXML_VALID_ENABLED
+#endif
+
+/**
+ * LIBXML_HTML_ENABLED:
+ *
+ * Whether the HTML support is configured in
+ */
+#if 1
+#define LIBXML_HTML_ENABLED
+#endif
+
+/**
+ * LIBXML_LEGACY_ENABLED:
+ *
+ * Whether the deprecated APIs are compiled in for compatibility
+ */
+#if 1
+#define LIBXML_LEGACY_ENABLED
+#endif
+
+/**
+ * LIBXML_C14N_ENABLED:
+ *
+ * Whether the Canonicalization support is configured in
+ */
+#if 1
+#define LIBXML_C14N_ENABLED
+#endif
+
+/**
+ * LIBXML_CATALOG_ENABLED:
+ *
+ * Whether the Catalog support is configured in
+ */
+#if 1
+#define LIBXML_CATALOG_ENABLED
+#endif
+
+/**
+ * LIBXML_DOCB_ENABLED:
+ *
+ * Whether the SGML Docbook support is configured in
+ */
+#if 1
+#define LIBXML_DOCB_ENABLED
+#endif
+
+/**
+ * LIBXML_XPATH_ENABLED:
+ *
+ * Whether XPath is configured in
+ */
+#if 1
+#define LIBXML_XPATH_ENABLED
+#endif
+
+/**
+ * LIBXML_XPTR_ENABLED:
+ *
+ * Whether XPointer is configured in
+ */
+#if 1
+#define LIBXML_XPTR_ENABLED
+#endif
+
+/**
+ * LIBXML_XINCLUDE_ENABLED:
+ *
+ * Whether XInclude is configured in
+ */
+#if 1
+#define LIBXML_XINCLUDE_ENABLED
+#endif
+
+/**
+ * LIBXML_ICONV_ENABLED:
+ *
+ * Whether iconv support is available
+ */
+#if 1
+#define LIBXML_ICONV_ENABLED
+#endif
+
+/**
+ * LIBXML_ISO8859X_ENABLED:
+ *
+ * Whether ISO-8859-* support is made available in case iconv is not
+ */
+#if 1
+#define LIBXML_ISO8859X_ENABLED
+#endif
+
+/**
+ * LIBXML_DEBUG_ENABLED:
+ *
+ * Whether Debugging module is configured in
+ */
+#if 1
+#define LIBXML_DEBUG_ENABLED
+#endif
+
+/**
+ * DEBUG_MEMORY_LOCATION:
+ *
+ * Whether the memory debugging is configured in
+ */
+#if 1
+#define DEBUG_MEMORY_LOCATION
+#endif
+
+/**
+ * LIBXML_DEBUG_RUNTIME:
+ *
+ * Whether the runtime debugging is configured in
+ */
+#if 1
+#define LIBXML_DEBUG_RUNTIME
+#endif
+
+/**
+ * LIBXML_UNICODE_ENABLED:
+ *
+ * Whether the Unicode related interfaces are compiled in
+ */
+#if 1
+#define LIBXML_UNICODE_ENABLED
+#endif
+
+/**
+ * LIBXML_REGEXP_ENABLED:
+ *
+ * Whether the regular expressions interfaces are compiled in
+ */
+#if 1
+#define LIBXML_REGEXP_ENABLED
+#endif
+
+/**
+ * LIBXML_AUTOMATA_ENABLED:
+ *
+ * Whether the automata interfaces are compiled in
+ */
+#if 1
+#define LIBXML_AUTOMATA_ENABLED
+#endif
+
+/**
+ * LIBXML_EXPR_ENABLED:
+ *
+ * Whether the formal expressions interfaces are compiled in
+ */
+#if 1
+#define LIBXML_EXPR_ENABLED
+#endif
+
+/**
+ * LIBXML_SCHEMAS_ENABLED:
+ *
+ * Whether the Schemas validation interfaces are compiled in
+ */
+#if 1
+#define LIBXML_SCHEMAS_ENABLED
+#endif
+
+/**
+ * LIBXML_SCHEMATRON_ENABLED:
+ *
+ * Whether the Schematron validation interfaces are compiled in
+ */
+#if 1
+#define LIBXML_SCHEMATRON_ENABLED
+#endif
+
+/**
+ * LIBXML_MODULES_ENABLED:
+ *
+ * Whether the module interfaces are compiled in
+ */
+#if 1
+#define LIBXML_MODULES_ENABLED
+/**
+ * LIBXML_MODULE_EXTENSION:
+ *
+ * the string suffix used by dynamic modules (usually shared libraries)
+ */
+#define LIBXML_MODULE_EXTENSION ".so" 
+#endif
+
+/**
+ * LIBXML_ZLIB_ENABLED:
+ *
+ * Whether the Zlib support is compiled in
+ */
+#if 1
+#define LIBXML_ZLIB_ENABLED
+#endif
+
+/**
+ * ATTRIBUTE_UNUSED:
+ *
+ * Macro used to signal to GCC unused function parameters
+ */
+#ifdef __GNUC__
+#ifdef HAVE_ANSIDECL_H
+#include <ansidecl.h>
+#endif
+#ifndef ATTRIBUTE_UNUSED
+#define ATTRIBUTE_UNUSED __attribute__((unused))
+#endif
+#else
+#define ATTRIBUTE_UNUSED
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif
+
+
diff -Naur orig.ns-2.33/libxml/xmlversion.h.in ns-2.33/libxml/xmlversion.h.in
--- orig.ns-2.33/libxml/xmlversion.h.in	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlversion.h.in	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,406 @@
+/*
+ * Summary: compile-time version informations
+ * Description: compile-time version informations for the XML library
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_VERSION_H__
+#define __XML_VERSION_H__
+
+#include <libxml/xmlexports.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * use those to be sure nothing nasty will happen if
+ * your library and includes mismatch
+ */
+#ifndef LIBXML2_COMPILING_MSCCDEF
+XMLPUBFUN void XMLCALL xmlCheckVersion(int version);
+#endif /* LIBXML2_COMPILING_MSCCDEF */
+
+/**
+ * LIBXML_DOTTED_VERSION:
+ *
+ * the version string like "1.2.3"
+ */
+#define LIBXML_DOTTED_VERSION "@VERSION@"
+
+/**
+ * LIBXML_VERSION:
+ *
+ * the version number: 1.2.3 value is 10203
+ */
+#define LIBXML_VERSION @LIBXML_VERSION_NUMBER@
+
+/**
+ * LIBXML_VERSION_STRING:
+ *
+ * the version number string, 1.2.3 value is "10203"
+ */
+#define LIBXML_VERSION_STRING "@LIBXML_VERSION_NUMBER@"
+
+/**
+ * LIBXML_VERSION_EXTRA:
+ *
+ * extra version information, used to show a CVS compilation
+ */
+#define LIBXML_VERSION_EXTRA "@LIBXML_VERSION_EXTRA@"
+
+/**
+ * LIBXML_TEST_VERSION:
+ *
+ * Macro to check that the libxml version in use is compatible with
+ * the version the software has been compiled against
+ */
+#define LIBXML_TEST_VERSION xmlCheckVersion(@LIBXML_VERSION_NUMBER@);
+
+#ifndef VMS
+#if @WITH_TRIO@
+/**
+ * WITH_TRIO:
+ *
+ * defined if the trio support need to be configured in
+ */
+#define WITH_TRIO
+#else
+/**
+ * WITHOUT_TRIO:
+ *
+ * defined if the trio support should not be configured in
+ */
+#define WITHOUT_TRIO
+#endif
+#else /* VMS */
+/**
+ * WITH_TRIO:
+ *
+ * defined if the trio support need to be configured in
+ */
+#define WITH_TRIO 1
+#endif /* VMS */
+
+/**
+ * LIBXML_THREAD_ENABLED:
+ *
+ * Whether the thread support is configured in
+ */
+#if @WITH_THREADS@
+#if defined(_REENTRANT) || defined(__MT__) || \
+    (defined(_POSIX_C_SOURCE) && (_POSIX_C_SOURCE - 0 >= 199506L))
+#define LIBXML_THREAD_ENABLED
+#endif
+#endif
+
+/**
+ * LIBXML_TREE_ENABLED:
+ *
+ * Whether the DOM like tree manipulation API support is configured in
+ */
+#if @WITH_TREE@
+#define LIBXML_TREE_ENABLED
+#endif
+
+/**
+ * LIBXML_OUTPUT_ENABLED:
+ *
+ * Whether the serialization/saving support is configured in
+ */
+#if @WITH_OUTPUT@
+#define LIBXML_OUTPUT_ENABLED
+#endif
+
+/**
+ * LIBXML_PUSH_ENABLED:
+ *
+ * Whether the push parsing interfaces are configured in
+ */
+#if @WITH_PUSH@
+#define LIBXML_PUSH_ENABLED
+#endif
+
+/**
+ * LIBXML_READER_ENABLED:
+ *
+ * Whether the xmlReader parsing interface is configured in
+ */
+#if @WITH_READER@
+#define LIBXML_READER_ENABLED
+#endif
+
+/**
+ * LIBXML_PATTERN_ENABLED:
+ *
+ * Whether the xmlPattern node selection interface is configured in
+ */
+#if @WITH_PATTERN@
+#define LIBXML_PATTERN_ENABLED
+#endif
+
+/**
+ * LIBXML_WRITER_ENABLED:
+ *
+ * Whether the xmlWriter saving interface is configured in
+ */
+#if @WITH_WRITER@
+#define LIBXML_WRITER_ENABLED
+#endif
+
+/**
+ * LIBXML_SAX1_ENABLED:
+ *
+ * Whether the older SAX1 interface is configured in
+ */
+#if @WITH_SAX1@
+#define LIBXML_SAX1_ENABLED
+#endif
+
+/**
+ * LIBXML_FTP_ENABLED:
+ *
+ * Whether the FTP support is configured in
+ */
+#if @WITH_FTP@
+#define LIBXML_FTP_ENABLED
+#endif
+
+/**
+ * LIBXML_HTTP_ENABLED:
+ *
+ * Whether the HTTP support is configured in
+ */
+#if @WITH_HTTP@
+#define LIBXML_HTTP_ENABLED
+#endif
+
+/**
+ * LIBXML_VALID_ENABLED:
+ *
+ * Whether the DTD validation support is configured in
+ */
+#if @WITH_VALID@
+#define LIBXML_VALID_ENABLED
+#endif
+
+/**
+ * LIBXML_HTML_ENABLED:
+ *
+ * Whether the HTML support is configured in
+ */
+#if @WITH_HTML@
+#define LIBXML_HTML_ENABLED
+#endif
+
+/**
+ * LIBXML_LEGACY_ENABLED:
+ *
+ * Whether the deprecated APIs are compiled in for compatibility
+ */
+#if @WITH_LEGACY@
+#define LIBXML_LEGACY_ENABLED
+#endif
+
+/**
+ * LIBXML_C14N_ENABLED:
+ *
+ * Whether the Canonicalization support is configured in
+ */
+#if @WITH_C14N@
+#define LIBXML_C14N_ENABLED
+#endif
+
+/**
+ * LIBXML_CATALOG_ENABLED:
+ *
+ * Whether the Catalog support is configured in
+ */
+#if @WITH_CATALOG@
+#define LIBXML_CATALOG_ENABLED
+#endif
+
+/**
+ * LIBXML_DOCB_ENABLED:
+ *
+ * Whether the SGML Docbook support is configured in
+ */
+#if @WITH_DOCB@
+#define LIBXML_DOCB_ENABLED
+#endif
+
+/**
+ * LIBXML_XPATH_ENABLED:
+ *
+ * Whether XPath is configured in
+ */
+#if @WITH_XPATH@
+#define LIBXML_XPATH_ENABLED
+#endif
+
+/**
+ * LIBXML_XPTR_ENABLED:
+ *
+ * Whether XPointer is configured in
+ */
+#if @WITH_XPTR@
+#define LIBXML_XPTR_ENABLED
+#endif
+
+/**
+ * LIBXML_XINCLUDE_ENABLED:
+ *
+ * Whether XInclude is configured in
+ */
+#if @WITH_XINCLUDE@
+#define LIBXML_XINCLUDE_ENABLED
+#endif
+
+/**
+ * LIBXML_ICONV_ENABLED:
+ *
+ * Whether iconv support is available
+ */
+#if @WITH_ICONV@
+#define LIBXML_ICONV_ENABLED
+#endif
+
+/**
+ * LIBXML_ISO8859X_ENABLED:
+ *
+ * Whether ISO-8859-* support is made available in case iconv is not
+ */
+#if @WITH_ISO8859X@
+#define LIBXML_ISO8859X_ENABLED
+#endif
+
+/**
+ * LIBXML_DEBUG_ENABLED:
+ *
+ * Whether Debugging module is configured in
+ */
+#if @WITH_DEBUG@
+#define LIBXML_DEBUG_ENABLED
+#endif
+
+/**
+ * DEBUG_MEMORY_LOCATION:
+ *
+ * Whether the memory debugging is configured in
+ */
+#if @WITH_MEM_DEBUG@
+#define DEBUG_MEMORY_LOCATION
+#endif
+
+/**
+ * LIBXML_DEBUG_RUNTIME:
+ *
+ * Whether the runtime debugging is configured in
+ */
+#if @WITH_RUN_DEBUG@
+#define LIBXML_DEBUG_RUNTIME
+#endif
+
+/**
+ * LIBXML_UNICODE_ENABLED:
+ *
+ * Whether the Unicode related interfaces are compiled in
+ */
+#if @WITH_REGEXPS@
+#define LIBXML_UNICODE_ENABLED
+#endif
+
+/**
+ * LIBXML_REGEXP_ENABLED:
+ *
+ * Whether the regular expressions interfaces are compiled in
+ */
+#if @WITH_REGEXPS@
+#define LIBXML_REGEXP_ENABLED
+#endif
+
+/**
+ * LIBXML_AUTOMATA_ENABLED:
+ *
+ * Whether the automata interfaces are compiled in
+ */
+#if @WITH_REGEXPS@
+#define LIBXML_AUTOMATA_ENABLED
+#endif
+
+/**
+ * LIBXML_EXPR_ENABLED:
+ *
+ * Whether the formal expressions interfaces are compiled in
+ */
+#if @WITH_SCHEMAS@
+#define LIBXML_EXPR_ENABLED
+#endif
+
+/**
+ * LIBXML_SCHEMAS_ENABLED:
+ *
+ * Whether the Schemas validation interfaces are compiled in
+ */
+#if @WITH_SCHEMAS@
+#define LIBXML_SCHEMAS_ENABLED
+#endif
+
+/**
+ * LIBXML_SCHEMATRON_ENABLED:
+ *
+ * Whether the Schematron validation interfaces are compiled in
+ */
+#if @WITH_SCHEMATRON@
+#define LIBXML_SCHEMATRON_ENABLED
+#endif
+
+/**
+ * LIBXML_MODULES_ENABLED:
+ *
+ * Whether the module interfaces are compiled in
+ */
+#if @WITH_MODULES@
+#define LIBXML_MODULES_ENABLED
+/**
+ * LIBXML_MODULE_EXTENSION:
+ *
+ * the string suffix used by dynamic modules (usually shared libraries)
+ */
+#define LIBXML_MODULE_EXTENSION "@MODULE_EXTENSION@" 
+#endif
+
+/**
+ * LIBXML_ZLIB_ENABLED:
+ *
+ * Whether the Zlib support is compiled in
+ */
+#if @WITH_ZLIB@
+#define LIBXML_ZLIB_ENABLED
+#endif
+
+/**
+ * ATTRIBUTE_UNUSED:
+ *
+ * Macro used to signal to GCC unused function parameters
+ */
+#ifdef __GNUC__
+#ifdef HAVE_ANSIDECL_H
+#include <ansidecl.h>
+#endif
+#ifndef ATTRIBUTE_UNUSED
+#define ATTRIBUTE_UNUSED __attribute__((unused))
+#endif
+#else
+#define ATTRIBUTE_UNUSED
+#endif
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif
+
+
diff -Naur orig.ns-2.33/libxml/xmlwriter.h ns-2.33/libxml/xmlwriter.h
--- orig.ns-2.33/libxml/xmlwriter.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xmlwriter.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,459 @@
+
+/*
+ * Summary: text writing API for XML
+ * Description: text writing API for XML
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Alfred Mickautsch <alfred@mickautsch.de>
+ */
+
+#ifndef __XML_XMLWRITER_H__
+#define __XML_XMLWRITER_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_WRITER_ENABLED
+
+#include <stdarg.h>
+#include <libxml/xmlIO.h>
+#include <libxml/list.h>
+#include <libxml/xmlstring.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    typedef struct _xmlTextWriter xmlTextWriter;
+    typedef xmlTextWriter *xmlTextWriterPtr;
+
+/*
+ * Constructors & Destructor
+ */
+    XMLPUBFUN xmlTextWriterPtr XMLCALL
+        xmlNewTextWriter(xmlOutputBufferPtr out);
+    XMLPUBFUN xmlTextWriterPtr XMLCALL
+        xmlNewTextWriterFilename(const char *uri, int compression);
+    XMLPUBFUN xmlTextWriterPtr XMLCALL
+        xmlNewTextWriterMemory(xmlBufferPtr buf, int compression);
+    XMLPUBFUN xmlTextWriterPtr XMLCALL
+        xmlNewTextWriterPushParser(xmlParserCtxtPtr ctxt, int compression);
+    XMLPUBFUN xmlTextWriterPtr XMLCALL
+        xmlNewTextWriterDoc(xmlDocPtr * doc, int compression);
+    XMLPUBFUN xmlTextWriterPtr XMLCALL
+        xmlNewTextWriterTree(xmlDocPtr doc, xmlNodePtr node,
+                             int compression);
+    XMLPUBFUN void XMLCALL xmlFreeTextWriter(xmlTextWriterPtr writer);
+
+/*
+ * Functions
+ */
+
+
+/*
+ * Document
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartDocument(xmlTextWriterPtr writer,
+                                   const char *version,
+                                   const char *encoding,
+                                   const char *standalone);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndDocument(xmlTextWriterPtr
+                                                   writer);
+
+/*
+ * Comments
+ */
+    XMLPUBFUN int XMLCALL xmlTextWriterStartComment(xmlTextWriterPtr
+                                                    writer);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndComment(xmlTextWriterPtr writer);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatComment(xmlTextWriterPtr writer,
+                                        const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatComment(xmlTextWriterPtr writer,
+                                         const char *format,
+                                         va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteComment(xmlTextWriterPtr
+                                                    writer,
+                                                    const xmlChar *
+                                                    content);
+
+/*
+ * Elements
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartElement(xmlTextWriterPtr writer,
+                                  const xmlChar * name);
+    XMLPUBFUN int XMLCALL xmlTextWriterStartElementNS(xmlTextWriterPtr
+                                                      writer,
+                                                      const xmlChar *
+                                                      prefix,
+                                                      const xmlChar * name,
+                                                      const xmlChar *
+                                                      namespaceURI);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndElement(xmlTextWriterPtr writer);
+    XMLPUBFUN int XMLCALL xmlTextWriterFullEndElement(xmlTextWriterPtr
+                                                      writer);
+
+/*
+ * Elements conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatElement(xmlTextWriterPtr writer,
+                                        const xmlChar * name,
+                                        const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatElement(xmlTextWriterPtr writer,
+                                         const xmlChar * name,
+                                         const char *format,
+                                         va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteElement(xmlTextWriterPtr
+                                                    writer,
+                                                    const xmlChar * name,
+                                                    const xmlChar *
+                                                    content);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatElementNS(xmlTextWriterPtr writer,
+                                          const xmlChar * prefix,
+                                          const xmlChar * name,
+                                          const xmlChar * namespaceURI,
+                                          const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatElementNS(xmlTextWriterPtr writer,
+                                           const xmlChar * prefix,
+                                           const xmlChar * name,
+                                           const xmlChar * namespaceURI,
+                                           const char *format,
+                                           va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteElementNS(xmlTextWriterPtr
+                                                      writer,
+                                                      const xmlChar *
+                                                      prefix,
+                                                      const xmlChar * name,
+                                                      const xmlChar *
+                                                      namespaceURI,
+                                                      const xmlChar *
+                                                      content);
+
+/*
+ * Text
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatRaw(xmlTextWriterPtr writer,
+                                    const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatRaw(xmlTextWriterPtr writer,
+                                     const char *format, va_list argptr);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteRawLen(xmlTextWriterPtr writer,
+                                 const xmlChar * content, int len);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteRaw(xmlTextWriterPtr writer,
+                              const xmlChar * content);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteFormatString(xmlTextWriterPtr
+                                                         writer,
+                                                         const char
+                                                         *format, ...);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteVFormatString(xmlTextWriterPtr
+                                                          writer,
+                                                          const char
+                                                          *format,
+                                                          va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteString(xmlTextWriterPtr writer,
+                                                   const xmlChar *
+                                                   content);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteBase64(xmlTextWriterPtr writer,
+                                                   const char *data,
+                                                   int start, int len);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteBinHex(xmlTextWriterPtr writer,
+                                                   const char *data,
+                                                   int start, int len);
+
+/*
+ * Attributes
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartAttribute(xmlTextWriterPtr writer,
+                                    const xmlChar * name);
+    XMLPUBFUN int XMLCALL xmlTextWriterStartAttributeNS(xmlTextWriterPtr
+                                                        writer,
+                                                        const xmlChar *
+                                                        prefix,
+                                                        const xmlChar *
+                                                        name,
+                                                        const xmlChar *
+                                                        namespaceURI);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndAttribute(xmlTextWriterPtr
+                                                    writer);
+
+/*
+ * Attributes conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatAttribute(xmlTextWriterPtr writer,
+                                          const xmlChar * name,
+                                          const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatAttribute(xmlTextWriterPtr writer,
+                                           const xmlChar * name,
+                                           const char *format,
+                                           va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteAttribute(xmlTextWriterPtr
+                                                      writer,
+                                                      const xmlChar * name,
+                                                      const xmlChar *
+                                                      content);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatAttributeNS(xmlTextWriterPtr writer,
+                                            const xmlChar * prefix,
+                                            const xmlChar * name,
+                                            const xmlChar * namespaceURI,
+                                            const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatAttributeNS(xmlTextWriterPtr writer,
+                                             const xmlChar * prefix,
+                                             const xmlChar * name,
+                                             const xmlChar * namespaceURI,
+                                             const char *format,
+                                             va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteAttributeNS(xmlTextWriterPtr
+                                                        writer,
+                                                        const xmlChar *
+                                                        prefix,
+                                                        const xmlChar *
+                                                        name,
+                                                        const xmlChar *
+                                                        namespaceURI,
+                                                        const xmlChar *
+                                                        content);
+
+/*
+ * PI's
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartPI(xmlTextWriterPtr writer,
+                             const xmlChar * target);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndPI(xmlTextWriterPtr writer);
+
+/*
+ * PI conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatPI(xmlTextWriterPtr writer,
+                                   const xmlChar * target,
+                                   const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatPI(xmlTextWriterPtr writer,
+                                    const xmlChar * target,
+                                    const char *format, va_list argptr);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWritePI(xmlTextWriterPtr writer,
+                             const xmlChar * target,
+                             const xmlChar * content);
+
+/**
+ * xmlTextWriterWriteProcessingInstruction:
+ *
+ * This macro maps to xmlTextWriterWritePI
+ */
+#define xmlTextWriterWriteProcessingInstruction xmlTextWriterWritePI
+
+/*
+ * CDATA
+ */
+    XMLPUBFUN int XMLCALL xmlTextWriterStartCDATA(xmlTextWriterPtr writer);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndCDATA(xmlTextWriterPtr writer);
+
+/*
+ * CDATA conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatCDATA(xmlTextWriterPtr writer,
+                                      const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatCDATA(xmlTextWriterPtr writer,
+                                       const char *format, va_list argptr);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteCDATA(xmlTextWriterPtr writer,
+                                const xmlChar * content);
+
+/*
+ * DTD
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartDTD(xmlTextWriterPtr writer,
+                              const xmlChar * name,
+                              const xmlChar * pubid,
+                              const xmlChar * sysid);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndDTD(xmlTextWriterPtr writer);
+
+/*
+ * DTD conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatDTD(xmlTextWriterPtr writer,
+                                    const xmlChar * name,
+                                    const xmlChar * pubid,
+                                    const xmlChar * sysid,
+                                    const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatDTD(xmlTextWriterPtr writer,
+                                     const xmlChar * name,
+                                     const xmlChar * pubid,
+                                     const xmlChar * sysid,
+                                     const char *format, va_list argptr);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteDTD(xmlTextWriterPtr writer,
+                              const xmlChar * name,
+                              const xmlChar * pubid,
+                              const xmlChar * sysid,
+                              const xmlChar * subset);
+
+/**
+ * xmlTextWriterWriteDocType:
+ *
+ * this macro maps to xmlTextWriterWriteDTD
+ */
+#define xmlTextWriterWriteDocType xmlTextWriterWriteDTD
+
+/*
+ * DTD element definition
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartDTDElement(xmlTextWriterPtr writer,
+                                     const xmlChar * name);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDElement(xmlTextWriterPtr
+                                                     writer);
+
+/*
+ * DTD element definition conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatDTDElement(xmlTextWriterPtr writer,
+                                           const xmlChar * name,
+                                           const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatDTDElement(xmlTextWriterPtr writer,
+                                            const xmlChar * name,
+                                            const char *format,
+                                            va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDElement(xmlTextWriterPtr
+                                                       writer,
+                                                       const xmlChar *
+                                                       name,
+                                                       const xmlChar *
+                                                       content);
+
+/*
+ * DTD attribute list definition
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartDTDAttlist(xmlTextWriterPtr writer,
+                                     const xmlChar * name);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDAttlist(xmlTextWriterPtr
+                                                     writer);
+
+/*
+ * DTD attribute list definition conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatDTDAttlist(xmlTextWriterPtr writer,
+                                           const xmlChar * name,
+                                           const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatDTDAttlist(xmlTextWriterPtr writer,
+                                            const xmlChar * name,
+                                            const char *format,
+                                            va_list argptr);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDAttlist(xmlTextWriterPtr
+                                                       writer,
+                                                       const xmlChar *
+                                                       name,
+                                                       const xmlChar *
+                                                       content);
+
+/*
+ * DTD entity definition
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterStartDTDEntity(xmlTextWriterPtr writer,
+                                    int pe, const xmlChar * name);
+    XMLPUBFUN int XMLCALL xmlTextWriterEndDTDEntity(xmlTextWriterPtr
+                                                    writer);
+
+/*
+ * DTD entity definition conveniency functions
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteFormatDTDInternalEntity(xmlTextWriterPtr writer,
+                                                  int pe,
+                                                  const xmlChar * name,
+                                                  const char *format, ...);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteVFormatDTDInternalEntity(xmlTextWriterPtr writer,
+                                                   int pe,
+                                                   const xmlChar * name,
+                                                   const char *format,
+                                                   va_list argptr);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteDTDInternalEntity(xmlTextWriterPtr writer,
+                                            int pe,
+                                            const xmlChar * name,
+                                            const xmlChar * content);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteDTDExternalEntity(xmlTextWriterPtr writer,
+                                            int pe,
+                                            const xmlChar * name,
+                                            const xmlChar * pubid,
+                                            const xmlChar * sysid,
+                                            const xmlChar * ndataid);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteDTDExternalEntityContents(xmlTextWriterPtr
+                                                    writer,
+                                                    const xmlChar * pubid,
+                                                    const xmlChar * sysid,
+                                                    const xmlChar *
+                                                    ndataid);
+    XMLPUBFUN int XMLCALL xmlTextWriterWriteDTDEntity(xmlTextWriterPtr
+                                                      writer, int pe,
+                                                      const xmlChar * name,
+                                                      const xmlChar *
+                                                      pubid,
+                                                      const xmlChar *
+                                                      sysid,
+                                                      const xmlChar *
+                                                      ndataid,
+                                                      const xmlChar *
+                                                      content);
+
+/*
+ * DTD notation definition
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterWriteDTDNotation(xmlTextWriterPtr writer,
+                                      const xmlChar * name,
+                                      const xmlChar * pubid,
+                                      const xmlChar * sysid);
+
+/*
+ * Indentation
+ */
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterSetIndent(xmlTextWriterPtr writer, int indent);
+    XMLPUBFUN int XMLCALL
+        xmlTextWriterSetIndentString(xmlTextWriterPtr writer,
+                                     const xmlChar * str);
+
+/*
+ * misc
+ */
+    XMLPUBFUN int XMLCALL xmlTextWriterFlush(xmlTextWriterPtr writer);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_WRITER_ENABLED */
+
+#endif                          /* __XML_XMLWRITER_H__ */
diff -Naur orig.ns-2.33/libxml/xpath.h ns-2.33/libxml/xpath.h
--- orig.ns-2.33/libxml/xpath.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xpath.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,543 @@
+/*
+ * Summary: XML Path Language implementation
+ * Description: API for the XML Path Language implementation
+ *
+ * XML Path Language implementation
+ * XPath is a language for addressing parts of an XML document,
+ * designed to be used by both XSLT and XPointer
+ *     http://www.w3.org/TR/xpath
+ *
+ * Implements
+ * W3C Recommendation 16 November 1999
+ *     http://www.w3.org/TR/1999/REC-xpath-19991116
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XPATH_H__
+#define __XML_XPATH_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_XPATH_ENABLED
+
+#include <libxml/xmlerror.h>
+#include <libxml/tree.h>
+#include <libxml/hash.h>
+#endif /* LIBXML_XPATH_ENABLED */
+
+#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+#ifdef __cplusplus
+extern "C" {
+#endif
+#endif /* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED */
+	
+#ifdef LIBXML_XPATH_ENABLED
+
+typedef struct _xmlXPathContext xmlXPathContext;
+typedef xmlXPathContext *xmlXPathContextPtr;
+typedef struct _xmlXPathParserContext xmlXPathParserContext;
+typedef xmlXPathParserContext *xmlXPathParserContextPtr;
+
+/**
+ * The set of XPath error codes.
+ */
+
+typedef enum {
+    XPATH_EXPRESSION_OK = 0,
+    XPATH_NUMBER_ERROR,
+    XPATH_UNFINISHED_LITERAL_ERROR,
+    XPATH_START_LITERAL_ERROR,
+    XPATH_VARIABLE_REF_ERROR,
+    XPATH_UNDEF_VARIABLE_ERROR,
+    XPATH_INVALID_PREDICATE_ERROR,
+    XPATH_EXPR_ERROR,
+    XPATH_UNCLOSED_ERROR,
+    XPATH_UNKNOWN_FUNC_ERROR,
+    XPATH_INVALID_OPERAND,
+    XPATH_INVALID_TYPE,
+    XPATH_INVALID_ARITY,
+    XPATH_INVALID_CTXT_SIZE,
+    XPATH_INVALID_CTXT_POSITION,
+    XPATH_MEMORY_ERROR,
+    XPTR_SYNTAX_ERROR,
+    XPTR_RESOURCE_ERROR,
+    XPTR_SUB_RESOURCE_ERROR,
+    XPATH_UNDEF_PREFIX_ERROR,
+    XPATH_ENCODING_ERROR,
+    XPATH_INVALID_CHAR_ERROR,
+    XPATH_INVALID_CTXT
+} xmlXPathError;
+
+/*
+ * A node-set (an unordered collection of nodes without duplicates).
+ */
+typedef struct _xmlNodeSet xmlNodeSet;
+typedef xmlNodeSet *xmlNodeSetPtr;
+struct _xmlNodeSet {
+    int nodeNr;			/* number of nodes in the set */
+    int nodeMax;		/* size of the array as allocated */
+    xmlNodePtr *nodeTab;	/* array of nodes in no particular order */
+    /* @@ with_ns to check wether namespace nodes should be looked at @@ */
+};
+
+/*
+ * An expression is evaluated to yield an object, which
+ * has one of the following four basic types:
+ *   - node-set
+ *   - boolean
+ *   - number
+ *   - string
+ *
+ * @@ XPointer will add more types !
+ */
+
+typedef enum {
+    XPATH_UNDEFINED = 0,
+    XPATH_NODESET = 1,
+    XPATH_BOOLEAN = 2,
+    XPATH_NUMBER = 3,
+    XPATH_STRING = 4,
+    XPATH_POINT = 5,
+    XPATH_RANGE = 6,
+    XPATH_LOCATIONSET = 7,
+    XPATH_USERS = 8,
+    XPATH_XSLT_TREE = 9  /* An XSLT value tree, non modifiable */
+} xmlXPathObjectType;
+
+typedef struct _xmlXPathObject xmlXPathObject;
+typedef xmlXPathObject *xmlXPathObjectPtr;
+struct _xmlXPathObject {
+    xmlXPathObjectType type;
+    xmlNodeSetPtr nodesetval;
+    int boolval;
+    double floatval;
+    xmlChar *stringval;
+    void *user;
+    int index;
+    void *user2;
+    int index2;
+};
+
+/**
+ * xmlXPathConvertFunc:
+ * @obj:  an XPath object
+ * @type:  the number of the target type
+ *
+ * A conversion function is associated to a type and used to cast
+ * the new type to primitive values.
+ *
+ * Returns -1 in case of error, 0 otherwise
+ */
+typedef int (*xmlXPathConvertFunc) (xmlXPathObjectPtr obj, int type);
+
+/*
+ * Extra type: a name and a conversion function.
+ */
+
+typedef struct _xmlXPathType xmlXPathType;
+typedef xmlXPathType *xmlXPathTypePtr;
+struct _xmlXPathType {
+    const xmlChar         *name;		/* the type name */
+    xmlXPathConvertFunc func;		/* the conversion function */
+};
+
+/*
+ * Extra variable: a name and a value.
+ */
+
+typedef struct _xmlXPathVariable xmlXPathVariable;
+typedef xmlXPathVariable *xmlXPathVariablePtr;
+struct _xmlXPathVariable {
+    const xmlChar       *name;		/* the variable name */
+    xmlXPathObjectPtr value;		/* the value */
+};
+
+/**
+ * xmlXPathEvalFunc:
+ * @ctxt: an XPath parser context
+ * @nargs: the number of arguments passed to the function
+ *
+ * An XPath evaluation function, the parameters are on the XPath context stack.
+ */
+
+typedef void (*xmlXPathEvalFunc)(xmlXPathParserContextPtr ctxt,
+	                         int nargs);
+
+/*
+ * Extra function: a name and a evaluation function.
+ */
+
+typedef struct _xmlXPathFunct xmlXPathFunct;
+typedef xmlXPathFunct *xmlXPathFuncPtr;
+struct _xmlXPathFunct {
+    const xmlChar      *name;		/* the function name */
+    xmlXPathEvalFunc func;		/* the evaluation function */
+};
+
+/**
+ * xmlXPathAxisFunc:
+ * @ctxt:  the XPath interpreter context
+ * @cur:  the previous node being explored on that axis
+ *
+ * An axis traversal function. To traverse an axis, the engine calls
+ * the first time with cur == NULL and repeat until the function returns
+ * NULL indicating the end of the axis traversal.
+ *
+ * Returns the next node in that axis or NULL if at the end of the axis.
+ */
+
+typedef xmlXPathObjectPtr (*xmlXPathAxisFunc) (xmlXPathParserContextPtr ctxt,
+				 xmlXPathObjectPtr cur);
+
+/*
+ * Extra axis: a name and an axis function.
+ */
+
+typedef struct _xmlXPathAxis xmlXPathAxis;
+typedef xmlXPathAxis *xmlXPathAxisPtr;
+struct _xmlXPathAxis {
+    const xmlChar      *name;		/* the axis name */
+    xmlXPathAxisFunc func;		/* the search function */
+};
+
+/**
+ * xmlXPathFunction:
+ * @ctxt:  the XPath interprestation context
+ * @nargs:  the number of arguments
+ *
+ * An XPath function.
+ * The arguments (if any) are popped out from the context stack
+ * and the result is pushed on the stack.
+ */
+
+typedef void (*xmlXPathFunction) (xmlXPathParserContextPtr ctxt, int nargs);
+
+/*
+ * Function and Variable Lookup.
+ */
+
+/**
+ * xmlXPathVariableLookupFunc:
+ * @ctxt:  an XPath context
+ * @name:  name of the variable
+ * @ns_uri:  the namespace name hosting this variable
+ *
+ * Prototype for callbacks used to plug variable lookup in the XPath
+ * engine.
+ *
+ * Returns the XPath object value or NULL if not found.
+ */
+typedef xmlXPathObjectPtr (*xmlXPathVariableLookupFunc) (void *ctxt,
+                                         const xmlChar *name,
+                                         const xmlChar *ns_uri);
+
+/**
+ * xmlXPathFuncLookupFunc:
+ * @ctxt:  an XPath context
+ * @name:  name of the function
+ * @ns_uri:  the namespace name hosting this function
+ *
+ * Prototype for callbacks used to plug function lookup in the XPath
+ * engine.
+ *
+ * Returns the XPath function or NULL if not found.
+ */
+typedef xmlXPathFunction (*xmlXPathFuncLookupFunc) (void *ctxt,
+					 const xmlChar *name,
+					 const xmlChar *ns_uri);
+
+/**
+ * xmlXPathFlags:
+ * Flags for XPath engine compilation and runtime
+ */
+/**
+ * XML_XPATH_CHECKNS:
+ *
+ * check namespaces at compilation
+ */
+#define XML_XPATH_CHECKNS (1<<0)
+/**
+ * XML_XPATH_NOVAR:
+ *
+ * forbid variables in expression
+ */
+#define XML_XPATH_NOVAR	  (1<<1)
+
+/**
+ * xmlXPathContext:
+ *
+ * Expression evaluation occurs with respect to a context.
+ * he context consists of:
+ *    - a node (the context node) 
+ *    - a node list (the context node list) 
+ *    - a set of variable bindings 
+ *    - a function library 
+ *    - the set of namespace declarations in scope for the expression 
+ * Following the switch to hash tables, this need to be trimmed up at
+ * the next binary incompatible release.
+ */
+
+struct _xmlXPathContext {
+    xmlDocPtr doc;			/* The current document */
+    xmlNodePtr node;			/* The current node */
+
+    int nb_variables_unused;		/* unused (hash table) */
+    int max_variables_unused;		/* unused (hash table) */
+    xmlHashTablePtr varHash;		/* Hash table of defined variables */
+
+    int nb_types;			/* number of defined types */
+    int max_types;			/* max number of types */
+    xmlXPathTypePtr types;		/* Array of defined types */
+
+    int nb_funcs_unused;		/* unused (hash table) */
+    int max_funcs_unused;		/* unused (hash table) */
+    xmlHashTablePtr funcHash;		/* Hash table of defined funcs */
+
+    int nb_axis;			/* number of defined axis */
+    int max_axis;			/* max number of axis */
+    xmlXPathAxisPtr axis;		/* Array of defined axis */
+
+    /* the namespace nodes of the context node */
+    xmlNsPtr *namespaces;		/* Array of namespaces */
+    int nsNr;				/* number of namespace in scope */
+    void *user;				/* function to free */
+
+    /* extra variables */
+    int contextSize;			/* the context size */
+    int proximityPosition;		/* the proximity position */
+
+    /* extra stuff for XPointer */
+    int xptr;				/* is this an XPointer context? */
+    xmlNodePtr here;			/* for here() */
+    xmlNodePtr origin;			/* for origin() */
+
+    /* the set of namespace declarations in scope for the expression */
+    xmlHashTablePtr nsHash;		/* The namespaces hash table */
+    xmlXPathVariableLookupFunc varLookupFunc;/* variable lookup func */
+    void *varLookupData;		/* variable lookup data */
+
+    /* Possibility to link in an extra item */
+    void *extra;                        /* needed for XSLT */
+
+    /* The function name and URI when calling a function */
+    const xmlChar *function;
+    const xmlChar *functionURI;
+
+    /* function lookup function and data */
+    xmlXPathFuncLookupFunc funcLookupFunc;/* function lookup func */
+    void *funcLookupData;		/* function lookup data */
+
+    /* temporary namespace lists kept for walking the namespace axis */
+    xmlNsPtr *tmpNsList;		/* Array of namespaces */
+    int tmpNsNr;			/* number of namespaces in scope */
+
+    /* error reporting mechanism */
+    void *userData;                     /* user specific data block */
+    xmlStructuredErrorFunc error;       /* the callback in case of errors */
+    xmlError lastError;			/* the last error */
+    xmlNodePtr debugNode;		/* the source node XSLT */
+
+    /* dictionary */
+    xmlDictPtr dict;			/* dictionary if any */
+
+    int flags;				/* flags to control compilation */
+
+    /* Cache for reusal of XPath objects */
+    void *cache;
+};
+
+/*
+ * The structure of a compiled expression form is not public.
+ */
+
+typedef struct _xmlXPathCompExpr xmlXPathCompExpr;
+typedef xmlXPathCompExpr *xmlXPathCompExprPtr;
+
+/**
+ * xmlXPathParserContext:
+ *
+ * An XPath parser context. It contains pure parsing informations,
+ * an xmlXPathContext, and the stack of objects.
+ */
+struct _xmlXPathParserContext {
+    const xmlChar *cur;			/* the current char being parsed */
+    const xmlChar *base;			/* the full expression */
+
+    int error;				/* error code */
+
+    xmlXPathContextPtr  context;	/* the evaluation context */
+    xmlXPathObjectPtr     value;	/* the current value */
+    int                 valueNr;	/* number of values stacked */
+    int                valueMax;	/* max number of values stacked */
+    xmlXPathObjectPtr *valueTab;	/* stack of values */
+
+    xmlXPathCompExprPtr comp;		/* the precompiled expression */
+    int xptr;				/* it this an XPointer expression */
+    xmlNodePtr         ancestor;	/* used for walking preceding axis */
+};
+
+/************************************************************************
+ *									*
+ *			Public API					*
+ *									*
+ ************************************************************************/
+
+/**
+ * Objects and Nodesets handling
+ */
+
+XMLPUBVAR double xmlXPathNAN;
+XMLPUBVAR double xmlXPathPINF;
+XMLPUBVAR double xmlXPathNINF;
+
+/* These macros may later turn into functions */
+/**
+ * xmlXPathNodeSetGetLength:
+ * @ns:  a node-set
+ *
+ * Implement a functionality similar to the DOM NodeList.length.
+ *
+ * Returns the number of nodes in the node-set.
+ */
+#define xmlXPathNodeSetGetLength(ns) ((ns) ? (ns)->nodeNr : 0)
+/**
+ * xmlXPathNodeSetItem:
+ * @ns:  a node-set
+ * @index:  index of a node in the set
+ *
+ * Implements a functionality similar to the DOM NodeList.item().
+ *
+ * Returns the xmlNodePtr at the given @index in @ns or NULL if
+ *         @index is out of range (0 to length-1)
+ */
+#define xmlXPathNodeSetItem(ns, index)				\
+		((((ns) != NULL) && 				\
+		  ((index) >= 0) && ((index) < (ns)->nodeNr)) ?	\
+		 (ns)->nodeTab[(index)]				\
+		 : NULL)
+/**
+ * xmlXPathNodeSetIsEmpty:
+ * @ns: a node-set
+ *
+ * Checks whether @ns is empty or not.
+ *
+ * Returns %TRUE if @ns is an empty node-set.
+ */
+#define xmlXPathNodeSetIsEmpty(ns)                                      \
+    (((ns) == NULL) || ((ns)->nodeNr == 0) || ((ns)->nodeTab == NULL))
+
+
+XMLPUBFUN void XMLCALL		   
+		    xmlXPathFreeObject		(xmlXPathObjectPtr obj);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	   
+		    xmlXPathNodeSetCreate	(xmlNodePtr val);
+XMLPUBFUN void XMLCALL		   
+		    xmlXPathFreeNodeSetList	(xmlXPathObjectPtr obj);
+XMLPUBFUN void XMLCALL		   
+		    xmlXPathFreeNodeSet		(xmlNodeSetPtr obj);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		    xmlXPathObjectCopy		(xmlXPathObjectPtr val);
+XMLPUBFUN int XMLCALL		   
+		    xmlXPathCmpNodes		(xmlNodePtr node1,
+						 xmlNodePtr node2);
+/**
+ * Conversion functions to basic types.
+ */
+XMLPUBFUN int XMLCALL		   
+		    xmlXPathCastNumberToBoolean	(double val);
+XMLPUBFUN int XMLCALL		   
+		    xmlXPathCastStringToBoolean	(const xmlChar * val);
+XMLPUBFUN int XMLCALL		   
+		    xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);
+XMLPUBFUN int XMLCALL		   
+		    xmlXPathCastToBoolean	(xmlXPathObjectPtr val);
+
+XMLPUBFUN double XMLCALL		   
+		    xmlXPathCastBooleanToNumber	(int val);
+XMLPUBFUN double XMLCALL		   
+		    xmlXPathCastStringToNumber	(const xmlChar * val);
+XMLPUBFUN double XMLCALL		   
+		    xmlXPathCastNodeToNumber	(xmlNodePtr node);
+XMLPUBFUN double XMLCALL		   
+		    xmlXPathCastNodeSetToNumber	(xmlNodeSetPtr ns);
+XMLPUBFUN double XMLCALL		   
+		    xmlXPathCastToNumber	(xmlXPathObjectPtr val);
+
+XMLPUBFUN xmlChar * XMLCALL	   
+		    xmlXPathCastBooleanToString	(int val);
+XMLPUBFUN xmlChar * XMLCALL	   
+		    xmlXPathCastNumberToString	(double val);
+XMLPUBFUN xmlChar * XMLCALL	   
+		    xmlXPathCastNodeToString	(xmlNodePtr node);
+XMLPUBFUN xmlChar * XMLCALL	   
+		    xmlXPathCastNodeSetToString	(xmlNodeSetPtr ns);
+XMLPUBFUN xmlChar * XMLCALL	   
+		    xmlXPathCastToString	(xmlXPathObjectPtr val);
+
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		    xmlXPathConvertBoolean	(xmlXPathObjectPtr val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		    xmlXPathConvertNumber	(xmlXPathObjectPtr val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		    xmlXPathConvertString	(xmlXPathObjectPtr val);
+
+/**
+ * Context handling.
+ */
+XMLPUBFUN xmlXPathContextPtr XMLCALL 
+		    xmlXPathNewContext		(xmlDocPtr doc);
+XMLPUBFUN void XMLCALL
+		    xmlXPathFreeContext		(xmlXPathContextPtr ctxt);
+XMLPUBFUN int XMLCALL
+		    xmlXPathContextSetCache(xmlXPathContextPtr ctxt,
+				            int active,
+					    int value,
+					    int options);
+/**
+ * Evaluation functions.
+ */
+XMLPUBFUN long XMLCALL               
+		    xmlXPathOrderDocElems	(xmlDocPtr doc);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		    xmlXPathEval		(const xmlChar *str,
+						 xmlXPathContextPtr ctx);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		    xmlXPathEvalExpression	(const xmlChar *str,
+						 xmlXPathContextPtr ctxt);
+XMLPUBFUN int XMLCALL                
+		    xmlXPathEvalPredicate	(xmlXPathContextPtr ctxt,
+						 xmlXPathObjectPtr res);
+/**
+ * Separate compilation/evaluation entry points.
+ */
+XMLPUBFUN xmlXPathCompExprPtr XMLCALL 
+		    xmlXPathCompile		(const xmlChar *str);
+XMLPUBFUN xmlXPathCompExprPtr XMLCALL 
+		    xmlXPathCtxtCompile		(xmlXPathContextPtr ctxt,
+		    				 const xmlChar *str);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL   
+		    xmlXPathCompiledEval	(xmlXPathCompExprPtr comp,
+						 xmlXPathContextPtr ctx);
+XMLPUBFUN int XMLCALL   
+		    xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,
+						 xmlXPathContextPtr ctxt);
+XMLPUBFUN void XMLCALL                
+		    xmlXPathFreeCompExpr	(xmlXPathCompExprPtr comp);
+#endif /* LIBXML_XPATH_ENABLED */
+#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)
+XMLPUBFUN void XMLCALL		   
+		    xmlXPathInit		(void);
+XMLPUBFUN int XMLCALL
+		xmlXPathIsNaN	(double val);
+XMLPUBFUN int XMLCALL
+		xmlXPathIsInf	(double val);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED*/
+#endif /* ! __XML_XPATH_H__ */
diff -Naur orig.ns-2.33/libxml/xpathInternals.h ns-2.33/libxml/xpathInternals.h
--- orig.ns-2.33/libxml/xpathInternals.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xpathInternals.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,630 @@
+/*
+ * Summary: internal interfaces for XML Path Language implementation
+ * Description: internal interfaces for XML Path Language implementation
+ *              used to build new modules on top of XPath like XPointer and
+ *              XSLT
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XPATH_INTERNALS_H__
+#define __XML_XPATH_INTERNALS_H__
+
+#include <libxml/xmlversion.h>
+#include <libxml/xpath.h>
+
+#ifdef LIBXML_XPATH_ENABLED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/************************************************************************
+ *									*
+ *			Helpers						*
+ *									*
+ ************************************************************************/
+
+/*
+ * Many of these macros may later turn into functions. They
+ * shouldn't be used in #ifdef's preprocessor instructions.
+ */
+/**
+ * xmlXPathSetError:
+ * @ctxt:  an XPath parser context
+ * @err:  an xmlXPathError code
+ *
+ * Raises an error.
+ */
+#define xmlXPathSetError(ctxt, err)					\
+    { xmlXPatherror((ctxt), __FILE__, __LINE__, (err));			\
+      if ((ctxt) != NULL) (ctxt)->error = (err); }
+
+/**
+ * xmlXPathSetArityError:
+ * @ctxt:  an XPath parser context
+ *
+ * Raises an XPATH_INVALID_ARITY error.
+ */
+#define xmlXPathSetArityError(ctxt)					\
+    xmlXPathSetError((ctxt), XPATH_INVALID_ARITY)
+
+/**
+ * xmlXPathSetTypeError:
+ * @ctxt:  an XPath parser context
+ *
+ * Raises an XPATH_INVALID_TYPE error.
+ */
+#define xmlXPathSetTypeError(ctxt)					\
+    xmlXPathSetError((ctxt), XPATH_INVALID_TYPE)
+
+/**
+ * xmlXPathGetError:
+ * @ctxt:  an XPath parser context
+ *
+ * Get the error code of an XPath context.
+ *
+ * Returns the context error.
+ */
+#define xmlXPathGetError(ctxt)	  ((ctxt)->error)
+
+/**
+ * xmlXPathCheckError:
+ * @ctxt:  an XPath parser context
+ *
+ * Check if an XPath error was raised.
+ *
+ * Returns true if an error has been raised, false otherwise.
+ */
+#define xmlXPathCheckError(ctxt)  ((ctxt)->error != XPATH_EXPRESSION_OK)
+
+/**
+ * xmlXPathGetDocument:
+ * @ctxt:  an XPath parser context
+ *
+ * Get the document of an XPath context.
+ *
+ * Returns the context document.
+ */
+#define xmlXPathGetDocument(ctxt)	((ctxt)->context->doc)
+
+/**
+ * xmlXPathGetContextNode:
+ * @ctxt: an XPath parser context
+ *
+ * Get the context node of an XPath context.
+ *
+ * Returns the context node.
+ */
+#define xmlXPathGetContextNode(ctxt)	((ctxt)->context->node)
+
+XMLPUBFUN int XMLCALL		
+		xmlXPathPopBoolean	(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN double XMLCALL		
+    		xmlXPathPopNumber	(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL	
+    		xmlXPathPopString	(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+    		xmlXPathPopNodeSet	(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void * XMLCALL		
+    		xmlXPathPopExternal	(xmlXPathParserContextPtr ctxt);
+
+/**
+ * xmlXPathReturnBoolean:
+ * @ctxt:  an XPath parser context
+ * @val:  a boolean
+ *
+ * Pushes the boolean @val on the context stack.
+ */
+#define xmlXPathReturnBoolean(ctxt, val)				\
+    valuePush((ctxt), xmlXPathNewBoolean(val))
+
+/**
+ * xmlXPathReturnTrue:
+ * @ctxt:  an XPath parser context
+ *
+ * Pushes true on the context stack.
+ */
+#define xmlXPathReturnTrue(ctxt)   xmlXPathReturnBoolean((ctxt), 1)
+
+/**
+ * xmlXPathReturnFalse:
+ * @ctxt:  an XPath parser context
+ *
+ * Pushes false on the context stack.
+ */
+#define xmlXPathReturnFalse(ctxt)  xmlXPathReturnBoolean((ctxt), 0)
+
+/**
+ * xmlXPathReturnNumber:
+ * @ctxt:  an XPath parser context
+ * @val:  a double
+ *
+ * Pushes the double @val on the context stack.
+ */
+#define xmlXPathReturnNumber(ctxt, val)					\
+    valuePush((ctxt), xmlXPathNewFloat(val))
+
+/**
+ * xmlXPathReturnString:
+ * @ctxt:  an XPath parser context
+ * @str:  a string
+ *
+ * Pushes the string @str on the context stack.
+ */
+#define xmlXPathReturnString(ctxt, str)					\
+    valuePush((ctxt), xmlXPathWrapString(str))
+
+/**
+ * xmlXPathReturnEmptyString:
+ * @ctxt:  an XPath parser context
+ *
+ * Pushes an empty string on the stack.
+ */
+#define xmlXPathReturnEmptyString(ctxt)					\
+    valuePush((ctxt), xmlXPathNewCString(""))
+
+/**
+ * xmlXPathReturnNodeSet:
+ * @ctxt:  an XPath parser context
+ * @ns:  a node-set
+ *
+ * Pushes the node-set @ns on the context stack.
+ */
+#define xmlXPathReturnNodeSet(ctxt, ns)					\
+    valuePush((ctxt), xmlXPathWrapNodeSet(ns))
+
+/**
+ * xmlXPathReturnEmptyNodeSet:
+ * @ctxt:  an XPath parser context
+ *
+ * Pushes an empty node-set on the context stack.
+ */
+#define xmlXPathReturnEmptyNodeSet(ctxt)				\
+    valuePush((ctxt), xmlXPathNewNodeSet(NULL))
+
+/**
+ * xmlXPathReturnExternal:
+ * @ctxt:  an XPath parser context
+ * @val:  user data
+ *
+ * Pushes user data on the context stack.
+ */
+#define xmlXPathReturnExternal(ctxt, val)				\
+    valuePush((ctxt), xmlXPathWrapExternal(val))
+
+/**
+ * xmlXPathStackIsNodeSet:
+ * @ctxt: an XPath parser context
+ *
+ * Check if the current value on the XPath stack is a node set or
+ * an XSLT value tree.
+ *
+ * Returns true if the current object on the stack is a node-set.
+ */
+#define xmlXPathStackIsNodeSet(ctxt)					\
+    (((ctxt)->value != NULL)						\
+     && (((ctxt)->value->type == XPATH_NODESET)				\
+         || ((ctxt)->value->type == XPATH_XSLT_TREE)))
+
+/**
+ * xmlXPathStackIsExternal:
+ * @ctxt: an XPath parser context
+ *
+ * Checks if the current value on the XPath stack is an external
+ * object.
+ *
+ * Returns true if the current object on the stack is an external
+ * object.
+ */
+#define xmlXPathStackIsExternal(ctxt)					\
+	((ctxt->value != NULL) && (ctxt->value->type == XPATH_USERS))
+
+/**
+ * xmlXPathEmptyNodeSet:
+ * @ns:  a node-set
+ *
+ * Empties a node-set.
+ */
+#define xmlXPathEmptyNodeSet(ns)					\
+    { while ((ns)->nodeNr > 0) (ns)->nodeTab[(ns)->nodeNr--] = NULL; }
+
+/**
+ * CHECK_ERROR:
+ *
+ * Macro to return from the function if an XPath error was detected.
+ */
+#define CHECK_ERROR							\
+    if (ctxt->error != XPATH_EXPRESSION_OK) return
+
+/**
+ * CHECK_ERROR0:
+ *
+ * Macro to return 0 from the function if an XPath error was detected.
+ */
+#define CHECK_ERROR0							\
+    if (ctxt->error != XPATH_EXPRESSION_OK) return(0)
+
+/**
+ * XP_ERROR:
+ * @X:  the error code
+ *
+ * Macro to raise an XPath error and return.
+ */
+#define XP_ERROR(X)							\
+    { xmlXPathErr(ctxt, X); return; }
+
+/**
+ * XP_ERROR0:
+ * @X:  the error code
+ *
+ * Macro to raise an XPath error and return 0.
+ */
+#define XP_ERROR0(X)							\
+    { xmlXPathErr(ctxt, X); return(0); }
+
+/**
+ * CHECK_TYPE:
+ * @typeval:  the XPath type
+ *
+ * Macro to check that the value on top of the XPath stack is of a given
+ * type.
+ */
+#define CHECK_TYPE(typeval)						\
+    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
+        XP_ERROR(XPATH_INVALID_TYPE)
+
+/**
+ * CHECK_TYPE0:
+ * @typeval:  the XPath type
+ *
+ * Macro to check that the value on top of the XPath stack is of a given
+ * type. Return(0) in case of failure
+ */
+#define CHECK_TYPE0(typeval)						\
+    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))	\
+        XP_ERROR0(XPATH_INVALID_TYPE)
+
+/**
+ * CHECK_ARITY:
+ * @x:  the number of expected args
+ *
+ * Macro to check that the number of args passed to an XPath function matches.
+ */
+#define CHECK_ARITY(x)							\
+    if (ctxt == NULL) return;						\
+    if (nargs != (x))							\
+        XP_ERROR(XPATH_INVALID_ARITY);
+
+/**
+ * CAST_TO_STRING:
+ *
+ * Macro to try to cast the value on the top of the XPath stack to a string.
+ */
+#define CAST_TO_STRING							\
+    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))	\
+        xmlXPathStringFunction(ctxt, 1);
+
+/**
+ * CAST_TO_NUMBER:
+ *
+ * Macro to try to cast the value on the top of the XPath stack to a number.
+ */
+#define CAST_TO_NUMBER							\
+    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))	\
+        xmlXPathNumberFunction(ctxt, 1);
+
+/**
+ * CAST_TO_BOOLEAN:
+ *
+ * Macro to try to cast the value on the top of the XPath stack to a boolean.
+ */
+#define CAST_TO_BOOLEAN							\
+    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_BOOLEAN))	\
+        xmlXPathBooleanFunction(ctxt, 1);
+
+/*
+ * Variable Lookup forwarding.
+ */
+
+XMLPUBFUN void XMLCALL	
+	xmlXPathRegisterVariableLookup	(xmlXPathContextPtr ctxt,
+					 xmlXPathVariableLookupFunc f,
+					 void *data);
+
+/*
+ * Function Lookup forwarding.
+ */
+
+XMLPUBFUN void XMLCALL	
+	    xmlXPathRegisterFuncLookup	(xmlXPathContextPtr ctxt,
+					 xmlXPathFuncLookupFunc f,
+					 void *funcCtxt);
+
+/*
+ * Error reporting.
+ */
+XMLPUBFUN void XMLCALL		
+		xmlXPatherror	(xmlXPathParserContextPtr ctxt,
+				 const char *file,
+				 int line,
+				 int no);
+
+XMLPUBFUN void XMLCALL
+		xmlXPathErr	(xmlXPathParserContextPtr ctxt,
+				 int error);
+
+#ifdef LIBXML_DEBUG_ENABLED
+XMLPUBFUN void XMLCALL		
+		xmlXPathDebugDumpObject	(FILE *output,
+					 xmlXPathObjectPtr cur,
+					 int depth);
+XMLPUBFUN void XMLCALL		
+	    xmlXPathDebugDumpCompExpr(FILE *output,
+					 xmlXPathCompExprPtr comp,
+					 int depth);
+#endif
+/**
+ * NodeSet handling.
+ */
+XMLPUBFUN int XMLCALL		
+		xmlXPathNodeSetContains		(xmlNodeSetPtr cur,
+						 xmlNodePtr val);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathDifference		(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathIntersection		(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathDistinctSorted		(xmlNodeSetPtr nodes);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathDistinct		(xmlNodeSetPtr nodes);
+
+XMLPUBFUN int XMLCALL		
+		xmlXPathHasSameNodes		(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathNodeLeadingSorted	(xmlNodeSetPtr nodes,
+						 xmlNodePtr node);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathLeadingSorted		(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathNodeLeading		(xmlNodeSetPtr nodes,
+						 xmlNodePtr node);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathLeading			(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathNodeTrailingSorted	(xmlNodeSetPtr nodes,
+						 xmlNodePtr node);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathTrailingSorted		(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathNodeTrailing		(xmlNodeSetPtr nodes,
+						 xmlNodePtr node);
+XMLPUBFUN xmlNodeSetPtr XMLCALL	
+		xmlXPathTrailing		(xmlNodeSetPtr nodes1,
+						 xmlNodeSetPtr nodes2);
+
+
+/**
+ * Extending a context.
+ */
+
+XMLPUBFUN int XMLCALL		   
+		xmlXPathRegisterNs		(xmlXPathContextPtr ctxt,
+						 const xmlChar *prefix,
+						 const xmlChar *ns_uri);
+XMLPUBFUN const xmlChar * XMLCALL	   
+		xmlXPathNsLookup		(xmlXPathContextPtr ctxt,
+						 const xmlChar *prefix);
+XMLPUBFUN void XMLCALL		   
+		xmlXPathRegisteredNsCleanup	(xmlXPathContextPtr ctxt);
+
+XMLPUBFUN int XMLCALL		   
+		xmlXPathRegisterFunc		(xmlXPathContextPtr ctxt,
+						 const xmlChar *name,
+						 xmlXPathFunction f);
+XMLPUBFUN int XMLCALL		   
+		xmlXPathRegisterFuncNS		(xmlXPathContextPtr ctxt,
+						 const xmlChar *name,
+						 const xmlChar *ns_uri,
+						 xmlXPathFunction f);
+XMLPUBFUN int XMLCALL		   
+		xmlXPathRegisterVariable	(xmlXPathContextPtr ctxt,
+						 const xmlChar *name,
+						 xmlXPathObjectPtr value);
+XMLPUBFUN int XMLCALL		   
+		xmlXPathRegisterVariableNS	(xmlXPathContextPtr ctxt,
+						 const xmlChar *name,
+						 const xmlChar *ns_uri,
+						 xmlXPathObjectPtr value);
+XMLPUBFUN xmlXPathFunction XMLCALL   
+		xmlXPathFunctionLookup		(xmlXPathContextPtr ctxt,
+						 const xmlChar *name);
+XMLPUBFUN xmlXPathFunction XMLCALL   
+		xmlXPathFunctionLookupNS	(xmlXPathContextPtr ctxt,
+						 const xmlChar *name,
+						 const xmlChar *ns_uri);
+XMLPUBFUN void XMLCALL		   
+		xmlXPathRegisteredFuncsCleanup	(xmlXPathContextPtr ctxt);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		xmlXPathVariableLookup		(xmlXPathContextPtr ctxt,
+						 const xmlChar *name);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL  
+		xmlXPathVariableLookupNS	(xmlXPathContextPtr ctxt,
+						 const xmlChar *name,
+						 const xmlChar *ns_uri);
+XMLPUBFUN void XMLCALL		   
+		xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);
+
+/**
+ * Utilities to extend XPath.
+ */
+XMLPUBFUN xmlXPathParserContextPtr XMLCALL
+		  xmlXPathNewParserContext	(const xmlChar *str,
+			  			 xmlXPathContextPtr ctxt);
+XMLPUBFUN void XMLCALL		  
+		xmlXPathFreeParserContext	(xmlXPathParserContextPtr ctxt);
+
+/* TODO: remap to xmlXPathValuePop and Push. */
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		valuePop			(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN int XMLCALL		  
+		valuePush			(xmlXPathParserContextPtr ctxt,
+					 	 xmlXPathObjectPtr value);
+
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewString		(const xmlChar *val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewCString		(const char *val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathWrapString		(xmlChar *val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathWrapCString		(char * val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewFloat		(double val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewBoolean		(int val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewNodeSet		(xmlNodePtr val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewValueTree		(xmlNodePtr val);
+XMLPUBFUN void XMLCALL		  
+		xmlXPathNodeSetAdd		(xmlNodeSetPtr cur,
+						 xmlNodePtr val);
+XMLPUBFUN void XMLCALL              
+		xmlXPathNodeSetAddUnique	(xmlNodeSetPtr cur,
+						 xmlNodePtr val);
+XMLPUBFUN void XMLCALL		  
+		xmlXPathNodeSetAddNs		(xmlNodeSetPtr cur, 
+						 xmlNodePtr node, 
+						 xmlNsPtr ns);
+XMLPUBFUN void XMLCALL              
+		xmlXPathNodeSetSort		(xmlNodeSetPtr set);
+
+XMLPUBFUN void XMLCALL		  
+		xmlXPathRoot			(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void XMLCALL		  
+		xmlXPathEvalExpr		(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL	  
+		xmlXPathParseName		(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN xmlChar * XMLCALL	  
+		xmlXPathParseNCName		(xmlXPathParserContextPtr ctxt);
+
+/*
+ * Existing functions.
+ */
+XMLPUBFUN double XMLCALL 
+		xmlXPathStringEvalNumber	(const xmlChar *str);
+XMLPUBFUN int XMLCALL 
+		xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt, 
+						 xmlXPathObjectPtr res);
+XMLPUBFUN void XMLCALL 
+		xmlXPathRegisterAllFunctions	(xmlXPathContextPtr ctxt);
+XMLPUBFUN xmlNodeSetPtr XMLCALL 
+		xmlXPathNodeSetMerge		(xmlNodeSetPtr val1, 
+						 xmlNodeSetPtr val2);
+XMLPUBFUN void XMLCALL 
+		xmlXPathNodeSetDel		(xmlNodeSetPtr cur, 
+						 xmlNodePtr val);
+XMLPUBFUN void XMLCALL 
+		xmlXPathNodeSetRemove		(xmlNodeSetPtr cur, 
+						 int val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathNewNodeSetList		(xmlNodeSetPtr val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathWrapNodeSet		(xmlNodeSetPtr val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL 
+		xmlXPathWrapExternal		(void *val);
+
+XMLPUBFUN int XMLCALL xmlXPathEqualValues(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN int XMLCALL xmlXPathNotEqualValues(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN int XMLCALL xmlXPathCompareValues(xmlXPathParserContextPtr ctxt, int inf, int strict);
+XMLPUBFUN void XMLCALL xmlXPathValueFlipSign(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void XMLCALL xmlXPathAddValues(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void XMLCALL xmlXPathSubValues(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void XMLCALL xmlXPathMultValues(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void XMLCALL xmlXPathDivValues(xmlXPathParserContextPtr ctxt);
+XMLPUBFUN void XMLCALL xmlXPathModValues(xmlXPathParserContextPtr ctxt);
+
+XMLPUBFUN int XMLCALL xmlXPathIsNodeType(const xmlChar *name);
+
+/*
+ * Some of the axis navigation routines.
+ */
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextSelf(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextChild(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextDescendant(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextDescendantOrSelf(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextParent(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAncestorOrSelf(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextFollowingSibling(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextFollowing(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextNamespace(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAttribute(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextPreceding(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextAncestor(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+XMLPUBFUN xmlNodePtr XMLCALL xmlXPathNextPrecedingSibling(xmlXPathParserContextPtr ctxt,
+			xmlNodePtr cur);
+/*
+ * The official core of XPath functions.
+ */
+XMLPUBFUN void XMLCALL xmlXPathLastFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathPositionFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathCountFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathIdFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathLocalNameFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathNamespaceURIFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathStringFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathStringLengthFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathConcatFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathContainsFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathStartsWithFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathSubstringFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathSubstringBeforeFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathSubstringAfterFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathNormalizeFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathTranslateFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathNotFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathTrueFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathFalseFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathLangFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathNumberFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathSumFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathFloorFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathCeilingFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathRoundFunction(xmlXPathParserContextPtr ctxt, int nargs);
+XMLPUBFUN void XMLCALL xmlXPathBooleanFunction(xmlXPathParserContextPtr ctxt, int nargs);
+
+/**
+ * Really internal functions
+ */
+XMLPUBFUN void XMLCALL xmlXPathNodeSetFreeNs(xmlNsPtr ns);
+ 
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_XPATH_ENABLED */
+#endif /* ! __XML_XPATH_INTERNALS_H__ */
diff -Naur orig.ns-2.33/libxml/xpointer.h ns-2.33/libxml/xpointer.h
--- orig.ns-2.33/libxml/xpointer.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/libxml/xpointer.h	2008-08-12 11:48:14.000000000 -0400
@@ -0,0 +1,114 @@
+/*
+ * Summary: API to handle XML Pointers
+ * Description: API to handle XML Pointers
+ * Base implementation was made accordingly to
+ * W3C Candidate Recommendation 7 June 2000
+ * http://www.w3.org/TR/2000/CR-xptr-20000607
+ *
+ * Added support for the element() scheme described in:
+ * W3C Proposed Recommendation 13 November 2002
+ * http://www.w3.org/TR/2002/PR-xptr-element-20021113/  
+ *
+ * Copy: See Copyright for the status of this software.
+ *
+ * Author: Daniel Veillard
+ */
+
+#ifndef __XML_XPTR_H__
+#define __XML_XPTR_H__
+
+#include <libxml/xmlversion.h>
+
+#ifdef LIBXML_XPTR_ENABLED
+
+#include <libxml/tree.h>
+#include <libxml/xpath.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * A Location Set
+ */
+typedef struct _xmlLocationSet xmlLocationSet;
+typedef xmlLocationSet *xmlLocationSetPtr;
+struct _xmlLocationSet {
+    int locNr;		      /* number of locations in the set */
+    int locMax;		      /* size of the array as allocated */
+    xmlXPathObjectPtr *locTab;/* array of locations */
+};
+
+/*
+ * Handling of location sets.
+ */
+
+XMLPUBFUN xmlLocationSetPtr XMLCALL			
+		    xmlXPtrLocationSetCreate	(xmlXPathObjectPtr val);
+XMLPUBFUN void XMLCALL			
+		    xmlXPtrFreeLocationSet	(xmlLocationSetPtr obj);
+XMLPUBFUN xmlLocationSetPtr XMLCALL	
+		    xmlXPtrLocationSetMerge	(xmlLocationSetPtr val1,
+						 xmlLocationSetPtr val2);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewRange		(xmlNodePtr start,
+						 int startindex,
+						 xmlNodePtr end,
+						 int endindex);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewRangePoints	(xmlXPathObjectPtr start,
+						 xmlXPathObjectPtr end);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewRangeNodePoint	(xmlNodePtr start,
+						 xmlXPathObjectPtr end);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewRangePointNode	(xmlXPathObjectPtr start,
+						 xmlNodePtr end);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL			
+		    xmlXPtrNewRangeNodes	(xmlNodePtr start,
+						 xmlNodePtr end);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewLocationSetNodes	(xmlNodePtr start,
+						 xmlNodePtr end);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewRangeNodeObject	(xmlNodePtr start,
+						 xmlXPathObjectPtr end);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrNewCollapsedRange	(xmlNodePtr start);
+XMLPUBFUN void XMLCALL			
+		    xmlXPtrLocationSetAdd	(xmlLocationSetPtr cur,
+						 xmlXPathObjectPtr val);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrWrapLocationSet	(xmlLocationSetPtr val);
+XMLPUBFUN void XMLCALL			
+		    xmlXPtrLocationSetDel	(xmlLocationSetPtr cur,
+						 xmlXPathObjectPtr val);
+XMLPUBFUN void XMLCALL			
+		    xmlXPtrLocationSetRemove	(xmlLocationSetPtr cur,
+						 int val);
+
+/*
+ * Functions.
+ */
+XMLPUBFUN xmlXPathContextPtr XMLCALL	
+		    xmlXPtrNewContext		(xmlDocPtr doc,
+						 xmlNodePtr here,
+						 xmlNodePtr origin);
+XMLPUBFUN xmlXPathObjectPtr XMLCALL	
+		    xmlXPtrEval			(const xmlChar *str,
+						 xmlXPathContextPtr ctx);
+XMLPUBFUN void XMLCALL					    
+		    xmlXPtrRangeToFunction	(xmlXPathParserContextPtr ctxt,
+       						 int nargs);
+XMLPUBFUN xmlNodePtr XMLCALL		
+		    xmlXPtrBuildNodeList	(xmlXPathObjectPtr obj);
+XMLPUBFUN void XMLCALL		
+		    xmlXPtrEvalRangePredicate	(xmlXPathParserContextPtr ctxt);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBXML_XPTR_ENABLED */
+#endif /* __XML_XPTR_H__ */
diff -Naur orig.ns-2.33/mrperf/datalayout.cc ns-2.33/mrperf/datalayout.cc
--- orig.ns-2.33/mrperf/datalayout.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/mrperf/datalayout.cc	2009-07-07 03:25:42.000000000 -0400
@@ -0,0 +1,450 @@
+#include "datalayout.h"
+#include "mrperf.h"
+
+namespace MRPerf {
+
+const int CHUNK_SIZE=16*1024*1024;
+
+static class NodeClass: public TclClass {
+public:
+	NodeClass() : TclClass("MRPerf/Node") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new Node);
+	}
+} node_class;
+
+Node::Node()
+{
+	//this->chunks = new set<Chunk *>;
+	this->working_on = NULL;
+}
+
+Node::~Node()
+{
+}
+
+int Node::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 3) {
+		if (strcmp(argv[1], "setnodename") == 0) {
+			TMSN& msn = DataLayout::instance().string_to_node;
+
+			this->string_ = argv[2];
+			// n_rg0_0_ng0_1
+			const char * const s = argv[2];
+			char * first = strchr(s, '_');
+			char * second = strchr(first+1, '_');
+			char *third = strchr(second+1, '_');
+
+			*third = NULL;
+			this->rack_ = first+1;
+			msn.insert(pair<std::string, Node*>(this->string_, this));
+
+			return TCL_OK;
+		}
+#if 0
+		else if (strcmp(argv[1], "has") == 0) {
+			Chunk *chunk = get_chunk(const_cast<char*>(argv[2]));
+			if (chunk == NULL) {
+				tcl.add_errorf("Wrong chunk name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			// Here I search for node in chunk's hosts, I can also search
+			// for chunk in node's chunks. should give the same result.
+			if (chunk->get_hosts().find(this) != chunk->get_hosts().end())
+				tcl.result("true");
+			else
+				tcl.result("false");
+			return TCL_OK;
+		}
+#endif
+		else if (strcmp(argv[1], "print") == 0) {
+			fprintf(stderr, "%s %s\n", string_.c_str(), argv[2]);
+
+#if 1
+			DataLayout& inst = DataLayout::instance();
+			TMSN& msn = inst.string_to_node;
+			TSN snit;
+			for (snit = msn.begin(); snit != msn.end(); snit++)
+			{
+				Node *n = const_cast<Node *>(snit->second);
+
+				//fprintf(stderr, "%s\n", snit->first.c_str());
+				n->dump();
+			}
+
+			TMSC& msc = inst.string_to_chunk;
+			TSC scit;
+			for (scit = msc.begin(); scit != msc.end(); scit++)
+			{
+				Chunk *c = const_cast<Chunk *>(scit->second);
+				fprintf(stderr, "%s-----", c->string());
+				set<Disk*>::iterator dit;
+				for (dit = c->get_host_disks().begin(); dit != c->get_host_disks().end(); dit++)
+				{
+					Disk *d = (*dit);
+					fprintf(stderr, " %s:%d", d->host->string(), d->id);
+				}
+				fprintf(stderr, "\n");
+			}
+
+			snit = msn.find(string_);
+			//fprintf(stderr, "%p %p\n", this, (snit->second));
+#endif
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "add-disk") == 0) {
+			Disk *d = (Disk *)TclObject::lookup(argv[2]);
+			d->id = disks.size();
+			this->disks.push_back(d);
+			d->host = this;
+			return TCL_OK;
+		}
+	}
+	else if (argc == 2) {
+		if (strcmp(argv[1], "nodename") == 0) {
+			tcl.result(this->string_.c_str());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "choosedisk") == 0) {
+			tcl.result(disks[0]->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "rack") == 0) {
+			tcl.result(rack_.c_str());
+			return TCL_OK;
+		}
+	}
+
+	//fprintf(stderr, "%d %s\n", argc, argv[1]);
+
+	return (TclObject::command(argc, argv));
+}
+
+void Node::dump()
+{
+	fprintf(stderr, "%s:\n", this->string_.c_str());
+	vector<Disk *>::iterator dit;
+	set<Chunk *>::iterator it;
+	for (dit = disks.begin(); dit != disks.end(); dit++)
+	{
+		fprintf(stderr, "\t");
+		for (it = (*dit)->chunks.begin(); it != (*dit)->chunks.end(); it++)
+			fprintf(stderr, "%s ", (*it)->string());
+		fprintf(stderr, "\n");
+	}
+	//fprintf(stderr, "\n");
+}
+
+Disk * Node::rack_local(Chunk *c)
+{
+	set<Disk*> *disks = &c->get_host_disks();
+	set<Disk*>::iterator dit;
+	for ( dit = disks->begin(); dit != disks->end(); dit++)
+	{
+		Disk *d = *dit;
+		if (rack_.compare(d->host->rack_) == 0)
+			return d;
+	}
+
+	return NULL;
+}
+
+static class DiskClass: public TclClass {
+public:
+	DiskClass() : TclClass("MRPerf/Node/Disk") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new Disk);
+	}
+} disk_class;
+
+int Disk::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "host") == 0) {
+			tcl.result(this->host->name());
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+const char * Disk::string()
+{
+	// TODO: this is not correct. string_ is never assigned a value.
+	return string_.c_str();
+}
+
+static class ChunkClass: public TclClass {
+public:
+	ChunkClass() : TclClass("MRPerf/Chunk") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new Chunk);
+	}
+} chunk_class;
+
+Chunk::Chunk()
+{
+	/* how large a buffer should be? a better string type may be needed */
+	filename = new char[10];
+	memcpy(filename, "filename", 9);
+	chunk = 0;
+	offset = 0;
+	length = 128 * 1024 * 1024;
+
+	//workers_ = new set<Node *>;
+	//hosts_ = new set<Node *>;
+	string_ = filename;
+	char s[100];
+	sprintf(s, ":%d:%d:%d", chunk, offset, length);
+	string_ += s;
+	finished = 0;
+}
+
+Chunk::Chunk(char *f, int c, int o, int l)
+{
+	this->filename = new char[strlen(f)+1];
+	strcpy(this->filename, f);
+	this->chunk = c;
+	this->offset = o;
+	this->length = l;
+
+	//workers_ = new set<Node *>;
+	//hosts_ = new set<Node *>;
+	string_ = filename;
+	char s[100];
+	sprintf(s, ":%d:%d:%d", chunk, offset, length);
+	string_ += s;
+	finished = 0;
+
+	TMSC& msc = DataLayout::instance().string_to_chunk;
+	msc.insert(pair<std::string, Chunk*>(this->string_, this));
+}
+
+Chunk::~Chunk()
+{
+	delete this->filename;
+}
+
+Chunk * get_chunk(const char * string)
+{
+	TMSC& msc = DataLayout::instance().string_to_chunk;
+	TSC scit = msc.find(string);
+
+	if (scit == msc.end())
+	{
+		fprintf(stderr, "Warning: nonexist chunk %s\n", string);
+		return NULL;
+	}
+
+	Chunk* c = const_cast<Chunk*>(scit->second);
+	return c;
+}
+
+Node * get_node(const char * string)
+{
+	TMSN &msn = DataLayout::instance().string_to_node;
+	TSN snit = msn.find(string);
+
+	if (snit == msn.end())
+	{
+		fprintf(stderr, "Warning: nonexist node %s\n", string);
+		return NULL;
+	}
+
+	Node* n = const_cast<Node*>(snit->second);
+	return n;
+}
+
+int Chunk::command(int argc, const char*const* argv)
+{
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "name") == 0) {
+			tcl.resultf("%s:%d:%d:%d", filename, chunk, offset, length);
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+void Chunk::dump()
+{
+	fprintf(stderr, "%s\n", string());
+}
+
+DataLayout* DataLayout::instance_;
+
+DataLayout::DataLayout()
+{
+	//string_to_chunk = new TMSC;
+	//string_to_node = new TMSN;
+#if 0
+	Tcl& tcl = Tcl::instance();
+	tcl.eval("set epsilon");
+	g_epsilon = atof(tcl.result());
+
+	if (g_epsilon <= 0)
+	{
+		cout << "g_epsilon < 0: " << g_epsilon << \
+			", setting it to 0.01" << endl;
+		g_epsilon = 0.01;
+	}
+#endif
+}
+
+int DataLayout::read_xml(const char *meta_xml)
+{
+
+	/*
+	 * this initialize the library and check potential ABI mismatches
+	 * between the version it was compiled for and the actual shared
+	 * library used.
+	 */
+	LIBXML_TEST_VERSION
+
+	return _parse(meta_xml);
+
+}
+
+DataLayout::~DataLayout()
+{
+	xmlFreeDoc(doc);
+
+	/*
+	 * Cleanup function for the XML library.
+	 */
+	xmlCleanupParser();
+	/*
+	 * this is to debug memory for regression tests
+	 */
+	xmlMemoryDump();
+}
+
+int DataLayout::_parse(const char *meta_xml)
+{
+	xmlNodePtr nfile, nchunk, nreplica;
+	xmlChar *dir, *file, *chunk, *rep, *name_node;
+	int chunk_size;
+
+	doc = xmlReadFile(meta_xml, NULL, 0);
+	if (doc == NULL) {
+		fprintf(stderr, "Failed to parse %s\n", meta_xml);
+		return -1;
+	}
+
+	xmlNodePtr cur = xmlDocGetRootElement(doc);
+	cur = cur->xmlChildrenNode;
+
+	for ( ; cur && (xmlStrcmp(cur->name, (const xmlChar *)"chunk_size") != 0); cur = cur->next);
+	if (cur != NULL) {
+		chunk_size = atoi(reinterpret_cast<char *>(xmlNodeListGetString(doc, cur->xmlChildrenNode, 1))) * 1024 * 1024;
+		//printf("chunk_size from xml: %d\n", chunk_size);
+	} else {
+		chunk_size = CHUNK_SIZE;
+		cur = xmlDocGetRootElement(doc);
+	}
+	for ( ; cur && (xmlStrcmp(cur->name, (const xmlChar *)"name_node") != 0); cur = cur->next);
+	name_node = xmlNodeListGetString(doc, cur->xmlChildrenNode, 1);
+	//printf("name node from xml: %s\n", name_node);
+	Tcl& tcl = Tcl::instance();
+	tcl.evalf("set nn $%s\n", name_node);
+
+	while ( cur && (xmlIsBlankNode(cur) \
+					|| xmlStrcmp(cur->name, (const xmlChar *) "dir") != 0)) {
+		cur = cur->next;
+	}
+	if (cur == NULL) {
+		xmlFreeDoc(doc);
+		return -1;
+	}
+
+	dir = xmlGetProp(cur, (const xmlChar *) "name");
+
+	for (nfile = cur->xmlChildrenNode; nfile != NULL; nfile = nfile->next)
+	{
+		if (xmlStrcmp(nfile->name, (const xmlChar *) "file") != 0)
+			continue;
+		file = xmlGetProp(nfile, (const xmlChar *) "name");
+
+		for (nchunk = nfile->xmlChildrenNode; nchunk != NULL; nchunk = nchunk->next)
+		{
+			if (xmlStrcmp(nchunk->name, (const xmlChar *) "chunk") != 0)
+				continue;
+			chunk = xmlGetProp(nchunk, (const xmlChar *) "id");
+			Chunk *c = new Chunk(reinterpret_cast<char *>(file),
+						atoi(reinterpret_cast<char *>(chunk)), 0, chunk_size);
+
+			for (nreplica = nchunk->xmlChildrenNode; nreplica != NULL;
+				nreplica = nreplica->next)
+			{
+				if (xmlStrcmp(nreplica->name, (const xmlChar *) "rep") != 0)
+					continue;
+				rep = xmlNodeListGetString(doc, nreplica->xmlChildrenNode, 1);
+
+				std::string str (reinterpret_cast<char *>(rep));
+				size_t underscore = str.rfind('_');
+				str[0] = 'n';
+
+				Node *n = get_node(str.substr(0, underscore).c_str());
+				int disk_id = atoi(str.substr(underscore+strlen("_disk")).c_str());
+				if (n == NULL)
+				{
+					fprintf(stderr, "warning: nonexist node: %s\n", str.c_str());
+
+					// TODO: maybe other operations
+					//return;
+				}
+
+#if 0
+				// replicas guaranteed on disk level, not node level.
+				// see comments in gen.py.
+				if (c->get_hosts().find(n) != c->get_hosts().end())
+					fprintf(stderr, "error!!!! %s %s\n", n->string(), c->string());
+				if (n->chunks.find(c) != n->chunks.end())
+					fprintf(stderr, "error!!!!!!!\n");
+#endif
+				Disk *d = n->disks[disk_id];
+				c->get_host_disks().insert(d);
+				d->chunks.insert(c);
+
+				//c->get_hosts().insert(n);
+				//n->chunks.insert(c);
+
+#if 0
+				DataLayout& inst = DataLayout::instance();
+				inst.chunk_to_nodes.insert(pair<Chunk,Node>(*c, *n));
+				inst.node_to_chunks.insert(pair<Node,Chunk>(*n, *c));
+#endif
+			}
+		}
+	}
+
+	DataLayout& inst = DataLayout::instance();
+	TMSC& msc = inst.string_to_chunk;
+	fprintf(stderr, "done parsing, totally %d chunks\n", msc.size());
+#if 0
+	TSC scit;
+	for (scit = msc.begin(); scit != msc.end(); scit++)
+	{
+		Chunk *c = const_cast<Chunk *>((*scit).second);
+
+		if (c->get_hosts().size() != 3)
+			fprintf(stderr, "replicas error!\n");
+		//c->dump();
+	}
+
+#endif
+
+	return msc.size();
+}
+
+} // namespace MRPerf
+
diff -Naur orig.ns-2.33/mrperf/datalayout.h ns-2.33/mrperf/datalayout.h
--- orig.ns-2.33/mrperf/datalayout.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/mrperf/datalayout.h	2009-07-07 03:39:03.000000000 -0400
@@ -0,0 +1,136 @@
+#ifndef NS_DATALAYOUT_H
+#define NS_DATALAYOUT_H
+
+#include <vector>
+#include <set>
+#include <string>
+#include <map>
+
+#include <libxml/tree.h>
+#include <libxml/parser.h>
+
+#include <tclcl.h>
+//#include "agent.h"
+//#include "app.h"
+
+using namespace std;
+
+namespace MRPerf {
+
+extern const int CHUNK_SIZE;
+
+class Chunk;
+class Disk;
+
+class Node: public TclObject {
+public:
+	Node();
+	~Node();
+
+	bool operator< (Node&);
+	void dump();
+//	virtual void process_data(int size, AppData* data);
+	char * schedule(Node *node);
+	const char * string() {return string_.c_str();}
+	Disk * rack_local(Chunk *c);
+
+	vector<Disk *> disks;
+	set<Chunk *> chunks;
+	Chunk * working_on;
+	double cycles_per_second;
+	std::string string_;
+	std::string rack_;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+
+};
+
+class Disk: public TclObject {
+public:
+	Disk() {};
+	~Disk() {};
+	const char * string();
+
+	set<Chunk *> chunks;
+	Node * host;
+	int id;
+	double read_bw;	//in MB/s
+	double write_bw; // in MB/s
+	std::string string_;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+template <class T>
+struct addrcomp {
+	bool operator() (const T& lhs, const T& rhs) const
+	{ return &lhs < &rhs; }
+};
+
+class Chunk: public TclObject {
+public:
+	Chunk();
+	Chunk(char *filename, int chunk, int offset, int length);
+	Chunk(char *);
+	~Chunk();
+
+	bool operator< (Chunk&);
+	void dump();
+
+	char * filename;
+	int chunk;
+	int offset;
+	int length;
+	set<Disk *>& get_host_disks() {return host_disks_;}
+	set<Node *>& get_hosts() {return hosts_;}
+	set<Node *>& get_workers() {return workers_;}
+	const char * string() {return string_.c_str();}
+
+	set<Disk *> host_disks_;
+	set<Node *> hosts_;
+	set<Node *> workers_;
+	std::string string_;
+	// It is possible to read _workers to determine status
+	//int status; /* todo, doing, done */
+	int finished;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+Disk * get_disk(const char *string);
+Chunk * get_chunk(const char * string);
+Node * get_node(const char * string);
+
+class DataLayout {
+public:
+	DataLayout();
+	~DataLayout();
+	static DataLayout& instance()
+	{
+		if (instance_ == NULL)
+			instance_ = new DataLayout();
+		return (*instance_);
+	}
+	int read_xml(const char * meta_xml);
+
+	void insert(Chunk&, Node&);
+
+	//multimap<Chunk, Node, addrcomp<Chunk> > *chunk_to_nodes;
+	//multimap<Node, Chunk, addrcomp<Node> > *node_to_chunks;
+	map<std::string, Node*> string_to_node;
+	map<std::string, Chunk*> string_to_chunk;
+
+protected:
+	int _parse(const char *meta_xml);
+	static DataLayout* instance_;
+	xmlDocPtr doc; /* the resulting document tree */
+
+};
+
+} // namespace MRPerf
+
+#endif // ifndef NS_DATALAYOUT_H
+
diff -Naur orig.ns-2.33/mrperf/mrperf.cc ns-2.33/mrperf/mrperf.cc
--- orig.ns-2.33/mrperf/mrperf.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/mrperf/mrperf.cc	2009-07-07 03:34:49.000000000 -0400
@@ -0,0 +1,571 @@
+#include <assert.h>
+#include <stdlib.h>
+
+#include "agent.h"
+#include "app.h"
+#include "mrperf.h"
+#include "datalayout.h"
+#include "thread.h"
+
+namespace MRPerf {
+
+
+static class MapTaskClass: public TclClass {
+public:
+	MapTaskClass() : TclClass("MRPerf/MapTask") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new MapTask);
+	}
+} maptask_class;
+ 
+int MapTask::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "worker") == 0) {
+			tcl.result(worker->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "chunk") == 0) {
+			tcl.result(chunk->string());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "disk") == 0) {
+			tcl.result(disk->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "finish") == 0) {
+			chunk->finished = 1;
+#if 0
+			// seems to cause segmentation fault
+			TMSC& msc = DataLayout::instance().string_to_chunk;
+			msc.erase(chunk->string_);
+			delete chunk;
+#endif
+
+			//for worker in chunk->workers(), ...
+
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "cpp_fail") == 0) {
+			chunk->finished = 0;
+			chunk->get_workers().erase(worker);
+			//printf("number of workers: %d\n", chunk->get_workers().size());
+			return TCL_OK;
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "def-schedule") == 0) {
+			Node *node = (Node *)(TclObject::lookup(argv[2]));
+			Scheduler *sched = &Scheduler::instance();
+			if (node == NULL) {
+				tcl.add_errorf("Wrong node name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			MapTask *ret = sched->schedule(this, node);
+			if (ret == NULL)
+				tcl.result("");
+			else
+				tcl.result(this->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "remote-schedule") == 0) {
+			Node *node = (Node *)(TclObject::lookup(argv[2]));
+			Scheduler *sched = &Scheduler::instance();
+			if (node == NULL) {
+				tcl.add_errorf("Wrong node name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			MapTask *ret = sched->remote_schedule(this, node);
+			if (ret == NULL)
+				tcl.result("");
+			else
+				tcl.result(this->name());
+			return TCL_OK;
+		}
+	}
+	else if (argc == 4) {
+		if (strcmp(argv[1], "fixed-schedule") == 0) {
+			Node *worker = (Node *)(TclObject::lookup(argv[2]));
+			Node *host = (Node *)(TclObject::lookup(argv[3]));
+			if (worker == NULL || host == NULL) {
+				tcl.add_errorf("Wrong node name %s or %s", \
+						argv[2], argv[3]);
+				return TCL_ERROR;
+			}
+			Scheduler *sched = &Scheduler::instance();
+			MapTask *ret = sched->fixed_schedule(this,worker,host);
+			if (ret == NULL)
+				tcl.result("");
+			else
+				tcl.result(this->name());
+			return TCL_OK;
+		}
+	}
+#if 0
+	if (argc == 3) {
+		if (strcmp(argv[1], "schedule") == 0) {
+			Node *node = (Node *)(TclObject::lookup(argv[2]));
+			Chunk *chunk;
+			if (node == NULL) {
+				tcl.add_errorf("Wrong node name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			task = schedule(node);
+			if (chunk == NULL)
+				tcl.result("");
+			else
+				tcl.result(task->string());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "find") == 0) {
+			// TODO: this is not correct for multiple replicas.
+			Chunk* chunk = get_chunk(argv[2]);
+			set<Node *>& s = chunk->get_hosts();
+			Node * first = *(s.begin());
+			tcl.result(first->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "finish") == 0) {
+			Chunk* chunk = get_chunk(argv[2]);
+			chunk->finished = 1;
+
+			//for worker in chunk->workers(), ...
+
+			return TCL_OK;
+		}
+	}
+#endif
+
+	return (TclObject::command(argc, argv));
+}
+
+void MapTask::dispatch(Node *n, Chunk *c, Disk *d)
+{
+	c->get_workers().insert(n);
+	//n->working_on = c;
+	worker = n;
+	chunk = c;
+	disk = d;
+}
+
+static class ReduceTaskClass: public TclClass {
+public:
+	ReduceTaskClass() : TclClass("MRPerf/ReduceTask") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new ReduceTask);
+	}
+} reducetask_class;
+ 
+int ReduceTask::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "worker") == 0) {
+			tcl.result(worker->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "disk") == 0) {
+			tcl.result(disk->name());
+
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "def-schedule") == 0) {
+			Node *node = (Node *)(TclObject::lookup(argv[2]));
+			Scheduler *sched = &Scheduler::instance();
+			if (node == NULL) {
+				tcl.add_errorf("Wrong node name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			ReduceTask *ret = sched->reducer_schedule(this, node);
+			if (ret == NULL)
+				tcl.result("");
+			else
+				tcl.result(this->name());
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+
+static class SchedulerClass: public TclClass {
+public:
+	SchedulerClass() : TclClass("MRPerf/Scheduler") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new Scheduler);
+	}
+} scheduler_class;
+
+Scheduler * Scheduler::instance_;
+
+int Scheduler::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+	if ((instance_ == 0) || (instance_ != this))
+		instance_ = this;
+
+	//fprintf(stderr, "in scheduler command()\n");
+	//fprintf(stderr, "%d, %s, %s\n", argc, argv[1], argv[2]);
+
+	if (argc == 3) {
+		if (strcmp(argv[1], "read-metadata") == 0) {
+			int chunks = DataLayout::instance().read_xml(argv[2]);
+			if (chunks < 0) {
+				tcl.add_errorf("Data Layout parse error");
+				return TCL_ERROR;
+			}
+			char buf[16];
+			sprintf(buf, "%d", chunks);
+			tcl.result(buf);
+			return TCL_OK;
+		}
+#if 0
+		else if (strcmp(argv[1], "schedule") == 0) {
+			// deprecated on 2008.7.11, use MapTask schedule instead
+			Node *node = (Node *)(TclObject::lookup(argv[2]));
+			MapTask *task;
+			if (node == NULL) {
+				tcl.add_errorf("Wrong node name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			MapTask *ret = schedule(task, node);
+			if (ret == NULL)
+				tcl.result("");
+			else
+				tcl.result(task->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "find") == 0) {
+			// TODO: this is not correct for multiple replicas.
+			Chunk* chunk = get_chunk(argv[2]);
+			set<Node *>& s = chunk->get_hosts();
+			Node * first = *(s.begin());
+			tcl.result(first->name());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "finish") == 0) {
+			// obseleted on 2008.7.11. use MapTask finish instead.
+			Chunk* chunk = get_chunk(argv[2]);
+			chunk->finished = 1;
+
+			//for worker in chunk->workers(), ...
+
+			return TCL_OK;
+		}
+#endif
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+MapTask * Scheduler::remote_schedule(MapTask *task, Node *node)
+{
+	TSC scit;
+	TMSC& msc = DataLayout::instance().string_to_chunk;
+	//fprintf(stderr, "%p %p\n", msc.begin(), msc.end());
+	Disk *d = *(node->disks.begin());
+	for (scit = msc.begin(); scit != msc.end(); scit++)
+	{
+		Chunk* c = const_cast<Chunk *>((*scit).second);
+		if (c == NULL)
+			fprintf(stderr, "Error: NULL on %s\n", scit->first.c_str());
+
+		if (c->get_host_disks().find(d) != c->get_host_disks().end())
+			continue;
+
+		if (c->finished == 0 && c->get_workers().empty())
+		{
+			Disk * d = replica_selector(node, c);
+			task->dispatch(node, c, d);
+			fprintf(stderr, "%s: scheduled to %s, on %s\n", c->string(),
+						node->string_.c_str(),
+						d->host->string_.c_str());
+			return task;
+		}
+	}
+
+	set<Chunk *>::iterator cit;
+	vector<Disk *>::iterator dit;
+	for (dit = node->disks.begin(); dit != node->disks.end(); dit++)
+	for (cit = (*dit)->chunks.begin(); cit != (*dit)->chunks.end(); cit++)
+	{
+		Chunk *c = *cit;
+
+		if (c->finished == 0 && c->get_workers().empty())
+		{
+			Disk * d = remote_replica_selector(node, c);
+			task->dispatch(node, c, d);
+			fprintf(stderr, "%s: scheduled to %s, on %s (could be local)\n", \
+						c->string(), node->string_.c_str(), \
+						d->host->string_.c_str());
+			//fprintf(stderr, "task %p. chunk %p\n", task, c);
+			return task;
+		}
+	}
+
+	// all chunks finished.
+	return NULL;
+}
+
+MapTask * Scheduler::fixed_schedule(MapTask *task, Node *worker, Node *host)
+{
+	TSC scit;
+	TMSC& msc = DataLayout::instance().string_to_chunk;
+	//fprintf(stderr, "%p %p\n", msc.begin(), msc.end());
+	Disk *d = *(host->disks.begin());
+	for (scit = msc.begin(); scit != msc.end(); scit++)
+	{
+		Chunk* c = const_cast<Chunk *>((*scit).second);
+		if (c == NULL)
+			fprintf(stderr, "Error: NULL on %s\n", scit->first.c_str());
+
+		if (c->finished != 0 || !c->get_workers().empty() )
+			continue;
+
+		// put chunk on host
+		set<Disk *> *disks = &c->get_host_disks();
+		if (disks->find(d) == disks->end())
+		{
+			disks->insert(d);
+			d->chunks.insert(c);
+		}
+
+		task->dispatch(worker, c, d);
+		fprintf(stderr, "%s: fixed scheduled to %s, on %s\n", \
+			c->string(), worker->string_.c_str(), \
+			host->string_.c_str());
+		return task;
+	}
+
+	// all chunks finished.
+	return NULL;
+}
+
+MapTask * Scheduler::schedule(MapTask *task, Node *node)
+{
+	//fprintf(stderr, "in schedule(), node %s\n", node->string_.c_str());
+
+	//node->dump();
+
+	set<Chunk *>::iterator cit;
+	vector<Disk *>::iterator dit;
+	for (dit = node->disks.begin(); dit != node->disks.end(); dit++)
+	for (cit = (*dit)->chunks.begin(); cit != (*dit)->chunks.end(); cit++)
+	{
+		Chunk *c = *cit;
+
+#if 0
+		//if (strcmp(c->string(), "file_00000000:0:0:131072") == 0)
+		{
+			TMSC& msc = DataLayout::instance().string_to_chunk;
+			TSC scit;
+			scit = msc.find(c->string());
+			//fprintf(stderr, "0:0 again, %p, in msc %p\n", c, scit->second);
+			if (c != scit->second)
+			{
+				fprintf(stderr, "chunk %s, node %s, disk %d\n", c->string(), node->string(), (*dit)->id);
+			}
+		}
+#endif
+		if (c->finished == 0 && c->get_workers().empty())
+		{
+			task->dispatch(node, c, *dit);
+			fprintf(stderr, "%s: scheduled to %s locally\n", c->string(),
+						node->string_.c_str());
+			//fprintf(stderr, "task %p. chunk %p\n", task, c);
+			return task;
+		}
+	}
+
+	// we reach here because node cannot find a local chunk to work on.
+	// do a scan on msc, and find any available chunk.
+	TSC scit;
+	TMSC& msc = DataLayout::instance().string_to_chunk;
+	//fprintf(stderr, "%p %p\n", msc.begin(), msc.end());
+
+	//TODO: clearly I can skip all finished chunks. Maybe managing them
+	//	in a separate structure would be better/faster.
+	//search for rack-local chunks
+	for (scit = msc.begin(); scit != msc.end(); scit++)
+	{
+		Chunk* c = const_cast<Chunk *>((*scit).second);
+		if (c == NULL)
+			fprintf(stderr, "Error: NULL on %s\n", \
+					scit->first.c_str());
+
+		if (c->finished == 0 && c->get_workers().empty())
+		{
+			//Disk * d = replica_selector(node, c);
+			Disk * d = node->rack_local(c);
+			if (d == NULL)
+				continue;
+			task->dispatch(node, c, d);
+			fprintf(stderr, "%s: rack local to %s, on %s\n", \
+					c->string(),
+					node->string_.c_str(),
+					d->host->string_.c_str());
+			return task;
+		}
+	}
+
+	// rack-local not found. any chunk would be fine.
+	for (scit = msc.begin(); scit != msc.end(); scit++)
+	{
+		Chunk* c = const_cast<Chunk *>((*scit).second);
+		if (c == NULL)
+			fprintf(stderr, "Error: NULL on %s\n", \
+					scit->first.c_str());
+
+		if (c->finished == 0 && c->get_workers().empty())
+		{
+			Disk * d = replica_selector(node, c);
+			task->dispatch(node, c, d);
+			fprintf(stderr, "%s: rack remote to %s, on %s\n", \
+					c->string(),
+					node->string_.c_str(),
+					d->host->string_.c_str());
+			return task;
+		}
+	}
+
+	// all chunks finished.
+	return NULL;
+}
+
+Disk *Scheduler::replica_selector(Node *n, Chunk *c)
+{
+	static int i = 0;
+	(void)n;
+
+	int r = i % (c->get_host_disks().size());
+	i++;
+	set<Disk*>::iterator dit = c->get_host_disks().begin();
+	for (int j = 0; j < r; j++)
+		dit ++;
+
+	return *dit;
+
+}
+
+Disk *Scheduler::remote_replica_selector(Node *n, Chunk *c)
+{
+	set<Disk*>::iterator dit;
+	for (dit = c->get_host_disks().begin(); dit != c->get_host_disks().end(); dit++) {
+		if (*dit != *(n->disks.begin()))
+			break;
+	}
+	return *dit;
+}
+
+ReduceTask * Scheduler::reducer_schedule(ReduceTask *task, Node *node)
+{
+	Disk *d = *(node->disks.begin());
+	task->worker = node;
+	task->disk = d;
+	return task;
+}
+
+
+static class DequeClass: public TclClass {
+public:
+	DequeClass() : TclClass("MRPerf/Deque") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new Deque);
+	}
+} deque_class;
+ 
+int Deque::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+
+	if (1) {
+	// put pointers to TclObject in std::deque
+	if (argc == 2) {
+		if (strcmp(argv[1], "pop_back") == 0) {
+			TclObject *obj = obj_deque.back();
+			if (obj == NULL) {
+				tcl.resultf("pop obj from an empty deque\n");
+				return TCL_ERROR;
+			}
+			obj_deque.pop_back();
+			tcl.result(obj->name());
+			return TCL_OK;
+		} else if (strcmp(argv[1], "pop_front") == 0) {
+			TclObject *obj = obj_deque.front();
+			if (obj == NULL) {
+				tcl.resultf("pop obj from an empty deque\n");
+				return TCL_ERROR;
+			}
+			obj_deque.pop_front();
+			tcl.result(obj->name());
+			return TCL_OK;
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "push_back") == 0) {
+			TclObject *obj = TclObject::lookup(argv[2]);
+			if (obj == NULL) {
+				tcl.add_errorf("Wrong object name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			obj_deque.push_back(obj);
+			return TCL_OK;
+		} else if (strcmp(argv[1], "push_front") == 0) {
+			TclObject *obj = TclObject::lookup(argv[2]);
+			if (obj == NULL) {
+				tcl.add_errorf("Wrong object name %s", argv[2]);
+				return TCL_ERROR;
+			}
+			obj_deque.push_front(obj);
+			return TCL_OK;
+		}
+	}
+	} else {
+	// put std::string in std::deque
+	if (argc == 2) {
+		if (strcmp(argv[1], "pop_back") == 0) {
+			std::string &obj = str_deque.back();
+#if 0
+			if (obj == NULL) {
+				tcl.resultf("pop obj from an empty deque\n");
+				return TCL_ERROR;
+			}
+#endif
+			str_deque.pop_back();
+			tcl.result(obj.c_str());
+			delete &obj;
+			return TCL_OK;
+		} else if (strcmp(argv[1], "pop_front") == 0) {
+			std::string &obj = str_deque.front();
+#if 0
+			if (obj == NULL) {
+				tcl.resultf("pop obj from an empty deque\n");
+				return TCL_ERROR;
+			}
+#endif
+			str_deque.pop_front();
+			tcl.result(obj.c_str());
+			delete &obj;
+			return TCL_OK;
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "push_back") == 0) {
+			std::string *obj = new std::string(argv[2]);
+			str_deque.push_back(*obj);
+			return TCL_OK;
+		} else if (strcmp(argv[1], "push_front") == 0) {
+			std::string *obj = new std::string(argv[2]);
+			str_deque.push_front(*obj);
+			return TCL_OK;
+		}
+	}
+	} // end if-else std::string or TclObject*
+
+	return (TclObject::command(argc, argv));
+}
+
+
+} // namespace MRPerf
+
diff -Naur orig.ns-2.33/mrperf/mrperf.h ns-2.33/mrperf/mrperf.h
--- orig.ns-2.33/mrperf/mrperf.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/mrperf/mrperf.h	2009-07-07 03:34:11.000000000 -0400
@@ -0,0 +1,101 @@
+#ifndef MRPERF_MRPERF_H
+#define MRPERF_MRPERF_H
+
+#include <set>
+#include <map>
+#include <string>
+#include <vector>
+#include <list>
+#include <deque>
+#include <iostream>
+
+//#include "datalayout.h"
+
+using namespace std;
+
+
+namespace MRPerf {
+
+class Node;
+class Chunk;
+class Disk;
+
+typedef map<std::string, Node*> TMSN;
+typedef map<std::string, Chunk*> TMSC;
+typedef map<std::string, Node*>::iterator TSN;
+typedef map<std::string, Chunk*>::iterator TSC;
+
+class MapTask: public TclObject {
+public:
+	MapTask() {}
+	MapTask(Node *n, Chunk *c, Disk *d) : worker(n), chunk(c), disk(d) {}
+	~MapTask() {}
+
+	void dispatch(Node *n, Chunk *c, Disk *d);
+	const char * string();
+
+	Node *worker;	// which node will work on it
+	Chunk *chunk;	// which chunk to work on
+	Disk * disk;	// where the chunk is supposed to be fetched
+	std::string string_;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+class ReduceTask: public TclObject {
+public:
+	ReduceTask() {}
+	~ReduceTask() {}
+
+	Node *worker;
+	Disk *disk;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+class DataLayout;
+
+class Scheduler: public TclObject {
+public:
+	Scheduler() {}
+	~Scheduler() {}
+	static Scheduler& instance() {
+		if (instance_ == NULL)
+			instance_ = new Scheduler;
+		return (*instance_);
+	}
+
+	MapTask* schedule(MapTask*, Node *);
+	MapTask* remote_schedule(MapTask*, Node *);
+	MapTask * fixed_schedule(MapTask *task, Node *worker, Node *host);
+	Disk *replica_selector(Node *n, Chunk *c);
+	Disk *remote_replica_selector(Node *n, Chunk *c);
+
+	ReduceTask* reducer_schedule(ReduceTask*, Node *);
+
+	DataLayout* dl;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+	//void _parse(char *meta_xml);
+	static Scheduler* instance_;
+	Chunk *chunk_;
+};
+
+class Deque: public TclObject {
+public:
+	Deque() {}
+	~Deque() {}
+
+	std::deque<std::string> str_deque;
+	std::deque<TclObject *> obj_deque;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+} // namespace MRPerf
+
+#endif // ifndef MRPERF_MRPERF_H
diff -Naur orig.ns-2.33/mrperf/thread.cc ns-2.33/mrperf/thread.cc
--- orig.ns-2.33/mrperf/thread.cc	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/mrperf/thread.cc	2009-07-07 03:41:01.000000000 -0400
@@ -0,0 +1,358 @@
+#include <set>
+#include <list>
+#include <iostream>
+
+#include <stdlib.h>
+
+#include "scheduler.h"
+#include "thread.h"
+
+using namespace std;
+
+namespace MRPerf {
+
+double g_epsilon=10000;
+
+static class TMultiChainClass: public TclClass {
+public:
+	TMultiChainClass() : TclClass("MRPerf/Thread/MultiChain") {}
+	TclObject* create(int argc, const char*const* argv) {
+		if (argc != 5)
+			return NULL;
+		int depth = atoi(argv[4]);
+		return (new TMultiChain(depth));
+	}
+} tmultichain_class;
+
+int TMultiChain::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "next-task") == 0) {
+			running -= 1;
+			//printf("before next, %d running, %d waiting\n", running, chlist.size());
+			next_task();
+			//printf("after next, %d running, %d waiting\n", running, chlist.size());
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "size") == 0) {
+			tcl.resultf("%d", chlist.size());
+			return TCL_OK;
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "attach") == 0) {
+			std::string * task = new std::string(argv[2]);
+			//printf("attach %s, %d running, %d waiting\n", argv[2], running, chlist.size());
+			attach(task);
+			//printf("after attach %s, %d running, %d waiting\n", argv[2], running, chlist.size());
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+void TMultiChain::run_first()
+{
+}
+
+void TMultiChain::next_task()
+{
+	if (chlist.empty())
+		return;
+	if (running >= depth)
+		return;
+
+	Tcl& tcl = Tcl::instance();
+	std::string *task = chlist.front();
+	if (task == NULL)
+		return;
+	chlist.pop_front();
+	running += 1;
+	tcl.evalf("%s run", task->c_str());
+	delete task;
+}
+
+void TMultiChain::attach(std::string *task)
+{
+	bool open = (running < depth);
+	chlist.push_back(task);
+
+	if (open == 1)
+		next_task();
+}
+
+static class TChainClass: public TclClass {
+public:
+	TChainClass() : TclClass("MRPerf/Thread/Chain") {}
+	TclObject* create(int argc, const char*const* argv) {
+		return (new TChain);
+	}
+} tchain_class;
+
+int TChain::command(int argc, const char*const* argv) {
+	//Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "next-task") == 0) {
+			next_task();
+			return TCL_OK;
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "attach") == 0) {
+			TTask *task = (TTask *)(TclObject::lookup(argv[2]));
+			attach(task);
+			return TCL_OK;
+		}
+		else if (strcmp(argv[1], "insert") == 0) {
+			TTask *task = (TTask *)(TclObject::lookup(argv[2]));
+			insert(task);
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+void TChain::run_first()
+{
+	Tcl& tcl = Tcl::instance();
+	TTask *task = chlist.front();
+	task->chain = this;
+	insert_it = chlist.begin();
+	insert_it++;
+	//printf("insert_it=%d\n", distance(insert_it, chlist.begin()));
+	tcl.evalf("%s", task->_command.c_str());
+	if (task->type == 0)
+		next_task();
+	else if (task->type == 1 && task->units < g_epsilon)
+	{
+		printf("command='%s'\n", task->_command.c_str());
+		printf("chain=%s units=%lf epsilon=%lf\n", this->name(), task->units, g_epsilon);
+	}
+}
+
+void TChain::next_task()
+{
+	if (chlist.size() > 0)
+	{
+		TTask *task = chlist.front();
+		Tcl& tcl = Tcl::instance();
+		chlist.pop_front();
+		//printf("self %s\n", task->_self.c_str());
+		//tcl.evalf("puts [%s units]", task->_self.c_str());
+		tcl.evalf("delete %s", task->_self.c_str());
+	}
+	else {
+		printf ("error, chlist.size == %d, chain %s\n", chlist.size(), this->name());
+	}
+	if (!chlist.empty())
+		run_first();
+}
+
+void TChain::attach(TTask *task)
+{
+	bool empty = chlist.empty();
+	chlist.push_back(task);
+
+	if (empty)
+		run_first();
+}
+
+void TChain::insert(TTask *task)
+{
+	if (chlist.empty())
+		attach(task);
+	else {
+		//printf("before insert\n");
+		//printf("size=%d\n", chlist.size());
+		//printf("insert_it=%d\n", distance(insert_it, chlist.begin()));
+		chlist.insert(insert_it, task);
+		//printf("insert done\n");
+	}
+}
+
+static class TaskListClass: public TclClass {
+public:
+	TaskListClass() : TclClass("MRPerf/Thread/TaskList") {}
+	TclObject* create(int argc, const char*const* argv) {
+		if (argc != 6)
+			return NULL;
+		double bw = atof(argv[4]);
+		int num = atoi(argv[5]);
+		if (num <= 0 || bw <= 0)
+			return NULL;
+		TTaskList *tl = new TTaskList(bw, num);
+
+		//printf("%s %s %s %s\n", argv[0], argv[1], argv[2], argv[3]);
+		if (strcmp(argv[0], argv[1]) != 0) {
+			cout << "argv[0] != argv[1], " << argv[0] << " != " \
+				<< argv[1] << endl;
+		}
+		strcpy(tl->self, argv[1]);
+		return tl;
+	}
+} chain_class;
+
+int TTaskList::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 2) {
+		if (strcmp(argv[1], "next1task") == 0) {
+			next_task();
+			return TCL_OK;
+		}
+	}
+	else if (argc == 3) {
+		if (strcmp(argv[1], "insert") == 0) {
+			TTask *newtask = (TTask *)(TclObject::lookup(argv[2]));
+			if (!lst.empty())
+			{
+				//cout << "last_uid: " << last_uid << endl;
+				tcl.evalf("$ns cancel %s", last_uid);
+			}
+
+			recalculate();
+
+			list<TTask *>::iterator it;
+			for (it = lst.begin(); it != lst.end(); it ++) {
+				TTask *task = *it;
+				if (task->units > newtask->units)
+					break;
+			}
+			lst.insert(it, newtask);
+
+			schedule_first();
+
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+void TTaskList::update_share()
+{
+	int count = lst.size();
+	if (count > num)
+		share = 1.0 * num / count;
+	else
+		share = 1.0;
+
+}
+
+void TTaskList::recalculate()
+{
+	double now = ::Scheduler::instance().clock();
+	if (now == last)
+		return;
+
+	update_share();
+
+	list<TTask *>::iterator it;
+	for (it = lst.begin(); it != lst.end(); it++)
+	{
+		TTask * task = *it;
+		if (task->units < bw*share*(now-last) - g_epsilon)
+		{
+			cout << "+++++++++ error" << endl;
+			cout << task->units << ", " << task->_command << endl;
+			cout << task->units << " < " << bw << " * " << share \
+				<< " * " << (now-last) << endl;
+			cout << now << "     " << last << endl;
+			cout << last_uid << endl;
+		}
+		task->units = task->units - bw*share*(now-last);
+	}
+}
+
+void TTaskList::schedule_first()
+{
+	Tcl& tcl = Tcl::instance();
+	TTask * task = lst.front();
+	update_share();
+	double delay = (task->units/share) / bw;
+
+	last = ::Scheduler::instance().clock();
+	//cout << delay << ", " << last << endl;
+	if (delay <= 0) {
+		if (delay < -g_epsilon)
+			cout << "delay < 0: " << delay << endl;
+		next_task();
+	}
+	else {
+		tcl.evalf("$ns after %lf \"%s next1task\"", delay, self);
+		strcpy(last_uid, tcl.result());
+		//cout << tcl.result() << endl;
+		//cout << last_uid << endl;
+	}
+}
+
+void TTaskList::next_task()
+{
+	if (!lst.empty()) {
+		recalculate();
+
+		TTask * task = lst.front();
+		if (task->units > g_epsilon || task->units < -g_epsilon) {
+			cout << "******* " << task->units << ", should be 0" \
+				<< endl;
+			cout << "task " << task->units << ", " \
+				<< task->_command << endl;
+			cout << num << ", " << lst.size() << ", " << share \
+				<< ", " << bw << endl;
+		}
+
+		lst.pop_front();
+
+		if (!lst.empty())
+			schedule_first();
+
+		task->chain->next_task();
+	}
+	else
+		cout << "------- error: run from an empty tasklist" << endl;
+}
+
+static class TTaskClass: public TclClass {
+public:
+	TTaskClass() : TclClass("MRPerf/Thread/Task") {}
+	TclObject* create(int argc, const char*const* argv) {
+		TTask *t = new TTask();
+		t->_self = argv[1];
+		return (t);
+	}
+} ttask_class;
+
+int TTask::command(int argc, const char*const* argv) {
+	Tcl& tcl = Tcl::instance();
+
+	if (argc == 5) {
+		if (strcmp(argv[1], "conf") == 0) {
+			units = atof(argv[2]);
+			_command = argv[3];
+			type = atoi(argv[4]);
+
+			if (units < 0 || _command.empty() ) {
+				cout << "====== error" << endl;
+				exit(1);
+			}
+			return TCL_OK;
+		}
+	}
+	else if (argc == 2) {
+		if (strcmp(argv[1], "units") == 0) {
+			char buffer[256];
+			sprintf(buffer, "%lg", units);
+			tcl.result(buffer);
+			return TCL_OK;
+		}
+	}
+
+	return (TclObject::command(argc, argv));
+}
+
+} // namespace MRPerf
+
diff -Naur orig.ns-2.33/mrperf/thread.h ns-2.33/mrperf/thread.h
--- orig.ns-2.33/mrperf/thread.h	1969-12-31 19:00:00.000000000 -0500
+++ ns-2.33/mrperf/thread.h	2009-07-07 03:39:18.000000000 -0400
@@ -0,0 +1,90 @@
+#ifndef MRPERF_THREAD_H
+#define MRPERF_THREAD_H
+
+#include <string>
+#include <list>
+
+#include <tclcl.h>
+
+using namespace std;
+
+namespace MRPerf {
+
+extern double g_epsilon;
+
+class TChain;
+class TTask: public TclObject {
+public:
+	TTask() {}
+	~TTask() {}
+
+	double units;
+	std::string _command;
+	std::string _self;
+	TChain *chain;
+	int type;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+class TChain: public TclObject {
+public:
+	TChain() {}
+	~TChain() {}
+
+	void run_first();
+	void attach(TTask *);
+	void insert(TTask *);
+	void next_task();
+	void o1(TTask *task = NULL);
+
+	list<TTask *> chlist;
+	std::list<TTask *>::iterator insert_it;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+class TMultiChain: public TclObject {
+public:
+	TMultiChain(int d) : depth(d), running(0) {}
+	~TMultiChain() {}
+
+	void run_first();
+	void attach(std::string *);
+	void next_task();
+
+	list<std::string *> chlist;
+	int depth;
+	int running;
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+class TTaskList: public TclObject {
+public:
+	TTaskList(double b, int n): bw(b), num(n), share(1.0) {}
+	~TTaskList() {}
+
+	list<TTask *> lst;
+	double bw;
+	int num;
+	double share;
+	double last;
+	char self[256];
+	char last_uid[256];
+
+	void update_share();
+	void recalculate();
+	void schedule_first();
+	void next_task();
+
+protected:
+	virtual int command(int argc, const char*const* argv);
+};
+
+} // namespace MRPerf
+
+#endif // ifndef MRPERF_THREAD_H
diff -Naur orig.ns-2.33/tcp/tcp-full.cc ns-2.33/tcp/tcp-full.cc
--- orig.ns-2.33/tcp/tcp-full.cc	2008-03-31 22:00:28.000000000 -0400
+++ ns-2.33/tcp/tcp-full.cc	2009-06-27 14:32:38.000000000 -0400
@@ -548,11 +548,11 @@
 		tcph->reason());
 }
 
-char *
+const char *
 FullTcpAgent::flagstr(int hflags)
 {
 	// update this if tcp header flags change
-	static char *flagstrs[28] = {
+	static const char *flagstrs[28] = {
 		"<null>", "<FIN>", "<SYN>", "<SYN,FIN>",	// 0-3
 		"<?>", "<?,FIN>", "<?,SYN>", "<?,SYN,FIN>",	// 4-7
 		"<PSH>", "<PSH,FIN>", "<PSH,SYN>", "<PSH,SYN,FIN>", // 0x08-0x0b
@@ -580,10 +580,10 @@
 	return (flagstrs[hflags]);
 }
 
-char *
+const char *
 FullTcpAgent::statestr(int state)
 {
-	static char *statestrs[TCP_NSTATES] = {
+	static const char *statestrs[TCP_NSTATES] = {
 		"CLOSED", "LISTEN", "SYN_SENT", "SYN_RCVD",
 		"ESTABLISHED", "CLOSE_WAIT", "FIN_WAIT_1", "CLOSING",
 		"LAST_ACK", "FIN_WAIT_2"
diff -Naur orig.ns-2.33/tcp/tcp-full.h ns-2.33/tcp/tcp-full.h
--- orig.ns-2.33/tcp/tcp-full.h	2008-03-31 22:00:28.000000000 -0400
+++ ns-2.33/tcp/tcp-full.h	2009-06-27 14:32:55.000000000 -0400
@@ -219,8 +219,8 @@
 	DelAckTimer delack_timer_;	// other timers in tcp.h
 	void cancel_timers();		// cancel all timers
 	void prpkt(Packet*);		// print packet (debugging helper)
-	char *flagstr(int);		// print header flags as symbols
-	char *statestr(int);		// print states as symbols
+	const char *flagstr(int);		// print header flags as symbols
+	const char *statestr(int);		// print states as symbols
 
 	/*
 	* the following are part of a tcpcb in "real" RFC793 TCP
diff -Naur orig.ns-2.33/tcp/tcp-sink.cc ns-2.33/tcp/tcp-sink.cc
--- orig.ns-2.33/tcp/tcp-sink.cc	2008-03-31 22:00:28.000000000 -0400
+++ ns-2.33/tcp/tcp-sink.cc	2009-06-27 14:31:08.000000000 -0400
@@ -324,7 +324,7 @@
 	if ( (sf != 0 && sf->ect()) || of->ect() )
 		// Set EcnEcho bit.  
 		nf->ecnecho() = acker_->ecn_unacked();
-	if (!of->ect() && of->ecnecho() ||
+	if ((!of->ect() && of->ecnecho()) ||
 		(sf != 0 && !sf->ect() && sf->ecnecho()) ) {
 		 // This is the negotiation for ECN-capability.
 		 // We are not checking for of->cong_action() also. 
diff -Naur orig.ns-2.33/tcp/tcp.cc ns-2.33/tcp/tcp.cc
--- orig.ns-2.33/tcp/tcp.cc	2008-03-31 22:00:28.000000000 -0400
+++ ns-2.33/tcp/tcp.cc	2009-06-06 17:58:35.000000000 -0400
@@ -614,6 +614,12 @@
         // RFC2988 allows a maximum for the backed-off RTO of 60 seconds.
         // This is applied by maxrto_.
 
+	if (t_backoff_ < 0)
+	{
+		t_backoff_ >>= 1;
+		t_backoff_ = -t_backoff_;
+	}
+
 	if (t_backoff_ > 8) {
 		/*
 		 * If backed off this far, clobber the srtt
diff -Naur orig.ns-2.33/trace/trace.cc ns-2.33/trace/trace.cc
--- orig.ns-2.33/trace/trace.cc	2008-03-31 22:00:24.000000000 -0400
+++ ns-2.33/trace/trace.cc	2009-06-27 14:30:03.000000000 -0400
@@ -180,7 +180,7 @@
 }
 
 
-char* srm_names[] = {
+const char* srm_names[] = {
         SRM_NAMES
 };
 
